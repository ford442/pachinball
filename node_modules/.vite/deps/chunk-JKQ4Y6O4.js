import {
  extractMinAndMax,
  extractMinAndMaxIndexed
} from "./chunk-LD4QXNXE.js";
import {
  Node
} from "./chunk-IOOGDP2L.js";
import {
  WebGPUPerfCounter
} from "./chunk-S52HQE73.js";
import {
  PickingInfo
} from "./chunk-YCDQC3XL.js";
import {
  UniformBuffer
} from "./chunk-YRW5V5ET.js";
import {
  Axis,
  CreateImageBitmapFromSource,
  Engine,
  ExitFullscreen,
  ExitPointerlock,
  FromHalfFloat,
  GetFontOffset,
  PerformanceMonitor,
  RenderTargetWrapper,
  RequestFullscreen,
  RequestPointerlock,
  ResizeImageBitmap,
  SphericalPolynomial,
  _CommonDispose,
  _CommonInit
} from "./chunk-4QSV5Q2G.js";
import {
  PerfCounter
} from "./chunk-LJSODA3L.js";
import {
  SerializationHelper
} from "./chunk-3MVLSGGR.js";
import {
  __decorate,
  nativeOverride,
  serialize,
  serializeAsQuaternion,
  serializeAsVector3
} from "./chunk-WT6I64UT.js";
import {
  Color3,
  Color4
} from "./chunk-RZSA2DYX.js";
import {
  BuildArray,
  Epsilon,
  Matrix,
  Quaternion,
  TmpVectors,
  Vector3,
  Vector4
} from "./chunk-JZRX5VBE.js";
import {
  DrawWrapper
} from "./chunk-GU6CF5V3.js";
import {
  Buffer,
  VertexBuffer
} from "./chunk-2HBTEC6O.js";
import {
  Tools
} from "./chunk-HHB3XDHH.js";
import {
  ErrorCodes,
  RuntimeError
} from "./chunk-MB5YOKOA.js";
import {
  GetClass,
  RegisterClass
} from "./chunk-LMH7SWDS.js";
import {
  ILog2
} from "./chunk-X4PSP3XC.js";
import {
  GetTypeForDepthTexture,
  HasStencilAspect,
  IsWrapper
} from "./chunk-Q27OV4D7.js";
import {
  DataBuffer
} from "./chunk-I2PO3XEU.js";
import {
  AbstractEngine,
  DepthCullingState,
  Effect,
  Finalize,
  Initialize,
  InternalTexture,
  Process,
  StencilStateComposer,
  allocateAndCopyTypedBuffer,
  resetCachedPipeline
} from "./chunk-M3ALQ324.js";
import {
  _WarnImport
} from "./chunk-4GUORC2E.js";
import {
  IsWindowObjectExist
} from "./chunk-AZNEH5GV.js";
import {
  PerformanceConfigurator
} from "./chunk-AYMFJBP3.js";
import {
  Observable
} from "./chunk-GWFZRJMO.js";
import {
  Logger
} from "./chunk-OJJXGLTO.js";
import {
  ShaderStore
} from "./chunk-FX6MN5HL.js";

// node_modules/@babylonjs/core/Engines/nullEngine.js
var NullEngineOptions = class {
  constructor() {
    this.renderWidth = 512;
    this.renderHeight = 256;
    this.textureSize = 512;
    this.deterministicLockstep = false;
    this.lockstepMaxSteps = 4;
  }
};
var NullEngine = class extends Engine {
  /**
   * Gets a boolean indicating that the engine is running in deterministic lock step mode
   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep
   * @returns true if engine is in deterministic lock step mode
   */
  isDeterministicLockStep() {
    return this._options.deterministicLockstep;
  }
  /**
   * Gets the max steps when engine is running in deterministic lock step
   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep
   * @returns the max steps
   */
  getLockstepMaxSteps() {
    return this._options.lockstepMaxSteps;
  }
  /**
   * Gets the current hardware scaling level.
   * By default the hardware scaling level is computed from the window device ratio.
   * if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.
   * @returns a number indicating the current hardware scaling level
   */
  getHardwareScalingLevel() {
    return 1;
  }
  constructor(options = new NullEngineOptions()) {
    super(null);
    if (options.deterministicLockstep === void 0) {
      options.deterministicLockstep = false;
    }
    if (options.timeStep !== void 0) {
      this._timeStep = options.timeStep;
    }
    if (options.lockstepMaxSteps === void 0) {
      options.lockstepMaxSteps = 4;
    }
    this._options = options;
    PerformanceConfigurator.SetMatrixPrecision(!!options.useHighPrecisionMatrix);
    this._caps = {
      maxTexturesImageUnits: 16,
      maxVertexTextureImageUnits: 16,
      maxCombinedTexturesImageUnits: 32,
      maxTextureSize: 512,
      maxCubemapTextureSize: 512,
      maxDrawBuffers: 0,
      maxRenderTextureSize: 512,
      maxVertexAttribs: 16,
      maxVaryingVectors: 16,
      maxFragmentUniformVectors: 16,
      maxVertexUniformVectors: 16,
      standardDerivatives: false,
      astc: null,
      pvrtc: null,
      etc1: null,
      etc2: null,
      bptc: null,
      maxAnisotropy: 0,
      uintIndices: false,
      fragmentDepthSupported: false,
      highPrecisionShaderSupported: true,
      colorBufferFloat: false,
      supportFloatTexturesResolve: false,
      rg11b10ufColorRenderable: false,
      textureFloat: false,
      textureFloatLinearFiltering: false,
      textureFloatRender: false,
      textureHalfFloat: false,
      textureHalfFloatLinearFiltering: false,
      textureHalfFloatRender: false,
      textureLOD: false,
      texelFetch: false,
      drawBuffersExtension: false,
      depthTextureExtension: false,
      vertexArrayObject: false,
      instancedArrays: false,
      supportOcclusionQuery: false,
      canUseTimestampForTimerQuery: false,
      maxMSAASamples: 1,
      blendMinMax: false,
      canUseGLInstanceID: false,
      canUseGLVertexID: false,
      supportComputeShaders: false,
      supportSRGBBuffers: false,
      supportTransformFeedbacks: false,
      textureMaxLevel: false,
      texture2DArrayMaxLayerCount: 128,
      disableMorphTargetTexture: false,
      textureNorm16: false
    };
    this._features = {
      forceBitmapOverHTMLImageElement: false,
      supportRenderAndCopyToLodForFloatTextures: false,
      supportDepthStencilTexture: false,
      supportShadowSamplers: false,
      uniformBufferHardCheckMatrix: false,
      allowTexturePrefiltering: false,
      trackUbosInFrame: false,
      checkUbosContentBeforeUpload: false,
      supportCSM: false,
      basisNeedsPOT: false,
      support3DTextures: false,
      needTypeSuffixInShaderConstants: false,
      supportMSAA: false,
      supportSSAO2: false,
      supportIBLShadows: false,
      supportExtendedTextureFormats: false,
      supportSwitchCaseInShader: false,
      supportSyncTextureRead: false,
      needsInvertingBitmap: false,
      useUBOBindingCache: false,
      needShaderCodeInlining: false,
      needToAlwaysBindUniformBuffers: false,
      supportRenderPasses: true,
      supportSpriteInstancing: false,
      forceVertexBufferStrideAndOffsetMultiple4Bytes: false,
      _checkNonFloatVertexBuffersDontRecreatePipelineContext: false,
      _collectUbosUpdatedInFrame: false
    };
    if (options.renderingCanvas) {
      this._renderingCanvas = options.renderingCanvas;
    }
    Logger.Log(`Babylon.js v${Engine.Version} - Null engine`);
    const theCurrentGlobal = typeof self !== "undefined" ? self : typeof global !== "undefined" ? global : window;
    if (typeof URL === "undefined") {
      theCurrentGlobal.URL = {
        createObjectURL: function() {
        },
        revokeObjectURL: function() {
        }
      };
    }
    if (typeof Blob === "undefined") {
      theCurrentGlobal.Blob = function() {
      };
    }
  }
  /**
   * Creates a vertex buffer
   * @param vertices the data for the vertex buffer
   * @returns the new WebGL static buffer
   */
  createVertexBuffer(vertices) {
    const buffer = new DataBuffer();
    buffer.references = 1;
    return buffer;
  }
  /**
   * Creates a new index buffer
   * @param indices defines the content of the index buffer
   * @returns a new webGL buffer
   */
  createIndexBuffer(indices) {
    const buffer = new DataBuffer();
    buffer.references = 1;
    return buffer;
  }
  /**
   * Clear the current render buffer or the current render target (if any is set up)
   * @param color defines the color to use
   * @param backBuffer defines if the back buffer must be cleared
   * @param depth defines if the depth buffer must be cleared
   * @param stencil defines if the stencil buffer must be cleared
   */
  clear(color, backBuffer, depth, stencil = false) {
  }
  /**
   * Gets the current render width
   * @param useScreen defines if screen size must be used (or the current render target if any)
   * @returns a number defining the current render width
   */
  getRenderWidth(useScreen = false) {
    if (!useScreen && this._currentRenderTarget) {
      return this._currentRenderTarget.width;
    }
    return this._options.renderWidth;
  }
  /**
   * Gets the current render height
   * @param useScreen defines if screen size must be used (or the current render target if any)
   * @returns a number defining the current render height
   */
  getRenderHeight(useScreen = false) {
    if (!useScreen && this._currentRenderTarget) {
      return this._currentRenderTarget.height;
    }
    return this._options.renderHeight;
  }
  /**
   * Set the WebGL's viewport
   * @param viewport defines the viewport element to be used
   * @param requiredWidth defines the width required for rendering. If not provided the rendering canvas' width is used
   * @param requiredHeight defines the height required for rendering. If not provided the rendering canvas' height is used
   */
  setViewport(viewport, requiredWidth, requiredHeight) {
    this._cachedViewport = viewport;
  }
  createShaderProgram(pipelineContext, vertexCode, fragmentCode, defines, context) {
    return {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      __SPECTOR_rebuildProgram: null
    };
  }
  /**
   * Gets the list of webGL uniform locations associated with a specific program based on a list of uniform names
   * @param pipelineContext defines the pipeline context to use
   * @param uniformsNames defines the list of uniform names
   * @returns an array of webGL uniform locations
   */
  getUniforms(pipelineContext, uniformsNames) {
    return [];
  }
  /**
   * Gets the lsit of active attributes for a given webGL program
   * @param pipelineContext defines the pipeline context to use
   * @param attributesNames defines the list of attribute names to get
   * @returns an array of indices indicating the offset of each attribute
   */
  getAttributes(pipelineContext, attributesNames) {
    return [];
  }
  /**
   * Binds an effect to the webGL context
   * @param effect defines the effect to bind
   */
  bindSamplers(effect) {
    this._currentEffect = null;
  }
  /**
   * Activates an effect, making it the current one (ie. the one used for rendering)
   * @param effect defines the effect to activate
   */
  enableEffect(effect) {
    effect = effect !== null && IsWrapper(effect) ? effect.effect : effect;
    this._currentEffect = effect;
    if (!effect) {
      return;
    }
    if (effect.onBind) {
      effect.onBind(effect);
    }
    if (effect._onBindObservable) {
      effect._onBindObservable.notifyObservers(effect);
    }
  }
  setStateCullFaceType(cullBackFaces, force) {
  }
  /**
   * Set various states to the webGL context
   * @param culling defines culling state: true to enable culling, false to disable it
   * @param zOffset defines the value to apply to zOffset (0 by default)
   * @param force defines if states must be applied even if cache is up to date
   * @param reverseSide defines if culling must be reversed (CCW if false, CW if true)
   * @param cullBackFaces true to cull back faces, false to cull front faces (if culling is enabled)
   * @param stencil stencil states to set
   * @param zOffsetUnits defines the value to apply to zOffsetUnits (0 by default)
   */
  setState(culling, zOffset = 0, force, reverseSide = false, cullBackFaces, stencil, zOffsetUnits = 0) {
  }
  /**
   * Set the value of an uniform to an array of int32
   * @param uniform defines the webGL uniform location where to store the value
   * @param array defines the array of int32 to store
   * @returns true if value was set
   */
  setIntArray(uniform, array) {
    return true;
  }
  /**
   * Set the value of an uniform to an array of int32 (stored as vec2)
   * @param uniform defines the webGL uniform location where to store the value
   * @param array defines the array of int32 to store
   * @returns true if value was set
   */
  setIntArray2(uniform, array) {
    return true;
  }
  /**
   * Set the value of an uniform to an array of int32 (stored as vec3)
   * @param uniform defines the webGL uniform location where to store the value
   * @param array defines the array of int32 to store
   * @returns true if value was set
   */
  setIntArray3(uniform, array) {
    return true;
  }
  /**
   * Set the value of an uniform to an array of int32 (stored as vec4)
   * @param uniform defines the webGL uniform location where to store the value
   * @param array defines the array of int32 to store
   * @returns true if value was set
   */
  setIntArray4(uniform, array) {
    return true;
  }
  /**
   * Set the value of an uniform to an array of float32
   * @param uniform defines the webGL uniform location where to store the value
   * @param array defines the array of float32 to store
   * @returns true if value was set
   */
  setFloatArray(uniform, array) {
    return true;
  }
  /**
   * Set the value of an uniform to an array of float32 (stored as vec2)
   * @param uniform defines the webGL uniform location where to store the value
   * @param array defines the array of float32 to store
   * @returns true if value was set
   */
  setFloatArray2(uniform, array) {
    return true;
  }
  /**
   * Set the value of an uniform to an array of float32 (stored as vec3)
   * @param uniform defines the webGL uniform location where to store the value
   * @param array defines the array of float32 to store
   * @returns true if value was set
   */
  setFloatArray3(uniform, array) {
    return true;
  }
  /**
   * Set the value of an uniform to an array of float32 (stored as vec4)
   * @param uniform defines the webGL uniform location where to store the value
   * @param array defines the array of float32 to store
   * @returns true if value was set
   */
  setFloatArray4(uniform, array) {
    return true;
  }
  /**
   * Set the value of an uniform to an array of number
   * @param uniform defines the webGL uniform location where to store the value
   * @param array defines the array of number to store
   * @returns true if value was set
   */
  setArray(uniform, array) {
    return true;
  }
  /**
   * Set the value of an uniform to an array of number (stored as vec2)
   * @param uniform defines the webGL uniform location where to store the value
   * @param array defines the array of number to store
   * @returns true if value was set
   */
  setArray2(uniform, array) {
    return true;
  }
  /**
   * Set the value of an uniform to an array of number (stored as vec3)
   * @param uniform defines the webGL uniform location where to store the value
   * @param array defines the array of number to store
   * @returns true if value was set
   */
  setArray3(uniform, array) {
    return true;
  }
  /**
   * Set the value of an uniform to an array of number (stored as vec4)
   * @param uniform defines the webGL uniform location where to store the value
   * @param array defines the array of number to store
   * @returns true if value was set
   */
  setArray4(uniform, array) {
    return true;
  }
  /**
   * Set the value of an uniform to an array of float32 (stored as matrices)
   * @param uniform defines the webGL uniform location where to store the value
   * @param matrices defines the array of float32 to store
   * @returns true if value was set
   */
  setMatrices(uniform, matrices) {
    return true;
  }
  /**
   * Set the value of an uniform to a matrix (3x3)
   * @param uniform defines the webGL uniform location where to store the value
   * @param matrix defines the Float32Array representing the 3x3 matrix to store
   * @returns true if value was set
   */
  setMatrix3x3(uniform, matrix) {
    return true;
  }
  /**
   * Set the value of an uniform to a matrix (2x2)
   * @param uniform defines the webGL uniform location where to store the value
   * @param matrix defines the Float32Array representing the 2x2 matrix to store
   * @returns true if value was set
   */
  setMatrix2x2(uniform, matrix) {
    return true;
  }
  /**
   * Set the value of an uniform to a number (float)
   * @param uniform defines the webGL uniform location where to store the value
   * @param value defines the float number to store
   * @returns true if value was set
   */
  setFloat(uniform, value) {
    return true;
  }
  /**
   * Set the value of an uniform to a vec2
   * @param uniform defines the webGL uniform location where to store the value
   * @param x defines the 1st component of the value
   * @param y defines the 2nd component of the value
   * @returns true if value was set
   */
  setFloat2(uniform, x, y) {
    return true;
  }
  /**
   * Set the value of an uniform to a vec3
   * @param uniform defines the webGL uniform location where to store the value
   * @param x defines the 1st component of the value
   * @param y defines the 2nd component of the value
   * @param z defines the 3rd component of the value
   * @returns true if value was set
   */
  setFloat3(uniform, x, y, z) {
    return true;
  }
  /**
   * Set the value of an uniform to a boolean
   * @param uniform defines the webGL uniform location where to store the value
   * @param bool defines the boolean to store
   * @returns true if value was set
   */
  setBool(uniform, bool) {
    return true;
  }
  /**
   * Set the value of an uniform to a vec4
   * @param uniform defines the webGL uniform location where to store the value
   * @param x defines the 1st component of the value
   * @param y defines the 2nd component of the value
   * @param z defines the 3rd component of the value
   * @param w defines the 4th component of the value
   * @returns true if value was set
   */
  setFloat4(uniform, x, y, z, w) {
    return true;
  }
  /**
   * Sets the current alpha mode
   * @param mode defines the mode to use (one of the Engine.ALPHA_XXX)
   * @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)
   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering
   */
  setAlphaMode(mode, noDepthWriteChange = false) {
    if (this._alphaMode === mode) {
      return;
    }
    this.alphaState.alphaBlend = mode !== 0;
    if (!noDepthWriteChange) {
      this.setDepthWrite(mode === 0);
    }
    this._alphaMode = mode;
  }
  /**
   * Bind webGl buffers directly to the webGL context
   * @param vertexBuffers defines the vertex buffer to bind
   * @param indexBuffer defines the index buffer to bind
   * @param effect defines the effect associated with the vertex buffer
   */
  bindBuffers(vertexBuffers, indexBuffer, effect) {
  }
  /**
   * Force the entire cache to be cleared
   * You should not have to use this function unless your engine needs to share the webGL context with another engine
   * @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)
   */
  wipeCaches(bruteForce) {
    if (this.preventCacheWipeBetweenFrames) {
      return;
    }
    this.resetTextureCache();
    this._currentEffect = null;
    if (bruteForce) {
      this._currentProgram = null;
      this._stencilStateComposer.reset();
      this.depthCullingState.reset();
      this.alphaState.reset();
    }
    this._cachedVertexBuffers = null;
    this._cachedIndexBuffer = null;
    this._cachedEffectForVertexBuffers = null;
  }
  /**
   * Send a draw order
   * @param useTriangles defines if triangles must be used to draw (else wireframe will be used)
   * @param indexStart defines the starting index
   * @param indexCount defines the number of index to draw
   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)
   */
  draw(useTriangles, indexStart, indexCount, instancesCount) {
  }
  /**
   * Draw a list of indexed primitives
   * @param fillMode defines the primitive to use
   * @param indexStart defines the starting index
   * @param indexCount defines the number of index to draw
   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)
   */
  drawElementsType(fillMode, indexStart, indexCount, instancesCount) {
  }
  /**
   * Draw a list of unindexed primitives
   * @param fillMode defines the primitive to use
   * @param verticesStart defines the index of first vertex to draw
   * @param verticesCount defines the count of vertices to draw
   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)
   */
  drawArraysType(fillMode, verticesStart, verticesCount, instancesCount) {
  }
  /** @internal */
  _createTexture() {
    return {};
  }
  /**
   * @internal
   */
  _releaseTexture(texture) {
  }
  /**
   * Usually called from Texture.ts.
   * Passed information to create a WebGLTexture
   * @param urlArg defines a value which contains one of the following:
   * * A conventional http URL, e.g. 'http://...' or 'file://...'
   * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'
   * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'
   * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file
   * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)
   * @param scene needed for loading to the correct scene
   * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)
   * @param onLoad optional callback to be called upon successful completion
   * @param onError optional callback to be called upon failure
   * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob
   * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities
   * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures
   * @param forcedExtension defines the extension to use to pick the right loader
   * @param mimeType defines an optional mime type
   * @returns a InternalTexture for assignment back into BABYLON.Texture
   */
  createTexture(urlArg, noMipmap, invertY, scene, samplingMode = 3, onLoad = null, onError = null, buffer = null, fallback = null, format = null, forcedExtension = null, mimeType) {
    const texture = new InternalTexture(
      this,
      1
      /* InternalTextureSource.Url */
    );
    const url = String(urlArg);
    texture.url = url;
    texture.generateMipMaps = !noMipmap;
    texture.samplingMode = samplingMode;
    texture.invertY = invertY;
    texture.baseWidth = this._options.textureSize;
    texture.baseHeight = this._options.textureSize;
    texture.width = this._options.textureSize;
    texture.height = this._options.textureSize;
    if (format) {
      texture.format = format;
    }
    texture.isReady = true;
    if (onLoad) {
      setTimeout(() => {
        onLoad(texture);
      });
    }
    this._internalTexturesCache.push(texture);
    return texture;
  }
  /**
   * @internal
   */
  _createHardwareRenderTargetWrapper(isMulti, isCube, size) {
    const rtWrapper = new RenderTargetWrapper(isMulti, isCube, size, this);
    this._renderTargetWrapperCache.push(rtWrapper);
    return rtWrapper;
  }
  /**
   * Creates a new render target wrapper
   * @param size defines the size of the texture
   * @param options defines the options used to create the texture
   * @returns a new render target wrapper
   */
  createRenderTargetTexture(size, options) {
    const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size);
    const fullOptions = {};
    if (options !== void 0 && typeof options === "object") {
      fullOptions.generateMipMaps = options.generateMipMaps;
      fullOptions.generateDepthBuffer = options.generateDepthBuffer === void 0 ? true : options.generateDepthBuffer;
      fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && options.generateStencilBuffer;
      fullOptions.type = options.type === void 0 ? 0 : options.type;
      fullOptions.samplingMode = options.samplingMode === void 0 ? 3 : options.samplingMode;
    } else {
      fullOptions.generateMipMaps = options;
      fullOptions.generateDepthBuffer = true;
      fullOptions.generateStencilBuffer = false;
      fullOptions.type = 0;
      fullOptions.samplingMode = 3;
    }
    const texture = new InternalTexture(
      this,
      5
      /* InternalTextureSource.RenderTarget */
    );
    const width = size.width || size;
    const height = size.height || size;
    rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;
    rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;
    texture.baseWidth = width;
    texture.baseHeight = height;
    texture.width = width;
    texture.height = height;
    texture.isReady = true;
    texture.samples = 1;
    texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;
    texture.samplingMode = fullOptions.samplingMode;
    texture.type = fullOptions.type;
    this._internalTexturesCache.push(texture);
    return rtWrapper;
  }
  /**
   * Creates a new render target wrapper
   * @param size defines the size of the texture
   * @param options defines the options used to create the texture
   * @returns a new render target wrapper
   */
  createRenderTargetCubeTexture(size, options) {
    const rtWrapper = this._createHardwareRenderTargetWrapper(false, true, size);
    const fullOptions = {
      generateMipMaps: true,
      generateDepthBuffer: true,
      generateStencilBuffer: false,
      type: 0,
      samplingMode: 3,
      format: 5,
      ...options
    };
    fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && fullOptions.generateStencilBuffer;
    if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {
      fullOptions.samplingMode = 1;
    } else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {
      fullOptions.samplingMode = 1;
    }
    rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;
    rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;
    const texture = new InternalTexture(
      this,
      5
      /* InternalTextureSource.RenderTarget */
    );
    texture.baseWidth = size;
    texture.baseHeight = size;
    texture.width = size;
    texture.height = size;
    texture.isReady = true;
    texture.isCube = true;
    texture.samples = 1;
    texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;
    texture.samplingMode = fullOptions.samplingMode;
    texture.type = fullOptions.type;
    this._internalTexturesCache.push(texture);
    return rtWrapper;
  }
  /**
   * Update the sampling mode of a given texture
   * @param samplingMode defines the required sampling mode
   * @param texture defines the texture to update
   */
  updateTextureSamplingMode(samplingMode, texture) {
    texture.samplingMode = samplingMode;
  }
  /**
   * Creates a raw texture
   * @param data defines the data to store in the texture
   * @param width defines the width of the texture
   * @param height defines the height of the texture
   * @param format defines the format of the data
   * @param generateMipMaps defines if the engine should generate the mip levels
   * @param invertY defines if data must be stored with Y axis inverted
   * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)
   * @param compression defines the compression used (null by default)
   * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_BYTE by default)
   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).
   * @returns the raw texture inside an InternalTexture
   */
  createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, compression = null, type = 0, creationFlags = 0, useSRGBBuffer = false) {
    const texture = new InternalTexture(
      this,
      3
      /* InternalTextureSource.Raw */
    );
    texture.baseWidth = width;
    texture.baseHeight = height;
    texture.width = width;
    texture.height = height;
    texture.format = format;
    texture.generateMipMaps = generateMipMaps;
    texture.samplingMode = samplingMode;
    texture.invertY = invertY;
    texture._compression = compression;
    texture.type = type;
    texture._useSRGBBuffer = useSRGBBuffer;
    if (!this._doNotHandleContextLost) {
      texture._bufferView = data;
    }
    return texture;
  }
  /**
   * Update a raw texture
   * @param texture defines the texture to update
   * @param data defines the data to store in the texture
   * @param format defines the format of the data
   * @param invertY defines if data must be stored with Y axis inverted
   * @param compression defines the compression used (null by default)
   * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_BYTE by default)
   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).
   */
  updateRawTexture(texture, data, format, invertY, compression = null, type = 0, useSRGBBuffer = false) {
    if (texture) {
      texture._bufferView = data;
      texture.format = format;
      texture.invertY = invertY;
      texture._compression = compression;
      texture.type = type;
      texture._useSRGBBuffer = useSRGBBuffer;
    }
  }
  /**
   * Binds the frame buffer to the specified texture.
   * @param rtWrapper The render target wrapper to render to
   * @param faceIndex The face of the texture to render to in case of cube texture
   * @param requiredWidth The width of the target to render to
   * @param requiredHeight The height of the target to render to
   * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true
   */
  bindFramebuffer(rtWrapper, faceIndex, requiredWidth, requiredHeight, forceFullscreenViewport) {
    if (this._currentRenderTarget) {
      this.unBindFramebuffer(this._currentRenderTarget);
    }
    this._currentRenderTarget = rtWrapper;
    this._currentFramebuffer = null;
    if (this._cachedViewport && !forceFullscreenViewport) {
      this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);
    }
  }
  /**
   * Unbind the current render target texture from the webGL context
   * @param rtWrapper defines the render target wrapper to unbind
   * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated
   * @param onBeforeUnbind defines a function which will be called before the effective unbind
   */
  unBindFramebuffer(rtWrapper, disableGenerateMipMaps = false, onBeforeUnbind) {
    this._currentRenderTarget = null;
    if (onBeforeUnbind) {
      onBeforeUnbind();
    }
    this._currentFramebuffer = null;
  }
  /**
   * Creates a dynamic vertex buffer
   * @param vertices the data for the dynamic vertex buffer
   * @returns the new WebGL dynamic buffer
   */
  createDynamicVertexBuffer(vertices) {
    const buffer = new DataBuffer();
    buffer.references = 1;
    buffer.capacity = 1;
    return buffer;
  }
  /**
   * Update the content of a dynamic texture
   * @param texture defines the texture to update
   * @param canvas defines the canvas containing the source
   * @param invertY defines if data must be stored with Y axis inverted
   * @param premulAlpha defines if alpha is stored as premultiplied
   * @param format defines the format of the data
   */
  updateDynamicTexture(texture, canvas, invertY, premulAlpha = false, format) {
  }
  /**
   * Gets a boolean indicating if all created effects are ready
   * @returns true if all effects are ready
   */
  areAllEffectsReady() {
    return true;
  }
  /**
   * @internal
   * Get the current error code of the webGL context
   * @returns the error code
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getError
   */
  getError() {
    return 0;
  }
  /** @internal */
  _getUnpackAlignement() {
    return 1;
  }
  /**
   * @internal
   */
  _unpackFlipY(value) {
  }
  /**
   * Update a dynamic index buffer
   * @param indexBuffer defines the target index buffer
   * @param indices defines the data to update
   * @param offset defines the offset in the target index buffer where update should start
   */
  updateDynamicIndexBuffer(indexBuffer, indices, offset = 0) {
  }
  /**
   * Updates a dynamic vertex buffer.
   * @param vertexBuffer the vertex buffer to update
   * @param vertices the data used to update the vertex buffer
   * @param byteOffset the byte offset of the data (optional)
   * @param byteLength the byte length of the data (optional)
   */
  updateDynamicVertexBuffer(vertexBuffer, vertices, byteOffset, byteLength) {
  }
  /**
   * @internal
   */
  _bindTextureDirectly(target, texture) {
    if (this._boundTexturesCache[this._activeChannel] !== texture) {
      this._boundTexturesCache[this._activeChannel] = texture;
      return true;
    }
    return false;
  }
  /**
   * @internal
   */
  _bindTexture(channel, texture) {
    if (channel < 0) {
      return;
    }
    this._bindTextureDirectly(0, texture);
  }
  _deleteBuffer(buffer) {
  }
  /**
   * Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled
   */
  releaseEffects() {
  }
  displayLoadingUI() {
  }
  hideLoadingUI() {
  }
  set loadingUIText(_) {
  }
  flushFramebuffer() {
  }
  /**
   * @internal
   */
  _uploadCompressedDataToTextureDirectly(texture, internalFormat, width, height, data, faceIndex = 0, lod = 0) {
  }
  /**
   * @internal
   */
  _uploadDataToTextureDirectly(texture, imageData, faceIndex = 0, lod = 0) {
  }
  /**
   * @internal
   */
  _uploadArrayBufferViewToTexture(texture, imageData, faceIndex = 0, lod = 0) {
  }
  /**
   * @internal
   */
  _uploadImageToTexture(texture, image, faceIndex = 0, lod = 0) {
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuTextureHelper.js
var WebGPUTextureHelper = class {
  static ComputeNumMipmapLevels(width, height) {
    return ILog2(Math.max(width, height)) + 1;
  }
  static GetTextureTypeFromFormat(format) {
    switch (format) {
      // One Component = 8 bits unsigned
      case "r8unorm":
      case "r8uint":
      case "rg8unorm":
      case "rg8uint":
      case "rgba8unorm":
      case "rgba8unorm-srgb":
      case "rgba8uint":
      case "bgra8unorm":
      case "bgra8unorm-srgb":
      case "rgb10a2uint":
      // composite format - let's say it's byte...
      case "rgb10a2unorm":
      // composite format - let's say it's byte...
      case "rgb9e5ufloat":
      // composite format - let's say it's byte...
      case "rg11b10ufloat":
      // composite format - let's say it's byte...
      case "bc7-rgba-unorm":
      case "bc7-rgba-unorm-srgb":
      case "bc6h-rgb-ufloat":
      case "bc5-rg-unorm":
      case "bc3-rgba-unorm":
      case "bc3-rgba-unorm-srgb":
      case "bc2-rgba-unorm":
      case "bc2-rgba-unorm-srgb":
      case "bc4-r-unorm":
      case "bc1-rgba-unorm":
      case "bc1-rgba-unorm-srgb":
      case "etc2-rgb8unorm":
      case "etc2-rgb8unorm-srgb":
      case "etc2-rgb8a1unorm":
      case "etc2-rgb8a1unorm-srgb":
      case "etc2-rgba8unorm":
      case "etc2-rgba8unorm-srgb":
      case "eac-r11unorm":
      case "eac-rg11unorm":
      case "astc-4x4-unorm":
      case "astc-4x4-unorm-srgb":
      case "astc-5x4-unorm":
      case "astc-5x4-unorm-srgb":
      case "astc-5x5-unorm":
      case "astc-5x5-unorm-srgb":
      case "astc-6x5-unorm":
      case "astc-6x5-unorm-srgb":
      case "astc-6x6-unorm":
      case "astc-6x6-unorm-srgb":
      case "astc-8x5-unorm":
      case "astc-8x5-unorm-srgb":
      case "astc-8x6-unorm":
      case "astc-8x6-unorm-srgb":
      case "astc-8x8-unorm":
      case "astc-8x8-unorm-srgb":
      case "astc-10x5-unorm":
      case "astc-10x5-unorm-srgb":
      case "astc-10x6-unorm":
      case "astc-10x6-unorm-srgb":
      case "astc-10x8-unorm":
      case "astc-10x8-unorm-srgb":
      case "astc-10x10-unorm":
      case "astc-10x10-unorm-srgb":
      case "astc-12x10-unorm":
      case "astc-12x10-unorm-srgb":
      case "astc-12x12-unorm":
      case "astc-12x12-unorm-srgb":
      case "stencil8":
        return 0;
      // One Component = 8 bits signed
      case "r8snorm":
      case "r8sint":
      case "rg8snorm":
      case "rg8sint":
      case "rgba8snorm":
      case "rgba8sint":
      case "bc6h-rgb-float":
      case "bc5-rg-snorm":
      case "bc4-r-snorm":
      case "eac-r11snorm":
      case "eac-rg11snorm":
        return 3;
      // One component = 16 bits unsigned
      case "r16uint":
      case "r16unorm":
      case "rg16unorm":
      case "rgba16unorm":
      case "rg16uint":
      case "rgba16uint":
      case "depth16unorm":
        return 5;
      // One component = 16 bits signed
      case "r16sint":
      case "r16snorm":
      case "rg16snorm":
      case "rgba16snorm":
      case "rg16sint":
      case "rgba16sint":
        return 4;
      case "r16float":
      case "rg16float":
      case "rgba16float":
        return 2;
      // One component = 32 bits unsigned
      case "r32uint":
      case "rg32uint":
      case "rgba32uint":
        return 7;
      // One component = 32 bits signed
      case "r32sint":
      case "rg32sint":
      case "rgba32sint":
        return 7;
      case "r32float":
      case "rg32float":
      case "rgba32float":
      case "depth32float":
      case "depth32float-stencil8":
      case "depth24plus":
      case "depth24plus-stencil8":
        return 1;
    }
    return 0;
  }
  static GetBlockInformationFromFormat(format) {
    switch (format) {
      // 8 bits formats
      case "r8unorm":
      case "r8snorm":
      case "r8uint":
      case "r8sint":
        return { width: 1, height: 1, length: 1 };
      // 16 bits formats
      case "r16uint":
      case "r16sint":
      case "r16unorm":
      case "rg16unorm":
      case "rgba16unorm":
      case "r16snorm":
      case "rg16snorm":
      case "rgba16snorm":
      case "r16float":
      case "rg8unorm":
      case "rg8snorm":
      case "rg8uint":
      case "rg8sint":
        return { width: 1, height: 1, length: 2 };
      // 32 bits formats
      case "r32uint":
      case "r32sint":
      case "r32float":
      case "rg16uint":
      case "rg16sint":
      case "rg16float":
      case "rgba8unorm":
      case "rgba8unorm-srgb":
      case "rgba8snorm":
      case "rgba8uint":
      case "rgba8sint":
      case "bgra8unorm":
      case "bgra8unorm-srgb":
      case "rgb9e5ufloat":
      case "rgb10a2uint":
      case "rgb10a2unorm":
      case "rg11b10ufloat":
        return { width: 1, height: 1, length: 4 };
      // 64 bits formats
      case "rg32uint":
      case "rg32sint":
      case "rg32float":
      case "rgba16uint":
      case "rgba16sint":
      case "rgba16float":
        return { width: 1, height: 1, length: 8 };
      // 128 bits formats
      case "rgba32uint":
      case "rgba32sint":
      case "rgba32float":
        return { width: 1, height: 1, length: 16 };
      // Depth and stencil formats
      case "stencil8":
        throw "No fixed size for Stencil8 format!";
      case "depth16unorm":
        return { width: 1, height: 1, length: 2 };
      case "depth24plus":
        throw "No fixed size for Depth24Plus format!";
      case "depth24plus-stencil8":
        throw "No fixed size for Depth24PlusStencil8 format!";
      case "depth32float":
        return { width: 1, height: 1, length: 4 };
      case "depth32float-stencil8":
        return { width: 1, height: 1, length: 5 };
      // BC compressed formats usable if "texture-compression-bc" is both
      // supported by the device/user agent and enabled in requestDevice.
      case "bc7-rgba-unorm":
      case "bc7-rgba-unorm-srgb":
      case "bc6h-rgb-ufloat":
      case "bc6h-rgb-float":
      case "bc5-rg-unorm":
      case "bc5-rg-snorm":
      case "bc3-rgba-unorm":
      case "bc3-rgba-unorm-srgb":
      case "bc2-rgba-unorm":
      case "bc2-rgba-unorm-srgb":
        return { width: 4, height: 4, length: 16 };
      case "bc4-r-unorm":
      case "bc4-r-snorm":
      case "bc1-rgba-unorm":
      case "bc1-rgba-unorm-srgb":
        return { width: 4, height: 4, length: 8 };
      // ETC2 compressed formats usable if "texture-compression-etc2" is both
      // supported by the device/user agent and enabled in requestDevice.
      case "etc2-rgb8unorm":
      case "etc2-rgb8unorm-srgb":
      case "etc2-rgb8a1unorm":
      case "etc2-rgb8a1unorm-srgb":
      case "eac-r11unorm":
      case "eac-r11snorm":
        return { width: 4, height: 4, length: 8 };
      case "etc2-rgba8unorm":
      case "etc2-rgba8unorm-srgb":
      case "eac-rg11unorm":
      case "eac-rg11snorm":
        return { width: 4, height: 4, length: 16 };
      // ASTC compressed formats usable if "texture-compression-astc" is both
      // supported by the device/user agent and enabled in requestDevice.
      case "astc-4x4-unorm":
      case "astc-4x4-unorm-srgb":
        return { width: 4, height: 4, length: 16 };
      case "astc-5x4-unorm":
      case "astc-5x4-unorm-srgb":
        return { width: 5, height: 4, length: 16 };
      case "astc-5x5-unorm":
      case "astc-5x5-unorm-srgb":
        return { width: 5, height: 5, length: 16 };
      case "astc-6x5-unorm":
      case "astc-6x5-unorm-srgb":
        return { width: 6, height: 5, length: 16 };
      case "astc-6x6-unorm":
      case "astc-6x6-unorm-srgb":
        return { width: 6, height: 6, length: 16 };
      case "astc-8x5-unorm":
      case "astc-8x5-unorm-srgb":
        return { width: 8, height: 5, length: 16 };
      case "astc-8x6-unorm":
      case "astc-8x6-unorm-srgb":
        return { width: 8, height: 6, length: 16 };
      case "astc-8x8-unorm":
      case "astc-8x8-unorm-srgb":
        return { width: 8, height: 8, length: 16 };
      case "astc-10x5-unorm":
      case "astc-10x5-unorm-srgb":
        return { width: 10, height: 5, length: 16 };
      case "astc-10x6-unorm":
      case "astc-10x6-unorm-srgb":
        return { width: 10, height: 6, length: 16 };
      case "astc-10x8-unorm":
      case "astc-10x8-unorm-srgb":
        return { width: 10, height: 8, length: 16 };
      case "astc-10x10-unorm":
      case "astc-10x10-unorm-srgb":
        return { width: 10, height: 10, length: 16 };
      case "astc-12x10-unorm":
      case "astc-12x10-unorm-srgb":
        return { width: 12, height: 10, length: 16 };
      case "astc-12x12-unorm":
      case "astc-12x12-unorm-srgb":
        return { width: 12, height: 12, length: 16 };
    }
    return { width: 1, height: 1, length: 4 };
  }
  static IsHardwareTexture(texture) {
    return !!texture.release;
  }
  static IsInternalTexture(texture) {
    return !!texture.dispose;
  }
  static IsImageBitmap(imageBitmap) {
    return imageBitmap.close !== void 0;
  }
  static IsImageBitmapArray(imageBitmap) {
    return Array.isArray(imageBitmap) && imageBitmap[0].close !== void 0;
  }
  static IsCompressedFormat(format) {
    switch (format) {
      case "bc7-rgba-unorm-srgb":
      case "bc7-rgba-unorm":
      case "bc6h-rgb-float":
      case "bc6h-rgb-ufloat":
      case "bc5-rg-snorm":
      case "bc5-rg-unorm":
      case "bc4-r-snorm":
      case "bc4-r-unorm":
      case "bc3-rgba-unorm-srgb":
      case "bc3-rgba-unorm":
      case "bc2-rgba-unorm-srgb":
      case "bc2-rgba-unorm":
      case "bc1-rgba-unorm-srgb":
      case "bc1-rgba-unorm":
      case "etc2-rgb8unorm":
      case "etc2-rgb8unorm-srgb":
      case "etc2-rgb8a1unorm":
      case "etc2-rgb8a1unorm-srgb":
      case "etc2-rgba8unorm":
      case "etc2-rgba8unorm-srgb":
      case "eac-r11unorm":
      case "eac-r11snorm":
      case "eac-rg11unorm":
      case "eac-rg11snorm":
      case "astc-4x4-unorm":
      case "astc-4x4-unorm-srgb":
      case "astc-5x4-unorm":
      case "astc-5x4-unorm-srgb":
      case "astc-5x5-unorm":
      case "astc-5x5-unorm-srgb":
      case "astc-6x5-unorm":
      case "astc-6x5-unorm-srgb":
      case "astc-6x6-unorm":
      case "astc-6x6-unorm-srgb":
      case "astc-8x5-unorm":
      case "astc-8x5-unorm-srgb":
      case "astc-8x6-unorm":
      case "astc-8x6-unorm-srgb":
      case "astc-8x8-unorm":
      case "astc-8x8-unorm-srgb":
      case "astc-10x5-unorm":
      case "astc-10x5-unorm-srgb":
      case "astc-10x6-unorm":
      case "astc-10x6-unorm-srgb":
      case "astc-10x8-unorm":
      case "astc-10x8-unorm-srgb":
      case "astc-10x10-unorm":
      case "astc-10x10-unorm-srgb":
      case "astc-12x10-unorm":
      case "astc-12x10-unorm-srgb":
      case "astc-12x12-unorm":
      case "astc-12x12-unorm-srgb":
        return true;
    }
    return false;
  }
  static GetWebGPUTextureFormat(type, format, useSRGBBuffer = false) {
    switch (format) {
      case 15:
        return "depth16unorm";
      case 16:
        return "depth24plus";
      case 13:
        return "depth24plus-stencil8";
      case 14:
        return "depth32float";
      case 18:
        return "depth32float-stencil8";
      case 19:
        return "stencil8";
      case 36492:
        return useSRGBBuffer ? "bc7-rgba-unorm-srgb" : "bc7-rgba-unorm";
      case 36495:
        return "bc6h-rgb-ufloat";
      case 36494:
        return "bc6h-rgb-float";
      case 33779:
        return useSRGBBuffer ? "bc3-rgba-unorm-srgb" : "bc3-rgba-unorm";
      case 33778:
        return useSRGBBuffer ? "bc2-rgba-unorm-srgb" : "bc2-rgba-unorm";
      case 33777:
      case 33776:
        return useSRGBBuffer ? "bc1-rgba-unorm-srgb" : "bc1-rgba-unorm";
      case 37808:
        return useSRGBBuffer ? "astc-4x4-unorm-srgb" : "astc-4x4-unorm";
      case 36196:
      case 37492:
        return useSRGBBuffer ? "etc2-rgb8unorm-srgb" : "etc2-rgb8unorm";
      case 37496:
        return useSRGBBuffer ? "etc2-rgba8unorm-srgb" : "etc2-rgba8unorm";
    }
    switch (type) {
      case 3:
        switch (format) {
          case 6:
            return "r8snorm";
          case 7:
            return "rg8snorm";
          case 4:
            throw "RGB format not supported in WebGPU";
          case 8:
            return "r8sint";
          case 9:
            return "rg8sint";
          case 10:
            throw "RGB_INTEGER format not supported in WebGPU";
          case 11:
            return "rgba8sint";
          default:
            return "rgba8snorm";
        }
      case 0:
        switch (format) {
          case 6:
            return "r8unorm";
          case 7:
            return "rg8unorm";
          case 4:
            throw "TEXTUREFORMAT_RGB format not supported in WebGPU";
          case 5:
            return useSRGBBuffer ? "rgba8unorm-srgb" : "rgba8unorm";
          case 12:
            return useSRGBBuffer ? "bgra8unorm-srgb" : "bgra8unorm";
          case 8:
            return "r8uint";
          case 9:
            return "rg8uint";
          case 10:
            throw "RGB_INTEGER format not supported in WebGPU";
          case 11:
            return "rgba8uint";
          case 0:
            throw "TEXTUREFORMAT_ALPHA format not supported in WebGPU";
          case 1:
            throw "TEXTUREFORMAT_LUMINANCE format not supported in WebGPU";
          case 2:
            throw "TEXTUREFORMAT_LUMINANCE_ALPHA format not supported in WebGPU";
          default:
            return "rgba8unorm";
        }
      case 4:
        switch (format) {
          case 8:
            return "r16sint";
          case 9:
            return "rg16sint";
          case 10:
            throw "TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU";
          case 11:
            return "rgba16sint";
          default:
            return "rgba16sint";
        }
      case 5:
        switch (format) {
          case 8:
            return "r16uint";
          case 9:
            return "rg16uint";
          case 10:
            throw "TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU";
          case 11:
            return "rgba16uint";
          default:
            return "rgba16uint";
        }
      case 6:
        switch (format) {
          case 8:
            return "r32sint";
          case 9:
            return "rg32sint";
          case 10:
            throw "TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU";
          case 11:
            return "rgba32sint";
          default:
            return "rgba32sint";
        }
      case 7:
        switch (format) {
          case 8:
            return "r32uint";
          case 9:
            return "rg32uint";
          case 10:
            throw "TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU";
          case 11:
            return "rgba32uint";
          default:
            return "rgba32uint";
        }
      case 1:
        switch (format) {
          case 6:
            return "r32float";
          // By default. Other possibility is R16Float.
          case 7:
            return "rg32float";
          // By default. Other possibility is RG16Float.
          case 4:
            throw "TEXTUREFORMAT_RGB format not supported in WebGPU";
          case 5:
            return "rgba32float";
          // By default. Other possibility is RGBA16Float.
          default:
            return "rgba32float";
        }
      case 2:
        switch (format) {
          case 6:
            return "r16float";
          case 7:
            return "rg16float";
          case 4:
            throw "TEXTUREFORMAT_RGB format not supported in WebGPU";
          case 5:
            return "rgba16float";
          default:
            return "rgba16float";
        }
      case 10:
        throw "TEXTURETYPE_UNSIGNED_SHORT_5_6_5 format not supported in WebGPU";
      case 13:
        switch (format) {
          case 5:
            return "rg11b10ufloat";
          case 11:
            throw "TEXTUREFORMAT_RGBA_INTEGER format not supported in WebGPU when type is TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV";
          default:
            return "rg11b10ufloat";
        }
      case 14:
        switch (format) {
          case 5:
            return "rgb9e5ufloat";
          case 11:
            throw "TEXTUREFORMAT_RGBA_INTEGER format not supported in WebGPU when type is TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV";
          default:
            return "rgb9e5ufloat";
        }
      case 8:
        throw "TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 format not supported in WebGPU";
      case 9:
        throw "TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 format not supported in WebGPU";
      case 11:
        switch (format) {
          case 5:
            return "rgb10a2unorm";
          case 11:
            return "rgb10a2uint";
          default:
            return "rgb10a2unorm";
        }
    }
    return useSRGBBuffer ? "rgba8unorm-srgb" : "rgba8unorm";
  }
  static GetNumChannelsFromWebGPUTextureFormat(format) {
    switch (format) {
      case "r8unorm":
      case "r8snorm":
      case "r8uint":
      case "r8sint":
      case "bc4-r-unorm":
      case "bc4-r-snorm":
      case "r16uint":
      case "r16sint":
      case "depth16unorm":
      case "r16float":
      case "r16unorm":
      case "r16snorm":
      case "r32uint":
      case "r32sint":
      case "r32float":
      case "depth32float":
      case "stencil8":
      case "depth24plus":
      case "eac-r11unorm":
      case "eac-r11snorm":
        return 1;
      case "rg8unorm":
      case "rg8snorm":
      case "rg8uint":
      case "rg8sint":
      case "depth32float-stencil8":
      case "bc5-rg-unorm":
      case "bc5-rg-snorm":
      case "rg16uint":
      case "rg16sint":
      case "rg16float":
      case "rg16unorm":
      case "rg16snorm":
      case "rg32uint":
      case "rg32sint":
      case "rg32float":
      case "depth24plus-stencil8":
      case "eac-rg11unorm":
      case "eac-rg11snorm":
        return 2;
      case "rgb9e5ufloat":
      case "rg11b10ufloat":
      case "bc6h-rgb-ufloat":
      case "bc6h-rgb-float":
      case "etc2-rgb8unorm":
      case "etc2-rgb8unorm-srgb":
        return 3;
      case "rgba8unorm":
      case "rgba8unorm-srgb":
      case "rgba8snorm":
      case "rgba8uint":
      case "rgba8sint":
      case "bgra8unorm":
      case "bgra8unorm-srgb":
      case "rgba16unorm":
      case "rgba16snorm":
      case "rgb10a2uint":
      case "rgb10a2unorm":
      case "bc7-rgba-unorm":
      case "bc7-rgba-unorm-srgb":
      case "bc3-rgba-unorm":
      case "bc3-rgba-unorm-srgb":
      case "bc2-rgba-unorm":
      case "bc2-rgba-unorm-srgb":
      case "bc1-rgba-unorm":
      case "bc1-rgba-unorm-srgb":
      case "rgba16uint":
      case "rgba16sint":
      case "rgba16float":
      case "rgba32uint":
      case "rgba32sint":
      case "rgba32float":
      case "etc2-rgb8a1unorm":
      case "etc2-rgb8a1unorm-srgb":
      case "etc2-rgba8unorm":
      case "etc2-rgba8unorm-srgb":
      case "astc-4x4-unorm":
      case "astc-4x4-unorm-srgb":
      case "astc-5x4-unorm":
      case "astc-5x4-unorm-srgb":
      case "astc-5x5-unorm":
      case "astc-5x5-unorm-srgb":
      case "astc-6x5-unorm":
      case "astc-6x5-unorm-srgb":
      case "astc-6x6-unorm":
      case "astc-6x6-unorm-srgb":
      case "astc-8x5-unorm":
      case "astc-8x5-unorm-srgb":
      case "astc-8x6-unorm":
      case "astc-8x6-unorm-srgb":
      case "astc-8x8-unorm":
      case "astc-8x8-unorm-srgb":
      case "astc-10x5-unorm":
      case "astc-10x5-unorm-srgb":
      case "astc-10x6-unorm":
      case "astc-10x6-unorm-srgb":
      case "astc-10x8-unorm":
      case "astc-10x8-unorm-srgb":
      case "astc-10x10-unorm":
      case "astc-10x10-unorm-srgb":
      case "astc-12x10-unorm":
      case "astc-12x10-unorm-srgb":
      case "astc-12x12-unorm":
      case "astc-12x12-unorm-srgb":
        return 4;
    }
    throw `Unknown format ${format}!`;
  }
  static HasStencilAspect(format) {
    switch (format) {
      case "stencil8":
      case "depth32float-stencil8":
      case "depth24plus-stencil8":
        return true;
    }
    return false;
  }
  static HasDepthAndStencilAspects(format) {
    switch (format) {
      case "depth32float-stencil8":
      case "depth24plus-stencil8":
        return true;
    }
    return false;
  }
  static GetDepthFormatOnly(format) {
    switch (format) {
      case "depth16unorm":
        return "depth16unorm";
      case "depth24plus":
        return "depth24plus";
      case "depth24plus-stencil8":
        return "depth24plus";
      case "depth32float":
        return "depth32float";
      case "depth32float-stencil8":
        return "depth32float";
    }
    return format;
  }
  static GetSample(sampleCount) {
    return sampleCount > 1 ? 4 : 1;
  }
};

// node_modules/@babylonjs/core/Engines/thinWebGPUEngine.js
var ThinWebGPUEngine = class extends AbstractEngine {
  constructor() {
    super(...arguments);
    this.dbgShowShaderCode = false;
    this.dbgSanityChecks = true;
    this.dbgVerboseLogsNumFrames = 10;
    this.dbgLogIfNotDrawWrapper = true;
    this.dbgShowEmptyEnableEffectCalls = true;
    this.dbgVerboseLogsForFirstFrames = false;
    this._currentRenderPass = null;
    this._snapshotRenderingMode = 0;
    this._timestampIndex = 0;
    this._debugStackRenderPass = [];
  }
  /**
   * Enables or disables GPU timing measurements.
   * Note that this is only supported if the "timestamp-query" extension is enabled in the options.
   */
  get enableGPUTimingMeasurements() {
    return this._timestampQuery.enable;
  }
  set enableGPUTimingMeasurements(enable) {
    if (this._timestampQuery.enable === enable) {
      return;
    }
    this.gpuTimeInFrameForMainPass = enable ? new WebGPUPerfCounter() : void 0;
    this._timestampQuery.enable = enable;
  }
  _currentPassIsMainPass() {
    return this._currentRenderTarget === null;
  }
  /** @internal */
  _endCurrentRenderPass() {
    if (!this._currentRenderPass) {
      return 0;
    }
    if (this._debugStackRenderPass.length !== 0) {
      for (let i = 0; i < this._debugStackRenderPass.length; ++i) {
        this._currentRenderPass.popDebugGroup();
      }
    }
    const currentPassIndex = this._currentPassIsMainPass() ? 2 : 1;
    if (!this._snapshotRendering.endRenderPass(this._currentRenderPass) && !this.compatibilityMode) {
      this._bundleList.run(this._currentRenderPass);
      this._bundleList.reset();
    }
    this._currentRenderPass.end();
    this._timestampQuery.endPass(this._timestampIndex, this._currentRenderTarget && this._currentRenderTarget.gpuTimeInFrame ? this._currentRenderTarget.gpuTimeInFrame : this.gpuTimeInFrameForMainPass);
    this._timestampIndex += 2;
    if (this.dbgVerboseLogsForFirstFrames) {
      if (this._count === void 0) {
        this._count = 0;
      }
      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {
        Logger.Log("frame #" + this._count + " - " + (currentPassIndex === 2 ? "main" : "render target") + " end pass" + (currentPassIndex === 1 ? " - internalTexture.uniqueId=" + this._currentRenderTarget?.texture?.uniqueId : ""));
      }
    }
    this._debugPopGroup?.(0);
    this._currentRenderPass = null;
    return currentPassIndex;
  }
  /**
   * @internal
   */
  _generateMipmaps(texture, commandEncoder) {
    commandEncoder = commandEncoder ?? this._renderEncoder;
    const gpuHardwareTexture = texture._hardwareTexture;
    if (!gpuHardwareTexture) {
      return;
    }
    if (commandEncoder === this._renderEncoder) {
      this._endCurrentRenderPass();
    }
    const format = texture._hardwareTexture.format;
    const mipmapCount = WebGPUTextureHelper.ComputeNumMipmapLevels(texture.width, texture.height);
    if (this.dbgVerboseLogsForFirstFrames) {
      if (this._count === void 0) {
        this._count = 0;
      }
      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {
        Logger.Log("frame #" + this._count + " - generate mipmaps - width=" + texture.width + ", height=" + texture.height + ", isCube=" + texture.isCube + ", command encoder=" + (commandEncoder === this._renderEncoder ? "render" : "copy"));
      }
    }
    if (texture.isCube) {
      this._textureHelper.generateCubeMipmaps(gpuHardwareTexture, format, mipmapCount, commandEncoder);
    } else {
      this._textureHelper.generateMipmaps(gpuHardwareTexture, format, mipmapCount, 0, texture.is3D, commandEncoder);
    }
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuConstants.js
var PowerPreference;
(function(PowerPreference2) {
  PowerPreference2["LowPower"] = "low-power";
  PowerPreference2["HighPerformance"] = "high-performance";
})(PowerPreference || (PowerPreference = {}));
var FeatureName;
(function(FeatureName2) {
  FeatureName2["DepthClipControl"] = "depth-clip-control";
  FeatureName2["Depth32FloatStencil8"] = "depth32float-stencil8";
  FeatureName2["TextureCompressionBC"] = "texture-compression-bc";
  FeatureName2["TextureCompressionBCSliced3D"] = "texture-compression-bc-sliced-3d";
  FeatureName2["TextureCompressionETC2"] = "texture-compression-etc2";
  FeatureName2["TextureCompressionASTC"] = "texture-compression-astc";
  FeatureName2["TextureCompressionASTCSliced3D"] = "texture-compression-astc-sliced-3d";
  FeatureName2["TimestampQuery"] = "timestamp-query";
  FeatureName2["IndirectFirstInstance"] = "indirect-first-instance";
  FeatureName2["ShaderF16"] = "shader-f16";
  FeatureName2["RG11B10UFloatRenderable"] = "rg11b10ufloat-renderable";
  FeatureName2["BGRA8UnormStorage"] = "bgra8unorm-storage";
  FeatureName2["Float32Filterable"] = "float32-filterable";
  FeatureName2["Float32Blendable"] = "float32-blendable";
  FeatureName2["ClipDistances"] = "clip-distances";
  FeatureName2["DualSourceBlending"] = "dual-source-blending";
})(FeatureName || (FeatureName = {}));
var BufferMapState;
(function(BufferMapState2) {
  BufferMapState2["Unmapped"] = "unmapped";
  BufferMapState2["Pending"] = "pending";
  BufferMapState2["Mapped"] = "mapped";
})(BufferMapState || (BufferMapState = {}));
var BufferUsage;
(function(BufferUsage2) {
  BufferUsage2[BufferUsage2["MapRead"] = 1] = "MapRead";
  BufferUsage2[BufferUsage2["MapWrite"] = 2] = "MapWrite";
  BufferUsage2[BufferUsage2["CopySrc"] = 4] = "CopySrc";
  BufferUsage2[BufferUsage2["CopyDst"] = 8] = "CopyDst";
  BufferUsage2[BufferUsage2["Index"] = 16] = "Index";
  BufferUsage2[BufferUsage2["Vertex"] = 32] = "Vertex";
  BufferUsage2[BufferUsage2["Uniform"] = 64] = "Uniform";
  BufferUsage2[BufferUsage2["Storage"] = 128] = "Storage";
  BufferUsage2[BufferUsage2["Indirect"] = 256] = "Indirect";
  BufferUsage2[BufferUsage2["QueryResolve"] = 512] = "QueryResolve";
})(BufferUsage || (BufferUsage = {}));
var MapMode;
(function(MapMode2) {
  MapMode2[MapMode2["Read"] = 1] = "Read";
  MapMode2[MapMode2["Write"] = 2] = "Write";
})(MapMode || (MapMode = {}));
var TextureDimension;
(function(TextureDimension2) {
  TextureDimension2["E1d"] = "1d";
  TextureDimension2["E2d"] = "2d";
  TextureDimension2["E3d"] = "3d";
})(TextureDimension || (TextureDimension = {}));
var TextureUsage;
(function(TextureUsage2) {
  TextureUsage2[TextureUsage2["CopySrc"] = 1] = "CopySrc";
  TextureUsage2[TextureUsage2["CopyDst"] = 2] = "CopyDst";
  TextureUsage2[TextureUsage2["TextureBinding"] = 4] = "TextureBinding";
  TextureUsage2[TextureUsage2["StorageBinding"] = 8] = "StorageBinding";
  TextureUsage2[TextureUsage2["RenderAttachment"] = 16] = "RenderAttachment";
})(TextureUsage || (TextureUsage = {}));
var TextureViewDimension;
(function(TextureViewDimension2) {
  TextureViewDimension2["E1d"] = "1d";
  TextureViewDimension2["E2d"] = "2d";
  TextureViewDimension2["E2dArray"] = "2d-array";
  TextureViewDimension2["Cube"] = "cube";
  TextureViewDimension2["CubeArray"] = "cube-array";
  TextureViewDimension2["E3d"] = "3d";
})(TextureViewDimension || (TextureViewDimension = {}));
var TextureAspect;
(function(TextureAspect2) {
  TextureAspect2["All"] = "all";
  TextureAspect2["StencilOnly"] = "stencil-only";
  TextureAspect2["DepthOnly"] = "depth-only";
})(TextureAspect || (TextureAspect = {}));
var TextureFormat;
(function(TextureFormat2) {
  TextureFormat2["R8Unorm"] = "r8unorm";
  TextureFormat2["R8Snorm"] = "r8snorm";
  TextureFormat2["R8Uint"] = "r8uint";
  TextureFormat2["R8Sint"] = "r8sint";
  TextureFormat2["R16Uint"] = "r16uint";
  TextureFormat2["R16Sint"] = "r16sint";
  TextureFormat2["R16Float"] = "r16float";
  TextureFormat2["RG8Unorm"] = "rg8unorm";
  TextureFormat2["RG8Snorm"] = "rg8snorm";
  TextureFormat2["RG8Uint"] = "rg8uint";
  TextureFormat2["RG8Sint"] = "rg8sint";
  TextureFormat2["R16Unorm"] = "r16unorm";
  TextureFormat2["R16Snorm"] = "r16snorm";
  TextureFormat2["RG16Unorm"] = "rg16unorm";
  TextureFormat2["RG16Snorm"] = "rg16snorm";
  TextureFormat2["RGBA16Unorm"] = "rgba16unorm";
  TextureFormat2["RGBA16Snorm"] = "rgba16snorm";
  TextureFormat2["R32Uint"] = "r32uint";
  TextureFormat2["R32Sint"] = "r32sint";
  TextureFormat2["R32Float"] = "r32float";
  TextureFormat2["RG16Uint"] = "rg16uint";
  TextureFormat2["RG16Sint"] = "rg16sint";
  TextureFormat2["RG16Float"] = "rg16float";
  TextureFormat2["RGBA8Unorm"] = "rgba8unorm";
  TextureFormat2["RGBA8UnormSRGB"] = "rgba8unorm-srgb";
  TextureFormat2["RGBA8Snorm"] = "rgba8snorm";
  TextureFormat2["RGBA8Uint"] = "rgba8uint";
  TextureFormat2["RGBA8Sint"] = "rgba8sint";
  TextureFormat2["BGRA8Unorm"] = "bgra8unorm";
  TextureFormat2["BGRA8UnormSRGB"] = "bgra8unorm-srgb";
  TextureFormat2["RGB9E5UFloat"] = "rgb9e5ufloat";
  TextureFormat2["RGB10A2UINT"] = "rgb10a2uint";
  TextureFormat2["RGB10A2Unorm"] = "rgb10a2unorm";
  TextureFormat2["RG11B10UFloat"] = "rg11b10ufloat";
  TextureFormat2["RG32Uint"] = "rg32uint";
  TextureFormat2["RG32Sint"] = "rg32sint";
  TextureFormat2["RG32Float"] = "rg32float";
  TextureFormat2["RGBA16Uint"] = "rgba16uint";
  TextureFormat2["RGBA16Sint"] = "rgba16sint";
  TextureFormat2["RGBA16Float"] = "rgba16float";
  TextureFormat2["RGBA32Uint"] = "rgba32uint";
  TextureFormat2["RGBA32Sint"] = "rgba32sint";
  TextureFormat2["RGBA32Float"] = "rgba32float";
  TextureFormat2["Stencil8"] = "stencil8";
  TextureFormat2["Depth16Unorm"] = "depth16unorm";
  TextureFormat2["Depth24Plus"] = "depth24plus";
  TextureFormat2["Depth24PlusStencil8"] = "depth24plus-stencil8";
  TextureFormat2["Depth32Float"] = "depth32float";
  TextureFormat2["BC1RGBAUnorm"] = "bc1-rgba-unorm";
  TextureFormat2["BC1RGBAUnormSRGB"] = "bc1-rgba-unorm-srgb";
  TextureFormat2["BC2RGBAUnorm"] = "bc2-rgba-unorm";
  TextureFormat2["BC2RGBAUnormSRGB"] = "bc2-rgba-unorm-srgb";
  TextureFormat2["BC3RGBAUnorm"] = "bc3-rgba-unorm";
  TextureFormat2["BC3RGBAUnormSRGB"] = "bc3-rgba-unorm-srgb";
  TextureFormat2["BC4RUnorm"] = "bc4-r-unorm";
  TextureFormat2["BC4RSnorm"] = "bc4-r-snorm";
  TextureFormat2["BC5RGUnorm"] = "bc5-rg-unorm";
  TextureFormat2["BC5RGSnorm"] = "bc5-rg-snorm";
  TextureFormat2["BC6HRGBUFloat"] = "bc6h-rgb-ufloat";
  TextureFormat2["BC6HRGBFloat"] = "bc6h-rgb-float";
  TextureFormat2["BC7RGBAUnorm"] = "bc7-rgba-unorm";
  TextureFormat2["BC7RGBAUnormSRGB"] = "bc7-rgba-unorm-srgb";
  TextureFormat2["ETC2RGB8Unorm"] = "etc2-rgb8unorm";
  TextureFormat2["ETC2RGB8UnormSRGB"] = "etc2-rgb8unorm-srgb";
  TextureFormat2["ETC2RGB8A1Unorm"] = "etc2-rgb8a1unorm";
  TextureFormat2["ETC2RGB8A1UnormSRGB"] = "etc2-rgb8a1unorm-srgb";
  TextureFormat2["ETC2RGBA8Unorm"] = "etc2-rgba8unorm";
  TextureFormat2["ETC2RGBA8UnormSRGB"] = "etc2-rgba8unorm-srgb";
  TextureFormat2["EACR11Unorm"] = "eac-r11unorm";
  TextureFormat2["EACR11Snorm"] = "eac-r11snorm";
  TextureFormat2["EACRG11Unorm"] = "eac-rg11unorm";
  TextureFormat2["EACRG11Snorm"] = "eac-rg11snorm";
  TextureFormat2["ASTC4x4Unorm"] = "astc-4x4-unorm";
  TextureFormat2["ASTC4x4UnormSRGB"] = "astc-4x4-unorm-srgb";
  TextureFormat2["ASTC5x4Unorm"] = "astc-5x4-unorm";
  TextureFormat2["ASTC5x4UnormSRGB"] = "astc-5x4-unorm-srgb";
  TextureFormat2["ASTC5x5Unorm"] = "astc-5x5-unorm";
  TextureFormat2["ASTC5x5UnormSRGB"] = "astc-5x5-unorm-srgb";
  TextureFormat2["ASTC6x5Unorm"] = "astc-6x5-unorm";
  TextureFormat2["ASTC6x5UnormSRGB"] = "astc-6x5-unorm-srgb";
  TextureFormat2["ASTC6x6Unorm"] = "astc-6x6-unorm";
  TextureFormat2["ASTC6x6UnormSRGB"] = "astc-6x6-unorm-srgb";
  TextureFormat2["ASTC8x5Unorm"] = "astc-8x5-unorm";
  TextureFormat2["ASTC8x5UnormSRGB"] = "astc-8x5-unorm-srgb";
  TextureFormat2["ASTC8x6Unorm"] = "astc-8x6-unorm";
  TextureFormat2["ASTC8x6UnormSRGB"] = "astc-8x6-unorm-srgb";
  TextureFormat2["ASTC8x8Unorm"] = "astc-8x8-unorm";
  TextureFormat2["ASTC8x8UnormSRGB"] = "astc-8x8-unorm-srgb";
  TextureFormat2["ASTC10x5Unorm"] = "astc-10x5-unorm";
  TextureFormat2["ASTC10x5UnormSRGB"] = "astc-10x5-unorm-srgb";
  TextureFormat2["ASTC10x6Unorm"] = "astc-10x6-unorm";
  TextureFormat2["ASTC10x6UnormSRGB"] = "astc-10x6-unorm-srgb";
  TextureFormat2["ASTC10x8Unorm"] = "astc-10x8-unorm";
  TextureFormat2["ASTC10x8UnormSRGB"] = "astc-10x8-unorm-srgb";
  TextureFormat2["ASTC10x10Unorm"] = "astc-10x10-unorm";
  TextureFormat2["ASTC10x10UnormSRGB"] = "astc-10x10-unorm-srgb";
  TextureFormat2["ASTC12x10Unorm"] = "astc-12x10-unorm";
  TextureFormat2["ASTC12x10UnormSRGB"] = "astc-12x10-unorm-srgb";
  TextureFormat2["ASTC12x12Unorm"] = "astc-12x12-unorm";
  TextureFormat2["ASTC12x12UnormSRGB"] = "astc-12x12-unorm-srgb";
  TextureFormat2["Depth32FloatStencil8"] = "depth32float-stencil8";
})(TextureFormat || (TextureFormat = {}));
var AddressMode;
(function(AddressMode2) {
  AddressMode2["ClampToEdge"] = "clamp-to-edge";
  AddressMode2["Repeat"] = "repeat";
  AddressMode2["MirrorRepeat"] = "mirror-repeat";
})(AddressMode || (AddressMode = {}));
var FilterMode;
(function(FilterMode2) {
  FilterMode2["Nearest"] = "nearest";
  FilterMode2["Linear"] = "linear";
})(FilterMode || (FilterMode = {}));
var MipmapFilterMode;
(function(MipmapFilterMode2) {
  MipmapFilterMode2["Nearest"] = "nearest";
  MipmapFilterMode2["Linear"] = "linear";
})(MipmapFilterMode || (MipmapFilterMode = {}));
var CompareFunction;
(function(CompareFunction2) {
  CompareFunction2["Never"] = "never";
  CompareFunction2["Less"] = "less";
  CompareFunction2["Equal"] = "equal";
  CompareFunction2["LessEqual"] = "less-equal";
  CompareFunction2["Greater"] = "greater";
  CompareFunction2["NotEqual"] = "not-equal";
  CompareFunction2["GreaterEqual"] = "greater-equal";
  CompareFunction2["Always"] = "always";
})(CompareFunction || (CompareFunction = {}));
var ShaderStage;
(function(ShaderStage2) {
  ShaderStage2[ShaderStage2["Vertex"] = 1] = "Vertex";
  ShaderStage2[ShaderStage2["Fragment"] = 2] = "Fragment";
  ShaderStage2[ShaderStage2["Compute"] = 4] = "Compute";
})(ShaderStage || (ShaderStage = {}));
var BufferBindingType;
(function(BufferBindingType2) {
  BufferBindingType2["Uniform"] = "uniform";
  BufferBindingType2["Storage"] = "storage";
  BufferBindingType2["ReadOnlyStorage"] = "read-only-storage";
})(BufferBindingType || (BufferBindingType = {}));
var SamplerBindingType;
(function(SamplerBindingType2) {
  SamplerBindingType2["Filtering"] = "filtering";
  SamplerBindingType2["NonFiltering"] = "non-filtering";
  SamplerBindingType2["Comparison"] = "comparison";
})(SamplerBindingType || (SamplerBindingType = {}));
var TextureSampleType;
(function(TextureSampleType2) {
  TextureSampleType2["Float"] = "float";
  TextureSampleType2["UnfilterableFloat"] = "unfilterable-float";
  TextureSampleType2["Depth"] = "depth";
  TextureSampleType2["Sint"] = "sint";
  TextureSampleType2["Uint"] = "uint";
})(TextureSampleType || (TextureSampleType = {}));
var StorageTextureAccess;
(function(StorageTextureAccess2) {
  StorageTextureAccess2["WriteOnly"] = "write-only";
  StorageTextureAccess2["ReadOnly"] = "read-only";
  StorageTextureAccess2["ReadWrite"] = "read-write";
})(StorageTextureAccess || (StorageTextureAccess = {}));
var CompilationMessageType;
(function(CompilationMessageType2) {
  CompilationMessageType2["Error"] = "error";
  CompilationMessageType2["Warning"] = "warning";
  CompilationMessageType2["Info"] = "info";
})(CompilationMessageType || (CompilationMessageType = {}));
var PipelineErrorReason;
(function(PipelineErrorReason2) {
  PipelineErrorReason2["Validation"] = "validation";
  PipelineErrorReason2["Internal"] = "internal";
})(PipelineErrorReason || (PipelineErrorReason = {}));
var AutoLayoutMode;
(function(AutoLayoutMode2) {
  AutoLayoutMode2["Auto"] = "auto";
})(AutoLayoutMode || (AutoLayoutMode = {}));
var PrimitiveTopology;
(function(PrimitiveTopology2) {
  PrimitiveTopology2["PointList"] = "point-list";
  PrimitiveTopology2["LineList"] = "line-list";
  PrimitiveTopology2["LineStrip"] = "line-strip";
  PrimitiveTopology2["TriangleList"] = "triangle-list";
  PrimitiveTopology2["TriangleStrip"] = "triangle-strip";
})(PrimitiveTopology || (PrimitiveTopology = {}));
var FrontFace;
(function(FrontFace2) {
  FrontFace2["CCW"] = "ccw";
  FrontFace2["CW"] = "cw";
})(FrontFace || (FrontFace = {}));
var CullMode;
(function(CullMode2) {
  CullMode2["None"] = "none";
  CullMode2["Front"] = "front";
  CullMode2["Back"] = "back";
})(CullMode || (CullMode = {}));
var ColorWrite;
(function(ColorWrite2) {
  ColorWrite2[ColorWrite2["Red"] = 1] = "Red";
  ColorWrite2[ColorWrite2["Green"] = 2] = "Green";
  ColorWrite2[ColorWrite2["Blue"] = 4] = "Blue";
  ColorWrite2[ColorWrite2["Alpha"] = 8] = "Alpha";
  ColorWrite2[ColorWrite2["All"] = 15] = "All";
})(ColorWrite || (ColorWrite = {}));
var BlendFactor;
(function(BlendFactor2) {
  BlendFactor2["Zero"] = "zero";
  BlendFactor2["One"] = "one";
  BlendFactor2["Src"] = "src";
  BlendFactor2["OneMinusSrc"] = "one-minus-src";
  BlendFactor2["SrcAlpha"] = "src-alpha";
  BlendFactor2["OneMinusSrcAlpha"] = "one-minus-src-alpha";
  BlendFactor2["Dst"] = "dst";
  BlendFactor2["OneMinusDst"] = "one-minus-dst";
  BlendFactor2["DstAlpha"] = "dst-alpha";
  BlendFactor2["OneMinusDstAlpha"] = "one-minus-dst-alpha";
  BlendFactor2["SrcAlphaSaturated"] = "src-alpha-saturated";
  BlendFactor2["Constant"] = "constant";
  BlendFactor2["OneMinusConstant"] = "one-minus-constant";
  BlendFactor2["Src1"] = "src1";
  BlendFactor2["OneMinusSrc1"] = "one-minus-src1";
  BlendFactor2["Src1Alpha"] = "src1-alpha";
  BlendFactor2["OneMinusSrc1Alpha"] = "one-minus-src1-alpha";
})(BlendFactor || (BlendFactor = {}));
var BlendOperation;
(function(BlendOperation2) {
  BlendOperation2["Add"] = "add";
  BlendOperation2["Subtract"] = "subtract";
  BlendOperation2["ReverseSubtract"] = "reverse-subtract";
  BlendOperation2["Min"] = "min";
  BlendOperation2["Max"] = "max";
})(BlendOperation || (BlendOperation = {}));
var StencilOperation;
(function(StencilOperation2) {
  StencilOperation2["Keep"] = "keep";
  StencilOperation2["Zero"] = "zero";
  StencilOperation2["Replace"] = "replace";
  StencilOperation2["Invert"] = "invert";
  StencilOperation2["IncrementClamp"] = "increment-clamp";
  StencilOperation2["DecrementClamp"] = "decrement-clamp";
  StencilOperation2["IncrementWrap"] = "increment-wrap";
  StencilOperation2["DecrementWrap"] = "decrement-wrap";
})(StencilOperation || (StencilOperation = {}));
var IndexFormat;
(function(IndexFormat2) {
  IndexFormat2["Uint16"] = "uint16";
  IndexFormat2["Uint32"] = "uint32";
})(IndexFormat || (IndexFormat = {}));
var VertexFormat;
(function(VertexFormat2) {
  VertexFormat2["Uint8x2"] = "uint8x2";
  VertexFormat2["Uint8x4"] = "uint8x4";
  VertexFormat2["Sint8x2"] = "sint8x2";
  VertexFormat2["Sint8x4"] = "sint8x4";
  VertexFormat2["Unorm8x2"] = "unorm8x2";
  VertexFormat2["Unorm8x4"] = "unorm8x4";
  VertexFormat2["Snorm8x2"] = "snorm8x2";
  VertexFormat2["Snorm8x4"] = "snorm8x4";
  VertexFormat2["Uint16x2"] = "uint16x2";
  VertexFormat2["Uint16x4"] = "uint16x4";
  VertexFormat2["Sint16x2"] = "sint16x2";
  VertexFormat2["Sint16x4"] = "sint16x4";
  VertexFormat2["Unorm16x2"] = "unorm16x2";
  VertexFormat2["Unorm16x4"] = "unorm16x4";
  VertexFormat2["Snorm16x2"] = "snorm16x2";
  VertexFormat2["Snorm16x4"] = "snorm16x4";
  VertexFormat2["Float16x2"] = "float16x2";
  VertexFormat2["Float16x4"] = "float16x4";
  VertexFormat2["Float32"] = "float32";
  VertexFormat2["Float32x2"] = "float32x2";
  VertexFormat2["Float32x3"] = "float32x3";
  VertexFormat2["Float32x4"] = "float32x4";
  VertexFormat2["Uint32"] = "uint32";
  VertexFormat2["Uint32x2"] = "uint32x2";
  VertexFormat2["Uint32x3"] = "uint32x3";
  VertexFormat2["Uint32x4"] = "uint32x4";
  VertexFormat2["Sint32"] = "sint32";
  VertexFormat2["Sint32x2"] = "sint32x2";
  VertexFormat2["Sint32x3"] = "sint32x3";
  VertexFormat2["Sint32x4"] = "sint32x4";
  VertexFormat2["UNORM10x10x10x2"] = "unorm10-10-10-2";
})(VertexFormat || (VertexFormat = {}));
var VertexStepMode;
(function(VertexStepMode2) {
  VertexStepMode2["Vertex"] = "vertex";
  VertexStepMode2["Instance"] = "instance";
})(VertexStepMode || (VertexStepMode = {}));
var ComputePassTimestampLocation;
(function(ComputePassTimestampLocation2) {
  ComputePassTimestampLocation2["Beginning"] = "beginning";
  ComputePassTimestampLocation2["End"] = "end";
})(ComputePassTimestampLocation || (ComputePassTimestampLocation = {}));
var RenderPassTimestampLocation;
(function(RenderPassTimestampLocation2) {
  RenderPassTimestampLocation2["Beginning"] = "beginning";
  RenderPassTimestampLocation2["End"] = "end";
})(RenderPassTimestampLocation || (RenderPassTimestampLocation = {}));
var LoadOp;
(function(LoadOp2) {
  LoadOp2["Load"] = "load";
  LoadOp2["Clear"] = "clear";
})(LoadOp || (LoadOp = {}));
var StoreOp;
(function(StoreOp2) {
  StoreOp2["Store"] = "store";
  StoreOp2["Discard"] = "discard";
})(StoreOp || (StoreOp = {}));
var QueryType;
(function(QueryType2) {
  QueryType2["Occlusion"] = "occlusion";
  QueryType2["Timestamp"] = "timestamp";
})(QueryType || (QueryType = {}));
var CanvasAlphaMode;
(function(CanvasAlphaMode2) {
  CanvasAlphaMode2["Opaque"] = "opaque";
  CanvasAlphaMode2["Premultiplied"] = "premultiplied";
})(CanvasAlphaMode || (CanvasAlphaMode = {}));
var CanvasToneMappingMode;
(function(CanvasToneMappingMode2) {
  CanvasToneMappingMode2["Standard"] = "standard";
  CanvasToneMappingMode2["Extended"] = "extended";
})(CanvasToneMappingMode || (CanvasToneMappingMode = {}));
var DeviceLostReason;
(function(DeviceLostReason2) {
  DeviceLostReason2["Unknown"] = "unknown";
  DeviceLostReason2["Destroyed"] = "destroyed";
})(DeviceLostReason || (DeviceLostReason = {}));
var ErrorFilter;
(function(ErrorFilter2) {
  ErrorFilter2["Validation"] = "validation";
  ErrorFilter2["OutOfMemory"] = "out-of-memory";
  ErrorFilter2["Internal"] = "internal";
})(ErrorFilter || (ErrorFilter = {}));

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuShaderProcessor.js
var WebGPUShaderProcessor = class _WebGPUShaderProcessor {
  constructor() {
    this.shaderLanguage = 0;
  }
  _addUniformToLeftOverUBO(name3, uniformType, preProcessors) {
    let length = 0;
    [name3, uniformType, length] = this._getArraySize(name3, uniformType, preProcessors);
    for (let i = 0; i < this._webgpuProcessingContext.leftOverUniforms.length; i++) {
      if (this._webgpuProcessingContext.leftOverUniforms[i].name === name3) {
        return;
      }
    }
    this._webgpuProcessingContext.leftOverUniforms.push({
      name: name3,
      type: uniformType,
      length
    });
  }
  _buildLeftOverUBO() {
    if (!this._webgpuProcessingContext.leftOverUniforms.length) {
      return "";
    }
    const name3 = _WebGPUShaderProcessor.LeftOvertUBOName;
    let availableUBO = this._webgpuProcessingContext.availableBuffers[name3];
    if (!availableUBO) {
      availableUBO = {
        binding: this._webgpuProcessingContext.getNextFreeUBOBinding()
      };
      this._webgpuProcessingContext.availableBuffers[name3] = availableUBO;
      this._addBufferBindingDescription(name3, availableUBO, "uniform", true);
      this._addBufferBindingDescription(name3, availableUBO, "uniform", false);
    }
    return this._generateLeftOverUBOCode(name3, availableUBO);
  }
  _collectBindingNames() {
    for (let i = 0; i < this._webgpuProcessingContext.bindGroupLayoutEntries.length; i++) {
      const setDefinition = this._webgpuProcessingContext.bindGroupLayoutEntries[i];
      if (setDefinition === void 0) {
        this._webgpuProcessingContext.bindGroupLayoutEntries[i] = [];
        continue;
      }
      for (let j = 0; j < setDefinition.length; j++) {
        const entry = this._webgpuProcessingContext.bindGroupLayoutEntries[i][j];
        const name3 = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding].name;
        const nameInArrayOfTexture = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding].nameInArrayOfTexture;
        if (entry) {
          if (entry.texture || entry.externalTexture || entry.storageTexture) {
            this._webgpuProcessingContext.textureNames.push(nameInArrayOfTexture);
          } else if (entry.sampler) {
            this._webgpuProcessingContext.samplerNames.push(name3);
          } else if (entry.buffer) {
            this._webgpuProcessingContext.bufferNames.push(name3);
          }
        }
      }
    }
  }
  _preCreateBindGroupEntries() {
    const bindGroupEntries = this._webgpuProcessingContext.bindGroupEntries;
    for (let i = 0; i < this._webgpuProcessingContext.bindGroupLayoutEntries.length; i++) {
      const setDefinition = this._webgpuProcessingContext.bindGroupLayoutEntries[i];
      const entries = [];
      for (let j = 0; j < setDefinition.length; j++) {
        const entry = this._webgpuProcessingContext.bindGroupLayoutEntries[i][j];
        if (entry.sampler || entry.texture || entry.storageTexture || entry.externalTexture) {
          entries.push({
            binding: entry.binding,
            resource: void 0
          });
        } else if (entry.buffer) {
          entries.push({
            binding: entry.binding,
            resource: {
              buffer: void 0,
              offset: 0,
              size: 0
            }
          });
        }
      }
      bindGroupEntries[i] = entries;
    }
  }
  _addTextureBindingDescription(name3, textureInfo, textureIndex, dimension, format, isVertex) {
    let { groupIndex, bindingIndex } = textureInfo.textures[textureIndex];
    if (!this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex]) {
      this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex] = [];
      this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex] = [];
    }
    if (!this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex]) {
      let len;
      if (dimension === null) {
        len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({
          binding: bindingIndex,
          visibility: 0,
          externalTexture: {}
        });
      } else if (format) {
        len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({
          binding: bindingIndex,
          visibility: 0,
          storageTexture: {
            access: "write-only",
            format,
            viewDimension: dimension
          }
        });
      } else {
        len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({
          binding: bindingIndex,
          visibility: 0,
          texture: {
            sampleType: textureInfo.sampleType,
            viewDimension: dimension,
            multisampled: false
          }
        });
      }
      const textureName = textureInfo.isTextureArray ? name3 + textureIndex : name3;
      this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex] = { name: name3, index: len - 1, nameInArrayOfTexture: textureName };
    }
    bindingIndex = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex].index;
    if (isVertex) {
      this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= 1;
    } else {
      this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= 2;
    }
  }
  _addSamplerBindingDescription(name3, samplerInfo, isVertex) {
    let { groupIndex, bindingIndex } = samplerInfo.binding;
    if (!this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex]) {
      this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex] = [];
      this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex] = [];
    }
    if (!this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex]) {
      const len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({
        binding: bindingIndex,
        visibility: 0,
        sampler: {
          type: samplerInfo.type
        }
      });
      this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex] = { name: name3, index: len - 1 };
    }
    bindingIndex = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex].index;
    if (isVertex) {
      this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= 1;
    } else {
      this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= 2;
    }
  }
  _addBufferBindingDescription(name3, uniformBufferInfo, bufferType, isVertex) {
    let { groupIndex, bindingIndex } = uniformBufferInfo.binding;
    if (!this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex]) {
      this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex] = [];
      this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex] = [];
    }
    if (!this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex]) {
      const len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({
        binding: bindingIndex,
        visibility: 0,
        buffer: {
          type: bufferType
        }
      });
      this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex] = { name: name3, index: len - 1 };
    }
    bindingIndex = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex].index;
    if (isVertex) {
      this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= 1;
    } else {
      this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= 2;
    }
  }
};
WebGPUShaderProcessor.LeftOvertUBOName = "LeftOver";
WebGPUShaderProcessor.InternalsUBOName = "Internals";
WebGPUShaderProcessor.UniformSizes = {
  // GLSL types
  bool: 1,
  int: 1,
  float: 1,
  vec2: 2,
  ivec2: 2,
  uvec2: 2,
  vec3: 3,
  ivec3: 3,
  uvec3: 3,
  vec4: 4,
  ivec4: 4,
  uvec4: 4,
  mat2: 4,
  mat3: 12,
  mat4: 16,
  // WGSL types
  i32: 1,
  u32: 1,
  f32: 1,
  mat2x2: 4,
  mat3x3: 12,
  mat4x4: 16,
  mat2x2f: 4,
  mat3x3f: 12,
  mat4x4f: 16,
  vec2i: 2,
  vec3i: 3,
  vec4i: 4,
  vec2u: 2,
  vec3u: 3,
  vec4u: 4,
  vec2f: 2,
  vec3f: 3,
  vec4f: 4,
  vec2h: 1,
  vec3h: 2,
  vec4h: 2
};
WebGPUShaderProcessor._SamplerFunctionByWebGLSamplerType = {
  sampler2D: "sampler2D",
  sampler2DArray: "sampler2DArray",
  sampler2DShadow: "sampler2DShadow",
  sampler2DArrayShadow: "sampler2DArrayShadow",
  samplerCube: "samplerCube",
  sampler3D: "sampler3D"
};
WebGPUShaderProcessor._TextureTypeByWebGLSamplerType = {
  sampler2D: "texture2D",
  sampler2DArray: "texture2DArray",
  sampler2DShadow: "texture2D",
  sampler2DArrayShadow: "texture2DArray",
  samplerCube: "textureCube",
  samplerCubeArray: "textureCubeArray",
  sampler3D: "texture3D"
};
WebGPUShaderProcessor._GpuTextureViewDimensionByWebGPUTextureType = {
  textureCube: "cube",
  textureCubeArray: "cube-array",
  texture2D: "2d",
  texture2DArray: "2d-array",
  texture3D: "3d"
};
WebGPUShaderProcessor._SamplerTypeByWebGLSamplerType = {
  sampler2DShadow: "samplerShadow",
  sampler2DArrayShadow: "samplerShadow"
};
WebGPUShaderProcessor._IsComparisonSamplerByWebGPUSamplerType = {
  samplerShadow: true,
  samplerArrayShadow: true,
  sampler: false
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuPipelineContext.js
var WebGPUPipelineContext = class {
  get isAsync() {
    return false;
  }
  get isReady() {
    if (this.stages) {
      return true;
    }
    return false;
  }
  constructor(shaderProcessingContext, engine) {
    this.bindGroupLayouts = {};
    this._name = "unnamed";
    this.shaderProcessingContext = shaderProcessingContext;
    this._leftOverUniformsByName = {};
    this.engine = engine;
    this.vertexBufferKindToType = {};
  }
  _handlesSpectorRebuildCallback() {
  }
  _fillEffectInformation(effect, uniformBuffersNames, uniformsNames, uniforms, samplerList, samplers, attributesNames, attributes) {
    const engine = this.engine;
    if (engine._doNotHandleContextLost) {
      effect._fragmentSourceCode = "";
      effect._vertexSourceCode = "";
    }
    const foundSamplers = this.shaderProcessingContext.availableTextures;
    let index;
    for (index = 0; index < samplerList.length; index++) {
      const name3 = samplerList[index];
      const sampler = foundSamplers[samplerList[index]];
      if (sampler == null || sampler == void 0) {
        samplerList.splice(index, 1);
        index--;
      } else {
        samplers[name3] = index;
      }
    }
    for (const attr of engine.getAttributes(this, attributesNames)) {
      attributes.push(attr);
    }
    this.buildUniformLayout();
    const attributeNamesFromEffect = [];
    const attributeLocationsFromEffect = [];
    for (index = 0; index < attributesNames.length; index++) {
      const location = attributes[index];
      if (location >= 0) {
        attributeNamesFromEffect.push(attributesNames[index]);
        attributeLocationsFromEffect.push(location);
      }
    }
    this.shaderProcessingContext.attributeNamesFromEffect = attributeNamesFromEffect;
    this.shaderProcessingContext.attributeLocationsFromEffect = attributeLocationsFromEffect;
  }
  /** @internal */
  /**
   * Build the uniform buffer used in the material.
   */
  buildUniformLayout() {
    if (!this.shaderProcessingContext.leftOverUniforms.length) {
      return;
    }
    this.uniformBuffer?.dispose();
    this.uniformBuffer = new UniformBuffer(this.engine, void 0, void 0, "leftOver-" + this._name);
    for (const leftOverUniform of this.shaderProcessingContext.leftOverUniforms) {
      const type = leftOverUniform.type.replace(/^(.*?)(<.*>)?$/, "$1");
      const size = WebGPUShaderProcessor.UniformSizes[type];
      this.uniformBuffer.addUniform(leftOverUniform.name, size, leftOverUniform.length);
      this._leftOverUniformsByName[leftOverUniform.name] = leftOverUniform.type;
    }
    this.uniformBuffer.create();
  }
  setEngine(engine) {
    this.engine = engine;
  }
  /**
   * Release all associated resources.
   **/
  dispose() {
    if (this.uniformBuffer) {
      this.uniformBuffer.dispose();
    }
  }
  /**
   * Sets an integer value on a uniform variable.
   * @param uniformName Name of the variable.
   * @param value Value to be set.
   */
  setInt(uniformName, value) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateInt(uniformName, value);
  }
  /**
   * Sets an int2 value on a uniform variable.
   * @param uniformName Name of the variable.
   * @param x First int in int2.
   * @param y Second int in int2.
   */
  setInt2(uniformName, x, y) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateInt2(uniformName, x, y);
  }
  /**
   * Sets an int3 value on a uniform variable.
   * @param uniformName Name of the variable.
   * @param x First int in int3.
   * @param y Second int in int3.
   * @param z Third int in int3.
   */
  setInt3(uniformName, x, y, z) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateInt3(uniformName, x, y, z);
  }
  /**
   * Sets an int4 value on a uniform variable.
   * @param uniformName Name of the variable.
   * @param x First int in int4.
   * @param y Second int in int4.
   * @param z Third int in int4.
   * @param w Fourth int in int4.
   */
  setInt4(uniformName, x, y, z, w) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateInt4(uniformName, x, y, z, w);
  }
  /**
   * Sets an int array on a uniform variable.
   * @param uniformName Name of the variable.
   * @param array array to be set.
   */
  setIntArray(uniformName, array) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateIntArray(uniformName, array);
  }
  /**
   * Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   */
  setIntArray2(uniformName, array) {
    this.setIntArray(uniformName, array);
  }
  /**
   * Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   */
  setIntArray3(uniformName, array) {
    this.setIntArray(uniformName, array);
  }
  /**
   * Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   */
  setIntArray4(uniformName, array) {
    this.setIntArray(uniformName, array);
  }
  /**
   * Sets an unsigned integer value on a uniform variable.
   * @param uniformName Name of the variable.
   * @param value Value to be set.
   */
  setUInt(uniformName, value) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateUInt(uniformName, value);
  }
  /**
   * Sets an unsigned int2 value on a uniform variable.
   * @param uniformName Name of the variable.
   * @param x First unsigned int in uint2.
   * @param y Second unsigned int in uint2.
   */
  setUInt2(uniformName, x, y) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateUInt2(uniformName, x, y);
  }
  /**
   * Sets an unsigned int3 value on a uniform variable.
   * @param uniformName Name of the variable.
   * @param x First unsigned int in uint3.
   * @param y Second unsigned int in uint3.
   * @param z Third unsigned int in uint3.
   */
  setUInt3(uniformName, x, y, z) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateUInt3(uniformName, x, y, z);
  }
  /**
   * Sets an unsigned int4 value on a uniform variable.
   * @param uniformName Name of the variable.
   * @param x First unsigned int in uint4.
   * @param y Second unsigned int in uint4.
   * @param z Third unsigned int in uint4.
   * @param w Fourth unsigned int in uint4.
   */
  setUInt4(uniformName, x, y, z, w) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateUInt4(uniformName, x, y, z, w);
  }
  /**
   * Sets an unsigned int array on a uniform variable.
   * @param uniformName Name of the variable.
   * @param array array to be set.
   */
  setUIntArray(uniformName, array) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateUIntArray(uniformName, array);
  }
  /**
   * Sets an unsigned int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   */
  setUIntArray2(uniformName, array) {
    this.setUIntArray(uniformName, array);
  }
  /**
   * Sets an unsigned int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   */
  setUIntArray3(uniformName, array) {
    this.setUIntArray(uniformName, array);
  }
  /**
   * Sets an unsigned int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   */
  setUIntArray4(uniformName, array) {
    this.setUIntArray(uniformName, array);
  }
  /**
   * Sets an array on a uniform variable.
   * @param uniformName Name of the variable.
   * @param array array to be set.
   */
  setArray(uniformName, array) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateArray(uniformName, array);
  }
  /**
   * Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   */
  setArray2(uniformName, array) {
    this.setArray(uniformName, array);
  }
  /**
   * Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   */
  setArray3(uniformName, array) {
    this.setArray(uniformName, array);
  }
  /**
   * Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   */
  setArray4(uniformName, array) {
    this.setArray(uniformName, array);
  }
  /**
   * Sets matrices on a uniform variable.
   * @param uniformName Name of the variable.
   * @param matrices matrices to be set.
   */
  setMatrices(uniformName, matrices) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateMatrices(uniformName, matrices);
  }
  /**
   * Sets matrix on a uniform variable.
   * @param uniformName Name of the variable.
   * @param matrix matrix to be set.
   */
  setMatrix(uniformName, matrix) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateMatrix(uniformName, matrix);
  }
  /**
   * Sets a 3x3 matrix on a uniform variable. (Specified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)
   * @param uniformName Name of the variable.
   * @param matrix matrix to be set.
   */
  setMatrix3x3(uniformName, matrix) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateMatrix3x3(uniformName, matrix);
  }
  /**
   * Sets a 2x2 matrix on a uniform variable. (Specified as [1,2,3,4] will result in [1,2][3,4] matrix)
   * @param uniformName Name of the variable.
   * @param matrix matrix to be set.
   */
  setMatrix2x2(uniformName, matrix) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateMatrix2x2(uniformName, matrix);
  }
  /**
   * Sets a float on a uniform variable.
   * @param uniformName Name of the variable.
   * @param value value to be set.
   */
  setFloat(uniformName, value) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateFloat(uniformName, value);
  }
  /**
   * Sets a Vector2 on a uniform variable.
   * @param uniformName Name of the variable.
   * @param vector2 vector2 to be set.
   */
  setVector2(uniformName, vector2) {
    this.setFloat2(uniformName, vector2.x, vector2.y);
  }
  /**
   * Sets a float2 on a uniform variable.
   * @param uniformName Name of the variable.
   * @param x First float in float2.
   * @param y Second float in float2.
   */
  setFloat2(uniformName, x, y) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateFloat2(uniformName, x, y);
  }
  /**
   * Sets a Vector3 on a uniform variable.
   * @param uniformName Name of the variable.
   * @param vector3 Value to be set.
   */
  setVector3(uniformName, vector3) {
    this.setFloat3(uniformName, vector3.x, vector3.y, vector3.z);
  }
  /**
   * Sets a float3 on a uniform variable.
   * @param uniformName Name of the variable.
   * @param x First float in float3.
   * @param y Second float in float3.
   * @param z Third float in float3.
   */
  setFloat3(uniformName, x, y, z) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateFloat3(uniformName, x, y, z);
  }
  /**
   * Sets a Vector4 on a uniform variable.
   * @param uniformName Name of the variable.
   * @param vector4 Value to be set.
   */
  setVector4(uniformName, vector4) {
    this.setFloat4(uniformName, vector4.x, vector4.y, vector4.z, vector4.w);
  }
  /**
   * Sets a Quaternion on a uniform variable.
   * @param uniformName Name of the variable.
   * @param quaternion Value to be set.
   */
  setQuaternion(uniformName, quaternion) {
    this.setFloat4(uniformName, quaternion.x, quaternion.y, quaternion.z, quaternion.w);
  }
  /**
   * Sets a float4 on a uniform variable.
   * @param uniformName Name of the variable.
   * @param x First float in float4.
   * @param y Second float in float4.
   * @param z Third float in float4.
   * @param w Fourth float in float4.
   */
  setFloat4(uniformName, x, y, z, w) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateFloat4(uniformName, x, y, z, w);
  }
  /**
   * Sets a Color3 on a uniform variable.
   * @param uniformName Name of the variable.
   * @param color3 Value to be set.
   */
  setColor3(uniformName, color3) {
    this.setFloat3(uniformName, color3.r, color3.g, color3.b);
  }
  /**
   * Sets a Color4 on a uniform variable.
   * @param uniformName Name of the variable.
   * @param color3 Value to be set.
   * @param alpha Alpha value to be set.
   */
  setColor4(uniformName, color3, alpha) {
    this.setFloat4(uniformName, color3.r, color3.g, color3.b, alpha);
  }
  /**
   * Sets a Color4 on a uniform variable
   * @param uniformName defines the name of the variable
   * @param color4 defines the value to be set
   */
  setDirectColor4(uniformName, color4) {
    this.setFloat4(uniformName, color4.r, color4.g, color4.b, color4.a);
  }
  _getVertexShaderCode() {
    return this.sources?.vertex;
  }
  _getFragmentShaderCode() {
    return this.sources?.fragment;
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuShaderProcessingContext.js
var _maxGroups = 4;
var _maxBindingsPerGroup = 1 << 16;
var _typeToLocationSize = {
  // GLSL types
  mat2: 2,
  mat3: 3,
  mat4: 4,
  // WGSL types
  mat2x2: 2,
  mat3x3: 3,
  mat4x4: 4
};
var WebGPUShaderProcessingContext = class _WebGPUShaderProcessingContext {
  static get KnownUBOs() {
    return _WebGPUShaderProcessingContext._SimplifiedKnownBindings ? _WebGPUShaderProcessingContext._SimplifiedKnownUBOs : _WebGPUShaderProcessingContext._KnownUBOs;
  }
  constructor(shaderLanguage, pureMode = false) {
    this.vertexBufferKindToNumberOfComponents = {};
    this.shaderLanguage = shaderLanguage;
    this._attributeNextLocation = 0;
    this._varyingNextLocation = 0;
    this.freeGroupIndex = 0;
    this.freeBindingIndex = 0;
    this.availableVaryings = {};
    this.availableAttributes = {};
    this.availableBuffers = {};
    this.availableTextures = {};
    this.availableSamplers = {};
    this.orderedAttributes = [];
    this.bindGroupLayoutEntries = [];
    this.bindGroupLayoutEntryInfo = [];
    this.bindGroupEntries = [];
    this.bufferNames = [];
    this.textureNames = [];
    this.samplerNames = [];
    this.leftOverUniforms = [];
    if (!pureMode) {
      this._findStartingGroupBinding();
    }
  }
  _findStartingGroupBinding() {
    const knownUBOs = _WebGPUShaderProcessingContext.KnownUBOs;
    const groups = [];
    for (const name3 in knownUBOs) {
      const binding = knownUBOs[name3].binding;
      if (binding.groupIndex === -1) {
        continue;
      }
      if (groups[binding.groupIndex] === void 0) {
        groups[binding.groupIndex] = binding.bindingIndex;
      } else {
        groups[binding.groupIndex] = Math.max(groups[binding.groupIndex], binding.bindingIndex);
      }
    }
    this.freeGroupIndex = groups.length - 1;
    if (this.freeGroupIndex === 0) {
      this.freeGroupIndex++;
      this.freeBindingIndex = 0;
    } else {
      this.freeBindingIndex = groups[groups.length - 1] + 1;
    }
  }
  getAttributeNextLocation(dataType, arrayLength = 0) {
    const index = this._attributeNextLocation;
    this._attributeNextLocation += (_typeToLocationSize[dataType] ?? 1) * (arrayLength || 1);
    return index;
  }
  getVaryingNextLocation(dataType, arrayLength = 0) {
    const index = this._varyingNextLocation;
    this._varyingNextLocation += (_typeToLocationSize[dataType] ?? 1) * (arrayLength || 1);
    return index;
  }
  getNextFreeUBOBinding() {
    return this._getNextFreeBinding(1);
  }
  _getNextFreeBinding(bindingCount) {
    if (this.freeBindingIndex > _maxBindingsPerGroup - bindingCount) {
      this.freeGroupIndex++;
      this.freeBindingIndex = 0;
    }
    if (this.freeGroupIndex === _maxGroups) {
      throw "Too many textures or UBOs have been declared and it is not supported in WebGPU.";
    }
    const returnValue = {
      groupIndex: this.freeGroupIndex,
      bindingIndex: this.freeBindingIndex
    };
    this.freeBindingIndex += bindingCount;
    return returnValue;
  }
};
WebGPUShaderProcessingContext._SimplifiedKnownBindings = true;
WebGPUShaderProcessingContext._SimplifiedKnownUBOs = {
  Scene: { binding: { groupIndex: 0, bindingIndex: 0 } },
  Light0: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light1: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light2: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light3: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light4: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light5: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light6: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light7: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light8: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light9: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light10: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light11: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light12: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light13: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light14: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light15: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light16: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light17: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light18: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light19: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light20: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light21: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light22: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light23: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light24: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light25: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light26: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light27: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light28: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light29: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light30: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light31: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Material: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Mesh: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Internals: { binding: { groupIndex: -1, bindingIndex: -1 } }
};
WebGPUShaderProcessingContext._KnownUBOs = {
  Scene: { binding: { groupIndex: 0, bindingIndex: 0 } },
  Light0: { binding: { groupIndex: 1, bindingIndex: 0 } },
  Light1: { binding: { groupIndex: 1, bindingIndex: 1 } },
  Light2: { binding: { groupIndex: 1, bindingIndex: 2 } },
  Light3: { binding: { groupIndex: 1, bindingIndex: 3 } },
  Light4: { binding: { groupIndex: 1, bindingIndex: 4 } },
  Light5: { binding: { groupIndex: 1, bindingIndex: 5 } },
  Light6: { binding: { groupIndex: 1, bindingIndex: 6 } },
  Light7: { binding: { groupIndex: 1, bindingIndex: 7 } },
  Light8: { binding: { groupIndex: 1, bindingIndex: 8 } },
  Light9: { binding: { groupIndex: 1, bindingIndex: 9 } },
  Light10: { binding: { groupIndex: 1, bindingIndex: 10 } },
  Light11: { binding: { groupIndex: 1, bindingIndex: 11 } },
  Light12: { binding: { groupIndex: 1, bindingIndex: 12 } },
  Light13: { binding: { groupIndex: 1, bindingIndex: 13 } },
  Light14: { binding: { groupIndex: 1, bindingIndex: 14 } },
  Light15: { binding: { groupIndex: 1, bindingIndex: 15 } },
  Light16: { binding: { groupIndex: 1, bindingIndex: 16 } },
  Light17: { binding: { groupIndex: 1, bindingIndex: 17 } },
  Light18: { binding: { groupIndex: 1, bindingIndex: 18 } },
  Light19: { binding: { groupIndex: 1, bindingIndex: 19 } },
  Light20: { binding: { groupIndex: 1, bindingIndex: 20 } },
  Light21: { binding: { groupIndex: 1, bindingIndex: 21 } },
  Light22: { binding: { groupIndex: 1, bindingIndex: 22 } },
  Light23: { binding: { groupIndex: 1, bindingIndex: 23 } },
  Light24: { binding: { groupIndex: 1, bindingIndex: 24 } },
  Light25: { binding: { groupIndex: 1, bindingIndex: 25 } },
  Light26: { binding: { groupIndex: 1, bindingIndex: 26 } },
  Light27: { binding: { groupIndex: 1, bindingIndex: 27 } },
  Light28: { binding: { groupIndex: 1, bindingIndex: 28 } },
  Light29: { binding: { groupIndex: 1, bindingIndex: 29 } },
  Light30: { binding: { groupIndex: 1, bindingIndex: 30 } },
  Light31: { binding: { groupIndex: 1, bindingIndex: 31 } },
  Material: { binding: { groupIndex: 2, bindingIndex: 0 } },
  Mesh: { binding: { groupIndex: 2, bindingIndex: 1 } },
  Internals: { binding: { groupIndex: 2, bindingIndex: 2 } }
};

// node_modules/@babylonjs/core/Misc/codeStringParsingTools.js
function ExtractBetweenMarkers(markerOpen, markerClose, block, startIndex) {
  let currPos = startIndex, openMarkers = 0, waitForChar = "";
  while (currPos < block.length) {
    const currChar = block.charAt(currPos);
    if (!waitForChar) {
      switch (currChar) {
        case markerOpen:
          openMarkers++;
          break;
        case markerClose:
          openMarkers--;
          break;
        case '"':
        case "'":
        case "`":
          waitForChar = currChar;
          break;
        case "/":
          if (currPos + 1 < block.length) {
            const nextChar = block.charAt(currPos + 1);
            if (nextChar === "/") {
              waitForChar = "\n";
            } else if (nextChar === "*") {
              waitForChar = "*/";
            }
          }
          break;
      }
    } else {
      if (currChar === waitForChar) {
        if (waitForChar === '"' || waitForChar === "'") {
          block.charAt(currPos - 1) !== "\\" && (waitForChar = "");
        } else {
          waitForChar = "";
        }
      } else if (waitForChar === "*/" && currChar === "*" && currPos + 1 < block.length) {
        block.charAt(currPos + 1) === "/" && (waitForChar = "");
        if (waitForChar === "") {
          currPos++;
        }
      }
    }
    currPos++;
    if (openMarkers === 0) {
      break;
    }
  }
  return openMarkers === 0 ? currPos - 1 : -1;
}
function SkipWhitespaces(s, index) {
  while (index < s.length) {
    const c = s[index];
    if (c !== " " && c !== "\n" && c !== "\r" && c !== "	" && c !== "\n" && c !== "") {
      break;
    }
    index++;
  }
  return index;
}
function IsIdentifierChar(c) {
  const v = c.charCodeAt(0);
  return v >= 48 && v <= 57 || // 0-9
  v >= 65 && v <= 90 || // A-Z
  v >= 97 && v <= 122 || // a-z
  v == 95;
}
function RemoveComments(block) {
  let currPos = 0, waitForChar = "", inComments = false;
  const s = [];
  while (currPos < block.length) {
    const currChar = block.charAt(currPos);
    if (!waitForChar) {
      switch (currChar) {
        case '"':
        case "'":
        case "`":
          waitForChar = currChar;
          break;
        case "/":
          if (currPos + 1 < block.length) {
            const nextChar = block.charAt(currPos + 1);
            if (nextChar === "/") {
              waitForChar = "\n";
              inComments = true;
            } else if (nextChar === "*") {
              waitForChar = "*/";
              inComments = true;
            }
          }
          break;
      }
      if (!inComments) {
        s.push(currChar);
      }
    } else {
      if (currChar === waitForChar) {
        if (waitForChar === '"' || waitForChar === "'") {
          block.charAt(currPos - 1) !== "\\" && (waitForChar = "");
          s.push(currChar);
        } else {
          waitForChar = "";
          inComments = false;
        }
      } else if (waitForChar === "*/" && currChar === "*" && currPos + 1 < block.length) {
        block.charAt(currPos + 1) === "/" && (waitForChar = "");
        if (waitForChar === "") {
          inComments = false;
          currPos++;
        }
      } else {
        if (!inComments) {
          s.push(currChar);
        }
      }
    }
    currPos++;
  }
  return s.join("");
}
function FindBackward(s, index, c, c2) {
  while (index >= 0 && s.charAt(index) !== c && (!c2 || s.charAt(index) !== c2)) {
    index--;
  }
  return index;
}
function EscapeRegExp(s) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function InjectStartingAndEndingCode(code, mainFuncDecl, startingCode, endingCode) {
  let idx = code.indexOf(mainFuncDecl);
  if (idx < 0) {
    return code;
  }
  if (startingCode) {
    while (idx++ < code.length && code.charAt(idx) != "{") {
    }
    if (idx < code.length) {
      const part1 = code.substring(0, idx + 1);
      const part2 = code.substring(idx + 1);
      code = part1 + startingCode + part2;
    }
  }
  if (endingCode) {
    const lastClosingCurly = code.lastIndexOf("}");
    code = code.substring(0, lastClosingCurly);
    code += endingCode + "\n}";
  }
  return code;
}

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuShaderProcessorsGLSL.js
var WebGPUShaderProcessorGLSL = class extends WebGPUShaderProcessor {
  constructor() {
    super(...arguments);
    this._missingVaryings = [];
    this._textureArrayProcessing = [];
    this._vertexIsGLES3 = false;
    this._fragmentIsGLES3 = false;
    this.shaderLanguage = 0;
    this.parseGLES3 = true;
  }
  _getArraySize(name3, type, preProcessors) {
    let length = 0;
    const startArray = name3.indexOf("[");
    const endArray = name3.indexOf("]");
    if (startArray > 0 && endArray > 0) {
      const lengthInString = name3.substring(startArray + 1, endArray);
      length = +lengthInString;
      if (isNaN(length)) {
        length = +preProcessors[lengthInString.trim()];
      }
      name3 = name3.substring(0, startArray);
    }
    return [name3, type, length];
  }
  initializeShaders(processingContext) {
    this._webgpuProcessingContext = processingContext;
    this._missingVaryings.length = 0;
    this._textureArrayProcessing.length = 0;
    this.attributeKeywordName = void 0;
    this.varyingVertexKeywordName = void 0;
    this.varyingFragmentKeywordName = void 0;
  }
  preProcessShaderCode(code, isFragment) {
    const ubDeclaration = `// Internals UBO
uniform ${WebGPUShaderProcessor.InternalsUBOName} {
float yFactor_;
float textureOutputHeight_;
};
`;
    const alreadyInjected = code.indexOf("// Internals UBO") !== -1;
    if (isFragment) {
      this._fragmentIsGLES3 = code.indexOf("#version 3") !== -1;
      if (this._fragmentIsGLES3) {
        this.varyingFragmentKeywordName = "in";
      }
      return alreadyInjected ? code : ubDeclaration + "##INJECTCODE##\n" + code;
    }
    this._vertexIsGLES3 = code.indexOf("#version 3") !== -1;
    if (this._vertexIsGLES3) {
      this.attributeKeywordName = "in";
      this.varyingVertexKeywordName = "out";
    }
    return alreadyInjected ? code : ubDeclaration + code;
  }
  varyingCheck(varying, isFragment) {
    const outRegex = /(flat\s)?\s*\bout\b/;
    const inRegex = /(flat\s)?\s*\bin\b/;
    const varyingRegex = /(flat\s)?\s*\bvarying\b/;
    const regex = isFragment && this._fragmentIsGLES3 ? inRegex : !isFragment && this._vertexIsGLES3 ? outRegex : varyingRegex;
    return regex.test(varying);
  }
  varyingProcessor(varying, isFragment, preProcessors) {
    this._preProcessors = preProcessors;
    const outRegex = /\s*(flat)?\s*out\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/gm;
    const inRegex = /\s*(flat)?\s*in\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/gm;
    const varyingRegex = /\s*(flat)?\s*varying\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/gm;
    const regex = isFragment && this._fragmentIsGLES3 ? inRegex : !isFragment && this._vertexIsGLES3 ? outRegex : varyingRegex;
    const match = regex.exec(varying);
    if (match !== null) {
      const interpolationQualifier = match[1] ?? "";
      const varyingType = match[2];
      const name3 = match[3];
      let location;
      if (isFragment) {
        location = this._webgpuProcessingContext.availableVaryings[name3];
        this._missingVaryings[location] = "";
        if (location === void 0) {
          Logger.Warn(`Invalid fragment shader: The varying named "${name3}" is not declared in the vertex shader! This declaration will be ignored.`);
        }
      } else {
        location = this._webgpuProcessingContext.getVaryingNextLocation(varyingType, this._getArraySize(name3, varyingType, preProcessors)[2]);
        this._webgpuProcessingContext.availableVaryings[name3] = location;
        this._missingVaryings[location] = `layout(location = ${location}) ${interpolationQualifier} in ${varyingType} ${name3};`;
      }
      varying = varying.replace(match[0], location === void 0 ? "" : `layout(location = ${location}) ${interpolationQualifier} ${isFragment ? "in" : "out"} ${varyingType} ${name3};`);
    }
    return varying;
  }
  attributeProcessor(attribute, preProcessors) {
    this._preProcessors = preProcessors;
    const inRegex = /\s*in\s+(\S+)\s+(\S+)\s*;/gm;
    const attribRegex = /\s*attribute\s+(\S+)\s+(\S+)\s*;/gm;
    const regex = this._vertexIsGLES3 ? inRegex : attribRegex;
    const match = regex.exec(attribute);
    if (match !== null) {
      const attributeType = match[1];
      const name3 = match[2];
      const location = this._webgpuProcessingContext.getAttributeNextLocation(attributeType, this._getArraySize(name3, attributeType, preProcessors)[2]);
      this._webgpuProcessingContext.availableAttributes[name3] = location;
      this._webgpuProcessingContext.orderedAttributes[location] = name3;
      const numComponents = this._webgpuProcessingContext.vertexBufferKindToNumberOfComponents[name3];
      if (numComponents !== void 0) {
        const newType = numComponents < 0 ? numComponents === -1 ? "int" : "ivec" + -numComponents : numComponents === 1 ? "uint" : "uvec" + numComponents;
        const newName = `_int_${name3}_`;
        attribute = attribute.replace(match[0], `layout(location = ${location}) in ${newType} ${newName}; ${attributeType} ${name3} = ${attributeType}(${newName});`);
      } else {
        attribute = attribute.replace(match[0], `layout(location = ${location}) in ${attributeType} ${name3};`);
      }
    }
    return attribute;
  }
  uniformProcessor(uniform, isFragment, preProcessors) {
    this._preProcessors = preProcessors;
    const uniformRegex = /\s*uniform\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/gm;
    const match = uniformRegex.exec(uniform);
    if (match !== null) {
      let uniformType = match[1];
      let name3 = match[2];
      if (uniformType.indexOf("sampler") === 0 || uniformType.indexOf("sampler") === 1) {
        let arraySize = 0;
        [name3, uniformType, arraySize] = this._getArraySize(name3, uniformType, preProcessors);
        let textureInfo = this._webgpuProcessingContext.availableTextures[name3];
        if (!textureInfo) {
          textureInfo = {
            autoBindSampler: true,
            isTextureArray: arraySize > 0,
            isStorageTexture: false,
            textures: [],
            sampleType: "float"
          };
          for (let i = 0; i < (arraySize || 1); ++i) {
            textureInfo.textures.push(this._webgpuProcessingContext.getNextFreeUBOBinding());
          }
        }
        const samplerType = WebGPUShaderProcessor._SamplerTypeByWebGLSamplerType[uniformType] ?? "sampler";
        const isComparisonSampler = !!WebGPUShaderProcessor._IsComparisonSamplerByWebGPUSamplerType[samplerType];
        const samplerBindingType = isComparisonSampler ? "comparison" : "filtering";
        const samplerName = name3 + `Sampler`;
        let samplerInfo = this._webgpuProcessingContext.availableSamplers[samplerName];
        if (!samplerInfo) {
          samplerInfo = {
            binding: this._webgpuProcessingContext.getNextFreeUBOBinding(),
            type: samplerBindingType
          };
        }
        const componentType = uniformType.charAt(0) === "u" ? "u" : uniformType.charAt(0) === "i" ? "i" : "";
        if (componentType) {
          uniformType = uniformType.substring(1);
        }
        const sampleType = isComparisonSampler ? "depth" : componentType === "u" ? "uint" : componentType === "i" ? "sint" : "float";
        textureInfo.sampleType = sampleType;
        const isTextureArray = arraySize > 0;
        const samplerGroupIndex = samplerInfo.binding.groupIndex;
        const samplerBindingIndex = samplerInfo.binding.bindingIndex;
        const samplerFunction = WebGPUShaderProcessor._SamplerFunctionByWebGLSamplerType[uniformType];
        const textureType = WebGPUShaderProcessor._TextureTypeByWebGLSamplerType[uniformType];
        const textureDimension = WebGPUShaderProcessor._GpuTextureViewDimensionByWebGPUTextureType[textureType];
        if (!isTextureArray) {
          arraySize = 1;
          uniform = `layout(set = ${samplerGroupIndex}, binding = ${samplerBindingIndex}) uniform ${samplerType} ${samplerName};
                        layout(set = ${textureInfo.textures[0].groupIndex}, binding = ${textureInfo.textures[0].bindingIndex}) uniform ${componentType}${textureType} ${name3}Texture;
                        #define ${name3} ${componentType}${samplerFunction}(${name3}Texture, ${samplerName})`;
        } else {
          const layouts = [];
          layouts.push(`layout(set = ${samplerGroupIndex}, binding = ${samplerBindingIndex}) uniform ${componentType}${samplerType} ${samplerName};`);
          uniform = `
`;
          for (let i = 0; i < arraySize; ++i) {
            const textureSetIndex = textureInfo.textures[i].groupIndex;
            const textureBindingIndex = textureInfo.textures[i].bindingIndex;
            layouts.push(`layout(set = ${textureSetIndex}, binding = ${textureBindingIndex}) uniform ${textureType} ${name3}Texture${i};`);
            uniform += `${i > 0 ? "\n" : ""}#define ${name3}${i} ${componentType}${samplerFunction}(${name3}Texture${i}, ${samplerName})`;
          }
          uniform = layouts.join("\n") + uniform;
          this._textureArrayProcessing.push(name3);
        }
        this._webgpuProcessingContext.availableTextures[name3] = textureInfo;
        this._webgpuProcessingContext.availableSamplers[samplerName] = samplerInfo;
        this._addSamplerBindingDescription(samplerName, samplerInfo, !isFragment);
        for (let i = 0; i < arraySize; ++i) {
          this._addTextureBindingDescription(name3, textureInfo, i, textureDimension, null, !isFragment);
        }
      } else {
        this._addUniformToLeftOverUBO(name3, uniformType, preProcessors);
        uniform = "";
      }
    }
    return uniform;
  }
  uniformBufferProcessor(uniformBuffer, isFragment) {
    const uboRegex = /uniform\s+(\w+)/gm;
    const match = uboRegex.exec(uniformBuffer);
    if (match !== null) {
      const name3 = match[1];
      let uniformBufferInfo = this._webgpuProcessingContext.availableBuffers[name3];
      if (!uniformBufferInfo) {
        const knownUBO = WebGPUShaderProcessingContext.KnownUBOs[name3];
        let binding;
        if (knownUBO && knownUBO.binding.groupIndex !== -1) {
          binding = knownUBO.binding;
        } else {
          binding = this._webgpuProcessingContext.getNextFreeUBOBinding();
        }
        uniformBufferInfo = { binding };
        this._webgpuProcessingContext.availableBuffers[name3] = uniformBufferInfo;
      }
      this._addBufferBindingDescription(name3, uniformBufferInfo, "uniform", !isFragment);
      uniformBuffer = uniformBuffer.replace("uniform", `layout(set = ${uniformBufferInfo.binding.groupIndex}, binding = ${uniformBufferInfo.binding.bindingIndex}) uniform`);
    }
    return uniformBuffer;
  }
  postProcessor(code, defines, isFragment, _processingContext, _parameters) {
    const hasDrawBuffersExtension = code.search(/#extension.+GL_EXT_draw_buffers.+require/) !== -1;
    const regex = /#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;
    code = code.replace(regex, "");
    code = code.replace(/texture2D\s*\(/g, "texture(");
    if (isFragment) {
      const hasFragCoord = code.indexOf("gl_FragCoord") >= 0;
      const fragCoordCode = `
                glFragCoord_ = gl_FragCoord;
                if (yFactor_ == 1.) {
                    glFragCoord_.y = textureOutputHeight_ - glFragCoord_.y;
                }
            `;
      const injectCode = hasFragCoord ? "vec4 glFragCoord_;\n" : "";
      const hasOutput = code.search(/layout *\(location *= *0\) *out/g) !== -1;
      code = code.replace(/texture2DLodEXT\s*\(/g, "textureLod(");
      code = code.replace(/textureCubeLodEXT\s*\(/g, "textureLod(");
      code = code.replace(/textureCube\s*\(/g, "texture(");
      code = code.replace(/gl_FragDepthEXT/g, "gl_FragDepth");
      code = code.replace(/gl_FragColor/g, "glFragColor");
      code = code.replace(/gl_FragData/g, "glFragData");
      code = code.replace(/gl_FragCoord/g, "glFragCoord_");
      if (!this._fragmentIsGLES3) {
        code = code.replace(/void\s+?main\s*\(/g, (hasDrawBuffersExtension || hasOutput ? "" : "layout(location = 0) out vec4 glFragColor;\n") + "void main(");
      } else {
        const match = /^\s*out\s+\S+\s+\S+\s*;/gm.exec(code);
        if (match !== null) {
          code = code.substring(0, match.index) + "layout(location = 0) " + code.substring(match.index);
        }
      }
      code = code.replace(/dFdy/g, "(-yFactor_)*dFdy");
      code = code.replace("##INJECTCODE##", injectCode);
      if (hasFragCoord) {
        code = InjectStartingAndEndingCode(code, "void main", fragCoordCode);
      }
    } else {
      code = code.replace(/gl_InstanceID/g, "gl_InstanceIndex");
      code = code.replace(/gl_VertexID/g, "gl_VertexIndex");
      const hasMultiviewExtension = defines.indexOf("#define MULTIVIEW") !== -1;
      if (hasMultiviewExtension) {
        return "#extension GL_OVR_multiview2 : require\nlayout (num_views = 2) in;\n" + code;
      }
    }
    if (!isFragment) {
      const lastClosingCurly = code.lastIndexOf("}");
      code = code.substring(0, lastClosingCurly);
      code += "gl_Position.y *= yFactor_;\n";
      code += "}";
    }
    return code;
  }
  _applyTextureArrayProcessing(code, name3) {
    const regex = new RegExp(name3 + "\\s*\\[(.+)?\\]", "gm");
    let match = regex.exec(code);
    while (match !== null) {
      const index = match[1];
      let iindex = +index;
      if (this._preProcessors && isNaN(iindex)) {
        iindex = +this._preProcessors[index.trim()];
      }
      code = code.replace(match[0], name3 + iindex);
      match = regex.exec(code);
    }
    return code;
  }
  _generateLeftOverUBOCode(name3, uniformBufferDescription) {
    let ubo = `layout(set = ${uniformBufferDescription.binding.groupIndex}, binding = ${uniformBufferDescription.binding.bindingIndex}) uniform ${name3} {
    `;
    for (const leftOverUniform of this._webgpuProcessingContext.leftOverUniforms) {
      if (leftOverUniform.length > 0) {
        ubo += `    ${leftOverUniform.type} ${leftOverUniform.name}[${leftOverUniform.length}];
`;
      } else {
        ubo += `    ${leftOverUniform.type} ${leftOverUniform.name};
`;
      }
    }
    ubo += "};\n\n";
    return ubo;
  }
  finalizeShaders(vertexCode, fragmentCode) {
    for (let i = 0; i < this._textureArrayProcessing.length; ++i) {
      const name3 = this._textureArrayProcessing[i];
      vertexCode = this._applyTextureArrayProcessing(vertexCode, name3);
      fragmentCode = this._applyTextureArrayProcessing(fragmentCode, name3);
    }
    for (let i = 0; i < this._missingVaryings.length; ++i) {
      const decl = this._missingVaryings[i];
      if (decl && decl.length > 0) {
        fragmentCode = decl + "\n" + fragmentCode;
      }
    }
    const leftOverUBO = this._buildLeftOverUBO();
    vertexCode = leftOverUBO + vertexCode;
    fragmentCode = leftOverUBO + fragmentCode;
    this._collectBindingNames();
    this._preCreateBindGroupEntries();
    this._preProcessors = null;
    this._webgpuProcessingContext.vertexBufferKindToNumberOfComponents = {};
    return { vertexCode, fragmentCode };
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuShaderProcessorsWGSL.js
var builtInName_frag_depth = "fragmentOutputs.fragDepth";
var leftOverVarName = "uniforms";
var internalsVarName = "internals";
var gpuTextureViewDimensionByWebGPUTextureFunction = {
  texture_1d: "1d",
  texture_2d: "2d",
  texture_2d_array: "2d-array",
  texture_3d: "3d",
  texture_cube: "cube",
  texture_cube_array: "cube-array",
  texture_multisampled_2d: "2d",
  texture_depth_2d: "2d",
  texture_depth_2d_array: "2d-array",
  texture_depth_cube: "cube",
  texture_depth_cube_array: "cube-array",
  texture_depth_multisampled_2d: "2d",
  texture_storage_1d: "1d",
  texture_storage_2d: "2d",
  texture_storage_2d_array: "2d-array",
  texture_storage_3d: "3d",
  texture_external: null
};
var WebGPUShaderProcessorWGSL = class extends WebGPUShaderProcessor {
  constructor() {
    super(...arguments);
    this.shaderLanguage = 1;
    this.uniformRegexp = /uniform\s+(\w+)\s*:\s*(.+)\s*;/;
    this.textureRegexp = /var\s+(\w+)\s*:\s*((array<\s*)?(texture_\w+)\s*(<\s*(.+)\s*>)?\s*(,\s*\w+\s*>\s*)?);/;
    this.noPrecision = true;
    this.pureMode = false;
  }
  preProcessor(code, defines, preProcessors, isFragment, processingContext) {
    for (const key in preProcessors) {
      if (key === "__VERSION__") {
        continue;
      }
      const value = preProcessors[key];
      if (!isNaN(parseInt(value)) || !isNaN(parseFloat(value))) {
        code = `const ${key} = ${value};
` + code;
      }
    }
    return code;
  }
  _getArraySize(name3, uniformType, preProcessors) {
    let length = 0;
    const endArray = uniformType.lastIndexOf(">");
    if (uniformType.indexOf("array") >= 0 && endArray > 0) {
      let startArray = endArray;
      while (startArray > 0 && uniformType.charAt(startArray) !== " " && uniformType.charAt(startArray) !== ",") {
        startArray--;
      }
      const lengthInString = uniformType.substring(startArray + 1, endArray);
      length = +lengthInString;
      if (isNaN(length)) {
        length = +preProcessors[lengthInString.trim()];
      }
      while (startArray > 0 && (uniformType.charAt(startArray) === " " || uniformType.charAt(startArray) === ",")) {
        startArray--;
      }
      uniformType = uniformType.substring(uniformType.indexOf("<") + 1, startArray + 1);
    }
    return [name3, uniformType, length];
  }
  initializeShaders(processingContext) {
    this._webgpuProcessingContext = processingContext;
    this._attributesInputWGSL = [];
    this._attributesWGSL = [];
    this._attributesConversionCodeWGSL = [];
    this._hasNonFloatAttribute = false;
    this._varyingsWGSL = [];
    this._varyingNamesWGSL = [];
    this._stridedUniformArrays = [];
  }
  preProcessShaderCode(code) {
    const ubDeclaration = this.pureMode ? "" : `struct ${WebGPUShaderProcessor.InternalsUBOName} {
  yFactor_: f32,
  textureOutputHeight_: f32,
};
var<uniform> ${internalsVarName} : ${WebGPUShaderProcessor.InternalsUBOName};
`;
    const alreadyInjected = code.indexOf(ubDeclaration) !== -1;
    return alreadyInjected ? code : ubDeclaration + RemoveComments(code);
  }
  varyingCheck(varying) {
    const regex = /(flat|linear|perspective)?\s*(center|centroid|sample)?\s*\bvarying\b/;
    return regex.test(varying);
  }
  varyingProcessor(varying, isFragment, preProcessors) {
    const varyingRegex = /\s*(flat|linear|perspective)?\s*(center|centroid|sample)?\s*varying\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s*:\s*(.+)\s*;/gm;
    const match = varyingRegex.exec(varying);
    if (match !== null) {
      const interpolationType = match[1] ?? "perspective";
      const interpolationSampling = match[2] ?? "center";
      const varyingType = match[4];
      const name3 = match[3];
      const interpolation = interpolationType === "flat" ? `@interpolate(${interpolationType})` : `@interpolate(${interpolationType}, ${interpolationSampling})`;
      let location;
      if (isFragment) {
        location = this._webgpuProcessingContext.availableVaryings[name3];
        if (location === void 0) {
          Logger.Warn(`Invalid fragment shader: The varying named "${name3}" is not declared in the vertex shader! This declaration will be ignored.`);
        }
      } else {
        location = this._webgpuProcessingContext.getVaryingNextLocation(varyingType, this._getArraySize(name3, varyingType, preProcessors)[2]);
        this._webgpuProcessingContext.availableVaryings[name3] = location;
        this._varyingsWGSL.push(`  @location(${location}) ${interpolation} ${name3} : ${varyingType},`);
        this._varyingNamesWGSL.push(name3);
      }
      varying = "";
    }
    return varying;
  }
  attributeProcessor(attribute, preProcessors) {
    const attribRegex = /\s*attribute\s+(\S+)\s*:\s*(.+)\s*;/gm;
    const match = attribRegex.exec(attribute);
    if (match !== null) {
      const attributeType = match[2];
      const name3 = match[1];
      const location = this._webgpuProcessingContext.getAttributeNextLocation(attributeType, this._getArraySize(name3, attributeType, preProcessors)[2]);
      this._webgpuProcessingContext.availableAttributes[name3] = location;
      this._webgpuProcessingContext.orderedAttributes[location] = name3;
      const numComponents = this._webgpuProcessingContext.vertexBufferKindToNumberOfComponents[name3];
      if (numComponents !== void 0) {
        const newType = numComponents < 0 ? numComponents === -1 ? "i32" : "vec" + -numComponents + "<i32>" : numComponents === 1 ? "u32" : "vec" + numComponents + "<u32>";
        const newName = `_int_${name3}_`;
        this._attributesInputWGSL.push(`@location(${location}) ${newName} : ${newType},`);
        this._attributesWGSL.push(`${name3} : ${attributeType},`);
        this._attributesConversionCodeWGSL.push(`vertexInputs.${name3} = ${attributeType}(vertexInputs_.${newName});`);
        this._hasNonFloatAttribute = true;
      } else {
        this._attributesInputWGSL.push(`@location(${location}) ${name3} : ${attributeType},`);
        this._attributesWGSL.push(`${name3} : ${attributeType},`);
        this._attributesConversionCodeWGSL.push(`vertexInputs.${name3} = vertexInputs_.${name3};`);
      }
      attribute = "";
    }
    return attribute;
  }
  uniformProcessor(uniform, isFragment, preProcessors) {
    const match = this.uniformRegexp.exec(uniform);
    if (match !== null) {
      const uniformType = match[2];
      const name3 = match[1];
      this._addUniformToLeftOverUBO(name3, uniformType, preProcessors);
      uniform = "";
    }
    return uniform;
  }
  textureProcessor(texture, isFragment, preProcessors) {
    const match = this.textureRegexp.exec(texture);
    if (match !== null) {
      const name3 = match[1];
      const type = match[2];
      const isArrayOfTexture = !!match[3];
      const textureFunc = match[4];
      const isStorageTexture = textureFunc.indexOf("storage") > 0;
      const componentType = match[6];
      const storageTextureFormat = isStorageTexture ? componentType.substring(0, componentType.indexOf(",")).trim() : null;
      let arraySize = isArrayOfTexture ? this._getArraySize(name3, type, preProcessors)[2] : 0;
      let textureInfo = this._webgpuProcessingContext.availableTextures[name3];
      if (!textureInfo) {
        textureInfo = {
          isTextureArray: arraySize > 0,
          isStorageTexture,
          textures: [],
          sampleType: "float"
        };
        arraySize = arraySize || 1;
        for (let i = 0; i < arraySize; ++i) {
          textureInfo.textures.push(this._webgpuProcessingContext.getNextFreeUBOBinding());
        }
      } else {
        arraySize = textureInfo.textures.length;
      }
      this._webgpuProcessingContext.availableTextures[name3] = textureInfo;
      const isDepthTexture = textureFunc.indexOf("depth") > 0;
      const textureDimension = gpuTextureViewDimensionByWebGPUTextureFunction[textureFunc];
      const sampleType = isDepthTexture ? "depth" : componentType === "u32" ? "uint" : componentType === "i32" ? "sint" : "float";
      textureInfo.sampleType = sampleType;
      if (textureDimension === void 0) {
        throw `Can't get the texture dimension corresponding to the texture function "${textureFunc}"!`;
      }
      for (let i = 0; i < arraySize; ++i) {
        const { groupIndex, bindingIndex } = textureInfo.textures[i];
        if (i === 0) {
          texture = `@group(${groupIndex}) @binding(${bindingIndex}) ${texture}`;
        }
        this._addTextureBindingDescription(name3, textureInfo, i, textureDimension, storageTextureFormat, !isFragment);
      }
    }
    return texture;
  }
  // We need to process defines which are directly in the files themselves
  postProcessor(code) {
    const definePattern = /#define (.+?) (.+?)$/gm;
    let match;
    while ((match = definePattern.exec(code)) !== null) {
      code = code.replace(new RegExp(match[1], "g"), match[2]);
    }
    return code;
  }
  finalizeShaders(vertexCode, fragmentCode) {
    const fragCoordCode = fragmentCode.indexOf("fragmentInputs.position") >= 0 && !this.pureMode ? `
            if (internals.yFactor_ == 1.) {
                fragmentInputs.position.y = internals.textureOutputHeight_ - fragmentInputs.position.y;
            }
        ` : "";
    vertexCode = this._processSamplers(vertexCode, true);
    fragmentCode = this._processSamplers(fragmentCode, false);
    vertexCode = this._processCustomBuffers(vertexCode, true);
    fragmentCode = this._processCustomBuffers(fragmentCode, false);
    const leftOverUBO = this._buildLeftOverUBO();
    vertexCode = leftOverUBO + vertexCode;
    fragmentCode = leftOverUBO + fragmentCode;
    vertexCode = vertexCode.replace(/#define (\w+)\s+(\d+\.?\d*)/g, "const $1 = $2;");
    vertexCode = vertexCode.replace(/#define /g, "//#define ");
    vertexCode = this._processStridedUniformArrays(vertexCode);
    let vertexInputs = "struct VertexInputs {\n  @builtin(vertex_index) vertexIndex : u32,\n  @builtin(instance_index) instanceIndex : u32,\n";
    if (this._attributesInputWGSL.length > 0) {
      vertexInputs += this._attributesInputWGSL.join("\n");
    }
    vertexInputs += "\n};\nvar<private> vertexInputs" + (this._hasNonFloatAttribute ? "_" : "") + " : VertexInputs;\n";
    if (this._hasNonFloatAttribute) {
      vertexInputs += "struct VertexInputs_ {\n  vertexIndex : u32, instanceIndex : u32,\n";
      vertexInputs += this._attributesWGSL.join("\n");
      vertexInputs += "\n};\nvar<private> vertexInputs : VertexInputs_;\n";
    }
    let vertexOutputs = "struct FragmentInputs {\n  @builtin(position) position : vec4<f32>,\n";
    if (this._varyingsWGSL.length > 0) {
      vertexOutputs += this._varyingsWGSL.join("\n");
    }
    vertexOutputs += "\n};\nvar<private> vertexOutputs : FragmentInputs;\n";
    vertexCode = vertexInputs + vertexOutputs + vertexCode;
    let vertexMainStartingCode = `
  vertexInputs${this._hasNonFloatAttribute ? "_" : ""} = input;
`;
    if (this._hasNonFloatAttribute) {
      vertexMainStartingCode += "vertexInputs.vertexIndex = vertexInputs_.vertexIndex;\nvertexInputs.instanceIndex = vertexInputs_.instanceIndex;\n";
      vertexMainStartingCode += this._attributesConversionCodeWGSL.join("\n");
      vertexMainStartingCode += "\n";
    }
    const vertexMainEndingCode = this.pureMode ? `  return vertexOutputs;` : `  vertexOutputs.position.y = vertexOutputs.position.y * internals.yFactor_;
  return vertexOutputs;`;
    let needDiagnosticOff = vertexCode.indexOf(`#define DISABLE_UNIFORMITY_ANALYSIS`) !== -1;
    vertexCode = (needDiagnosticOff ? "diagnostic(off, derivative_uniformity);\n" : "") + "diagnostic(off, chromium.unreachable_code);\n" + InjectStartingAndEndingCode(vertexCode, "fn main", vertexMainStartingCode, vertexMainEndingCode);
    fragmentCode = fragmentCode.replace(/#define (\w+)\s+(\d+\.?\d*)/g, "const $1 = $2;");
    fragmentCode = fragmentCode.replace(/#define /g, "//#define ");
    fragmentCode = this._processStridedUniformArrays(fragmentCode);
    if (!this.pureMode) {
      fragmentCode = fragmentCode.replace(/dpdy/g, "(-internals.yFactor_)*dpdy");
    }
    let fragmentInputs = "struct FragmentInputs {\n  @builtin(position) position : vec4<f32>,\n  @builtin(front_facing) frontFacing : bool,\n";
    if (this._varyingsWGSL.length > 0) {
      fragmentInputs += this._varyingsWGSL.join("\n");
    }
    fragmentInputs += "\n};\nvar<private> fragmentInputs : FragmentInputs;\n";
    let fragmentOutputs = "struct FragmentOutputs {\n";
    const regexRoot = "fragmentOutputs\\.fragData";
    let match = fragmentCode.match(new RegExp(regexRoot + "0", "g"));
    let indexLocation = 0;
    if (match) {
      fragmentOutputs += ` @location(${indexLocation}) fragData0 : vec4<f32>,
`;
      indexLocation++;
      for (let index = 1; index < 8; index++) {
        match = fragmentCode.match(new RegExp(regexRoot + index, "g"));
        if (match) {
          fragmentOutputs += ` @location(${indexLocation}) fragData${indexLocation} : vec4<f32>,
`;
          indexLocation++;
        }
      }
      if (fragmentCode.indexOf("MRT_AND_COLOR") !== -1) {
        fragmentOutputs += `  @location(${indexLocation}) color : vec4<f32>,
`;
        indexLocation++;
      }
    }
    const regex = /oitDepthSampler/;
    match = fragmentCode.match(regex);
    if (match) {
      fragmentOutputs += ` @location(${indexLocation++}) depth : vec2<f32>,
`;
      fragmentOutputs += ` @location(${indexLocation++}) frontColor : vec4<f32>,
`;
      fragmentOutputs += ` @location(${indexLocation++}) backColor : vec4<f32>,
`;
    }
    if (indexLocation === 0) {
      fragmentOutputs += "  @location(0) color : vec4<f32>,\n";
      indexLocation++;
    }
    let hasFragDepth = false;
    let idx = 0;
    while (!hasFragDepth) {
      idx = fragmentCode.indexOf(builtInName_frag_depth, idx);
      if (idx < 0) {
        break;
      }
      const saveIndex = idx;
      hasFragDepth = true;
      while (idx > 1 && fragmentCode.charAt(idx) !== "\n") {
        if (fragmentCode.charAt(idx) === "/" && fragmentCode.charAt(idx - 1) === "/") {
          hasFragDepth = false;
          break;
        }
        idx--;
      }
      idx = saveIndex + builtInName_frag_depth.length;
    }
    if (hasFragDepth) {
      fragmentOutputs += "  @builtin(frag_depth) fragDepth: f32,\n";
    }
    fragmentOutputs += "};\nvar<private> fragmentOutputs : FragmentOutputs;\n";
    fragmentCode = fragmentInputs + fragmentOutputs + fragmentCode;
    const fragmentStartingCode = "  fragmentInputs = input;\n  " + fragCoordCode;
    const fragmentEndingCode = "  return fragmentOutputs;";
    needDiagnosticOff = fragmentCode.indexOf(`#define DISABLE_UNIFORMITY_ANALYSIS`) !== -1;
    fragmentCode = (needDiagnosticOff ? "diagnostic(off, derivative_uniformity);\n" : "") + "diagnostic(off, chromium.unreachable_code);\n" + InjectStartingAndEndingCode(fragmentCode, "fn main", fragmentStartingCode, fragmentEndingCode);
    this._collectBindingNames();
    this._preCreateBindGroupEntries();
    this._webgpuProcessingContext.vertexBufferKindToNumberOfComponents = {};
    return { vertexCode, fragmentCode };
  }
  _generateLeftOverUBOCode(name3, uniformBufferDescription) {
    let stridedArrays = "";
    let ubo = `struct ${name3} {
`;
    for (const leftOverUniform of this._webgpuProcessingContext.leftOverUniforms) {
      const type = leftOverUniform.type.replace(/^(.*?)(<.*>)?$/, "$1");
      const size = WebGPUShaderProcessor.UniformSizes[type];
      if (leftOverUniform.length > 0) {
        if (size <= 2) {
          const stridedArrayType = `${name3}_${this._stridedUniformArrays.length}_strided_arr`;
          stridedArrays += `struct ${stridedArrayType} {
                        @size(16)
                        el: ${type},
                    }`;
          this._stridedUniformArrays.push(leftOverUniform.name);
          ubo += ` @align(16) ${leftOverUniform.name} : array<${stridedArrayType}, ${leftOverUniform.length}>,
`;
        } else {
          ubo += ` ${leftOverUniform.name} : array<${leftOverUniform.type}, ${leftOverUniform.length}>,
`;
        }
      } else {
        ubo += `  ${leftOverUniform.name} : ${leftOverUniform.type},
`;
      }
    }
    ubo += "};\n";
    ubo = `${stridedArrays}
${ubo}`;
    ubo += `@group(${uniformBufferDescription.binding.groupIndex}) @binding(${uniformBufferDescription.binding.bindingIndex}) var<uniform> ${leftOverVarName} : ${name3};
`;
    return ubo;
  }
  _processSamplers(code, isVertex) {
    const samplerRegexp = /var\s+(\w+Sampler)\s*:\s*(sampler|sampler_comparison)\s*;/gm;
    while (true) {
      const match = samplerRegexp.exec(code);
      if (match === null) {
        break;
      }
      const name3 = match[1];
      const samplerType = match[2];
      const suffixLessLength = name3.length - `Sampler`.length;
      const textureName = name3.lastIndexOf(`Sampler`) === suffixLessLength ? name3.substring(0, suffixLessLength) : null;
      const samplerBindingType = samplerType === "sampler_comparison" ? "comparison" : "filtering";
      if (textureName) {
        const textureInfo = this._webgpuProcessingContext.availableTextures[textureName];
        if (textureInfo) {
          textureInfo.autoBindSampler = true;
        }
      }
      let samplerInfo = this._webgpuProcessingContext.availableSamplers[name3];
      if (!samplerInfo) {
        samplerInfo = {
          binding: this._webgpuProcessingContext.getNextFreeUBOBinding(),
          type: samplerBindingType
        };
        this._webgpuProcessingContext.availableSamplers[name3] = samplerInfo;
      }
      this._addSamplerBindingDescription(name3, samplerInfo, isVertex);
      const part1 = code.substring(0, match.index);
      const insertPart = `@group(${samplerInfo.binding.groupIndex}) @binding(${samplerInfo.binding.bindingIndex}) `;
      const part2 = code.substring(match.index);
      code = part1 + insertPart + part2;
      samplerRegexp.lastIndex += insertPart.length;
    }
    return code;
  }
  _processCustomBuffers(code, isVertex) {
    const instantiateBufferRegexp = /var<\s*(uniform|storage)\s*(,\s*(read|read_write)\s*)?>\s+(\S+)\s*:\s*(\S+)\s*;/gm;
    while (true) {
      const match = instantiateBufferRegexp.exec(code);
      if (match === null) {
        break;
      }
      const type = match[1];
      const decoration = match[3];
      let name3 = match[4];
      const structName = match[5];
      let bufferInfo = this._webgpuProcessingContext.availableBuffers[name3];
      if (!bufferInfo) {
        const knownUBO = type === "uniform" ? WebGPUShaderProcessingContext.KnownUBOs[structName] : null;
        let binding;
        if (knownUBO) {
          name3 = structName;
          binding = knownUBO.binding;
          if (binding.groupIndex === -1) {
            binding = this._webgpuProcessingContext.availableBuffers[name3]?.binding;
            if (!binding) {
              binding = this._webgpuProcessingContext.getNextFreeUBOBinding();
            }
          }
        } else {
          binding = this._webgpuProcessingContext.getNextFreeUBOBinding();
        }
        bufferInfo = { binding };
        this._webgpuProcessingContext.availableBuffers[name3] = bufferInfo;
      }
      this._addBufferBindingDescription(name3, this._webgpuProcessingContext.availableBuffers[name3], decoration === "read_write" ? "storage" : type === "storage" ? "read-only-storage" : "uniform", isVertex);
      const groupIndex = bufferInfo.binding.groupIndex;
      const bindingIndex = bufferInfo.binding.bindingIndex;
      const part1 = code.substring(0, match.index);
      const insertPart = `@group(${groupIndex}) @binding(${bindingIndex}) `;
      const part2 = code.substring(match.index);
      code = part1 + insertPart + part2;
      instantiateBufferRegexp.lastIndex += insertPart.length;
    }
    return code;
  }
  _processStridedUniformArrays(code) {
    for (const uniformArrayName of this._stridedUniformArrays) {
      code = code.replace(new RegExp(`${uniformArrayName}\\s*\\[(.*?)\\]`, "g"), `${uniformArrayName}[$1].el`);
    }
    return code;
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuHardwareTexture.js
var WebGPUHardwareTexture = class {
  get underlyingResource() {
    return this._webgpuTexture;
  }
  getMSAATexture(index) {
    return this._webgpuMSAATexture?.[index] ?? null;
  }
  setMSAATexture(texture, index) {
    if (!this._webgpuMSAATexture) {
      this._webgpuMSAATexture = [];
    }
    this._webgpuMSAATexture[index] = texture;
  }
  releaseMSAATexture(index) {
    if (this._webgpuMSAATexture) {
      if (index !== void 0) {
        this._engine._textureHelper.releaseTexture(this._webgpuMSAATexture[index]);
        delete this._webgpuMSAATexture[index];
      } else {
        for (const texture of this._webgpuMSAATexture) {
          this._engine._textureHelper.releaseTexture(texture);
        }
        this._webgpuMSAATexture = null;
      }
    }
  }
  constructor(_engine, existingTexture = null) {
    this._engine = _engine;
    this._originalFormatIsRGB = false;
    this.format = "rgba8unorm";
    this.textureUsages = 0;
    this.textureAdditionalUsages = 0;
    this._webgpuTexture = existingTexture;
    this._webgpuMSAATexture = null;
    this.view = null;
    this.viewForWriting = null;
  }
  set(hardwareTexture) {
    this._webgpuTexture = hardwareTexture;
  }
  setUsage(_textureSource, generateMipMaps, is2DArray, isCube, is3D, width, height, depth) {
    let viewDimension = "2d";
    let arrayLayerCount = 1;
    if (isCube) {
      viewDimension = is2DArray ? "cube-array" : "cube";
      arrayLayerCount = 6 * (depth || 1);
    } else if (is3D) {
      viewDimension = "3d";
      arrayLayerCount = 1;
    } else if (is2DArray) {
      viewDimension = "2d-array";
      arrayLayerCount = depth;
    }
    const format = WebGPUTextureHelper.GetDepthFormatOnly(this.format);
    const aspect = WebGPUTextureHelper.HasDepthAndStencilAspects(this.format) ? "depth-only" : "all";
    this.createView({
      label: `TextureView${is3D ? "3D" : isCube ? "Cube" : "2D"}${is2DArray ? "_Array" + arrayLayerCount : ""}_${width}x${height}_${generateMipMaps ? "wmips" : "womips"}_${this.format}_${viewDimension}`,
      format,
      dimension: viewDimension,
      mipLevelCount: generateMipMaps ? ILog2(Math.max(width, height)) + 1 : 1,
      baseArrayLayer: 0,
      baseMipLevel: 0,
      arrayLayerCount,
      aspect
    });
  }
  createView(descriptor, createViewForWriting = false) {
    this.view = this._webgpuTexture.createView(descriptor);
    if (createViewForWriting && descriptor) {
      const saveNumMipMaps = descriptor.mipLevelCount;
      descriptor.mipLevelCount = 1;
      this.viewForWriting = this._webgpuTexture.createView(descriptor);
      descriptor.mipLevelCount = saveNumMipMaps;
    }
  }
  reset() {
    this._webgpuTexture = null;
    this._webgpuMSAATexture = null;
    this.view = null;
    this.viewForWriting = null;
  }
  release() {
    this._webgpuTexture?.destroy();
    this.releaseMSAATexture();
    this._copyInvertYTempTexture?.destroy();
    this.reset();
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuTextureManager.js
var mipmapVertexSource = `
    const pos = array<vec2<f32>, 4>( vec2f(-1.0f, 1.0f),  vec2f(1.0f, 1.0f),  vec2f(-1.0f, -1.0f),  vec2f(1.0f, -1.0f));
    const tex = array<vec2<f32>, 4>( vec2f(0.0f, 0.0f),  vec2f(1.0f, 0.0f),  vec2f(0.0f, 1.0f),  vec2f(1.0f, 1.0f));

    varying vTex: vec2f;

    @vertex
    fn main(input : VertexInputs) -> FragmentInputs {
        vertexOutputs.vTex = tex[input.vertexIndex];
        vertexOutputs.position = vec4f(pos[input.vertexIndex], 0.0, 1.0);
    }
    `;
var mipmapFragmentSource = `
    var imgSampler: sampler;
    var img: texture_2d<f32>;

    varying vTex: vec2f;

    @fragment
    fn main(input: FragmentInputs) -> FragmentOutputs {
        fragmentOutputs.color = textureSample(img, imgSampler, input.vTex);
    }
    `;
var invertYPreMultiplyAlphaVertexSource = `
    const pos = array<vec2<f32>, 4>( vec2f(-1.0f, 1.0f),  vec2f(1.0f, 1.0f),  vec2f(-1.0f, -1.0f),  vec2f(1.0f, -1.0f));
    const tex = array<vec2<f32>, 4>( vec2f(0.0f, 0.0f),  vec2f(1.0f, 0.0f),  vec2f(0.0f, 1.0f),  vec2f(1.0f, 1.0f));

    var img: texture_2d<f32>;

    #ifdef INVERTY
        varying vTextureSize: vec2f;
    #endif

    @vertex
    fn main(input : VertexInputs) -> FragmentInputs {
        #ifdef INVERTY
            vertexOutputs.vTextureSize = vec2f(textureDimensions(img, 0));
        #endif
        vertexOutputs.position =  vec4f(pos[input.vertexIndex], 0.0, 1.0);
    }
    `;
var invertYPreMultiplyAlphaFragmentSource = `
    var img: texture_2d<f32>;

    #ifdef INVERTY
        varying vTextureSize: vec2f;
    #endif

    @fragment
    fn main(input: FragmentInputs) -> FragmentOutputs {
    #ifdef INVERTY
        var color: vec4f = textureLoad(img, vec2i(i32(input.position.x), i32(input.vTextureSize.y - input.position.y)), 0);
    #else
        var color: vec4f = textureLoad(img, vec2i(input.position.xy), 0);
    #endif
    #ifdef PREMULTIPLYALPHA
        color = vec4f(color.rgb * color.a, color.a);
    #endif
        fragmentOutputs.color = color;
    }
    `;
var invertYPreMultiplyAlphaWithOfstVertexSource = invertYPreMultiplyAlphaVertexSource;
var invertYPreMultiplyAlphaWithOfstFragmentSource = `
    var img: texture_2d<f32>;
    uniform ofstX: f32;
    uniform ofstY: f32;
    uniform width: f32;
    uniform height: f32;

    #ifdef INVERTY
        varying vTextureSize: vec2f;
    #endif

    @fragment
    fn main(input: FragmentInputs) -> FragmentOutputs {
        if (input.position.x < uniforms.ofstX || input.position.x >= uniforms.ofstX + uniforms.width) {
            discard;
        }
        if (input.position.y < uniforms.ofstY || input.position.y >= uniforms.ofstY + uniforms.height) {
            discard;
        }
    #ifdef INVERTY
        var color: vec4f = textureLoad(img, vec2i(i32(input.position.x), i32(uniforms.ofstY + uniforms.height - (input.position.y - uniforms.ofstY))), 0);
    #else
        var color: vec4f = textureLoad(img, vec2i(input.position.xy), 0);
    #endif
    #ifdef PREMULTIPLYALPHA
        color = vec4f(color.rgb * color.a, color.a);
    #endif
        fragmentOutputs.color = color;
    }
    `;
var clearVertexSource = `
    const pos = array<vec2<f32>, 4>( vec2f(-1.0f, 1.0f),  vec2f(1.0f, 1.0f),  vec2f(-1.0f, -1.0f),  vec2f(1.0f, -1.0f));

    @vertex
    fn main(input : VertexInputs) -> FragmentInputs {
        vertexOutputs.position =  vec4f(pos[input.vertexIndex], 0.0, 1.0);
    }
    `;
var clearFragmentSource = `
    uniform color: vec4f;


    @fragment
    fn main(input: FragmentInputs) -> FragmentOutputs {
        fragmentOutputs.color = uniforms.color;
    }
    `;
var copyVideoToTextureVertexSource = `
    struct VertexOutput {
        @builtin(position) Position : vec4<f32>,
        @location(0) fragUV : vec2<f32>
    }

    @vertex
    fn main(
        @builtin(vertex_index) VertexIndex : u32
    ) -> VertexOutput {
        var pos = array<vec2<f32>, 4>(
            vec2(-1.0,  1.0),
            vec2( 1.0,  1.0),
            vec2(-1.0, -1.0),
            vec2( 1.0, -1.0)
        );
        var tex = array<vec2<f32>, 4>(
            vec2(0.0, 0.0),
            vec2(1.0, 0.0),
            vec2(0.0, 1.0),
            vec2(1.0, 1.0)
        );

        var output: VertexOutput;

        output.Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);
        output.fragUV = tex[VertexIndex];

        return output;
    }
    `;
var copyVideoToTextureFragmentSource = `
    @group(0) @binding(0) var videoSampler: sampler;
    @group(0) @binding(1) var videoTexture: texture_external;

    @fragment
    fn main(
        @location(0) fragUV: vec2<f32>
    ) -> @location(0) vec4<f32> {
        return textureSampleBaseClampToEdge(videoTexture, videoSampler, fragUV);
    }
    `;
var copyVideoToTextureInvertYFragmentSource = `
    @group(0) @binding(0) var videoSampler: sampler;
    @group(0) @binding(1) var videoTexture: texture_external;

    @fragment
    fn main(
        @location(0) fragUV: vec2<f32>
    ) -> @location(0) vec4<f32> {
        return textureSampleBaseClampToEdge(videoTexture, videoSampler, vec2<f32>(fragUV.x, 1.0 - fragUV.y));
    }
    `;
var PipelineType;
(function(PipelineType2) {
  PipelineType2[PipelineType2["MipMap"] = 0] = "MipMap";
  PipelineType2[PipelineType2["InvertYPremultiplyAlpha"] = 1] = "InvertYPremultiplyAlpha";
  PipelineType2[PipelineType2["Clear"] = 2] = "Clear";
  PipelineType2[PipelineType2["InvertYPremultiplyAlphaWithOfst"] = 3] = "InvertYPremultiplyAlphaWithOfst";
})(PipelineType || (PipelineType = {}));
var VideoPipelineType;
(function(VideoPipelineType2) {
  VideoPipelineType2[VideoPipelineType2["DontInvertY"] = 0] = "DontInvertY";
  VideoPipelineType2[VideoPipelineType2["InvertY"] = 1] = "InvertY";
})(VideoPipelineType || (VideoPipelineType = {}));
var shadersForPipelineType = [
  { vertex: mipmapVertexSource, fragment: mipmapFragmentSource },
  { vertex: invertYPreMultiplyAlphaVertexSource, fragment: invertYPreMultiplyAlphaFragmentSource },
  { vertex: clearVertexSource, fragment: clearFragmentSource },
  { vertex: invertYPreMultiplyAlphaWithOfstVertexSource, fragment: invertYPreMultiplyAlphaWithOfstFragmentSource }
];
var renderableTextureFormatToIndex = {
  "": 0,
  r8unorm: 1,
  r8uint: 2,
  r8sint: 3,
  r16uint: 4,
  r16sint: 5,
  r16float: 6,
  rg8unorm: 7,
  rg8uint: 8,
  rg8sint: 9,
  r32uint: 10,
  r32sint: 11,
  r32float: 12,
  rg16uint: 13,
  rg16sint: 14,
  rg16float: 15,
  rgba8unorm: 16,
  "rgba8unorm-srgb": 17,
  rgba8uint: 18,
  rgba8sint: 19,
  bgra8unorm: 20,
  "bgra8unorm-srgb": 21,
  rgb10a2uint: 22,
  rgb10a2unorm: 23,
  /* rg11b10ufloat: this entry is dynamically added if the "RG11B10UFloatRenderable" extension is supported */
  rg32uint: 24,
  rg32sint: 25,
  rg32float: 26,
  rgba16uint: 27,
  rgba16sint: 28,
  rgba16float: 29,
  rgba32uint: 30,
  rgba32sint: 31,
  rgba32float: 32,
  stencil8: 33,
  depth16unorm: 34,
  depth24plus: 35,
  "depth24plus-stencil8": 36,
  depth32float: 37,
  "depth32float-stencil8": 38,
  r16unorm: 39,
  rg16unorm: 40,
  rgba16unorm: 41,
  r16snorm: 42,
  rg16snorm: 43,
  rgba16snorm: 44
};
var WebGPUTextureManager = class {
  //------------------------------------------------------------------------------
  //                         Initialization / Helpers
  //------------------------------------------------------------------------------
  constructor(engine, device, bufferManager, enabledExtensions) {
    this._pipelines = {};
    this._compiledShaders = [];
    this._videoPipelines = {};
    this._videoCompiledShaders = [];
    this._deferredReleaseTextures = [];
    this._engine = engine;
    this._device = device;
    this._bufferManager = bufferManager;
    if (enabledExtensions.indexOf(
      "rg11b10ufloat-renderable"
      /* WebGPUConstants.FeatureName.RG11B10UFloatRenderable */
    ) !== -1) {
      const keys = Object.keys(renderableTextureFormatToIndex);
      renderableTextureFormatToIndex[
        "rg11b10ufloat"
        /* WebGPUConstants.TextureFormat.RG11B10UFloat */
      ] = renderableTextureFormatToIndex[keys[keys.length - 1]] + 1;
    }
    this._mipmapSampler = device.createSampler({
      minFilter: "linear"
      /* WebGPUConstants.FilterMode.Linear */
    });
    this._videoSampler = device.createSampler({
      minFilter: "linear"
      /* WebGPUConstants.FilterMode.Linear */
    });
    this._ubCopyWithOfst = this._bufferManager.createBuffer(4 * 4, BufferUsage.Uniform | BufferUsage.CopyDst, "UBCopyWithOffset").underlyingResource;
    this._getPipeline(
      "rgba8unorm"
      /* WebGPUConstants.TextureFormat.RGBA8Unorm */
    );
    this._getVideoPipeline(
      "rgba8unorm"
      /* WebGPUConstants.TextureFormat.RGBA8Unorm */
    );
  }
  _getPipeline(format, type = PipelineType.MipMap, params) {
    const index = type === PipelineType.MipMap ? 1 << 0 : type === PipelineType.InvertYPremultiplyAlpha ? ((params.invertY ? 1 : 0) << 1) + ((params.premultiplyAlpha ? 1 : 0) << 2) : type === PipelineType.Clear ? 1 << 3 : type === PipelineType.InvertYPremultiplyAlphaWithOfst ? ((params.invertY ? 1 : 0) << 4) + ((params.premultiplyAlpha ? 1 : 0) << 5) : 0;
    if (!this._pipelines[format]) {
      this._pipelines[format] = [];
    }
    let pipelineAndBGL = this._pipelines[format][index];
    if (!pipelineAndBGL) {
      let defines = "";
      if (type === PipelineType.InvertYPremultiplyAlpha || type === PipelineType.InvertYPremultiplyAlphaWithOfst) {
        if (params.invertY) {
          defines += "#define INVERTY\n";
        }
        if (params.premultiplyAlpha) {
          defines += "#define PREMULTIPLYALPHA\n";
        }
      }
      let modules = this._compiledShaders[index];
      if (!modules) {
        let vertexCode = shadersForPipelineType[type].vertex;
        let fragmentCode = shadersForPipelineType[type].fragment;
        const processorOptions = {
          defines: defines.split("\n"),
          indexParameters: null,
          isFragment: false,
          shouldUseHighPrecisionShader: true,
          processor: this._engine._getShaderProcessor(
            1
            /* ShaderLanguage.WGSL */
          ),
          supportsUniformBuffers: true,
          shadersRepository: "",
          includesShadersStore: {},
          version: (this._engine.version * 100).toString(),
          platformName: this._engine.shaderPlatformName,
          processingContext: this._engine._getShaderProcessingContext(1, true),
          isNDCHalfZRange: this._engine.isNDCHalfZRange,
          useReverseDepthBuffer: this._engine.useReverseDepthBuffer
        };
        Initialize(processorOptions);
        processorOptions.processor.pureMode = true;
        Process(vertexCode, processorOptions, (migratedVertexCode) => {
          vertexCode = migratedVertexCode;
        }, this._engine);
        processorOptions.isFragment = true;
        Process(fragmentCode, processorOptions, (migratedFragmentCode) => {
          fragmentCode = migratedFragmentCode;
        }, this._engine);
        const final = Finalize(vertexCode, fragmentCode, processorOptions);
        processorOptions.processor.pureMode = false;
        const vertexModule = this._device.createShaderModule({
          label: `BabylonWebGPUDevice${this._engine.uniqueId}_InternalVertexShader_${index}`,
          code: final.vertexCode
        });
        const fragmentModule = this._device.createShaderModule({
          label: `BabylonWebGPUDevice${this._engine.uniqueId}_InternalFragmentShader_${index}`,
          code: final.fragmentCode
        });
        modules = this._compiledShaders[index] = [vertexModule, fragmentModule];
      }
      const pipeline = this._device.createRenderPipeline({
        label: `BabylonWebGPUDevice${this._engine.uniqueId}_InternalPipeline_${format}_${index}`,
        layout: "auto",
        vertex: {
          module: modules[0],
          entryPoint: "main"
        },
        fragment: {
          module: modules[1],
          entryPoint: "main",
          targets: [
            {
              format
            }
          ]
        },
        primitive: {
          topology: "triangle-strip",
          stripIndexFormat: "uint16"
        }
      });
      pipelineAndBGL = this._pipelines[format][index] = [pipeline, pipeline.getBindGroupLayout(0)];
    }
    return pipelineAndBGL;
  }
  _getVideoPipeline(format, type = VideoPipelineType.DontInvertY) {
    const index = type === VideoPipelineType.InvertY ? 1 << 0 : 0;
    if (!this._videoPipelines[format]) {
      this._videoPipelines[format] = [];
    }
    let pipelineAndBGL = this._videoPipelines[format][index];
    if (!pipelineAndBGL) {
      let modules = this._videoCompiledShaders[index];
      if (!modules) {
        const vertexModule = this._device.createShaderModule({
          code: copyVideoToTextureVertexSource,
          label: `BabylonWebGPUDevice${this._engine.uniqueId}_CopyVideoToTexture_VertexShader`
        });
        const fragmentModule = this._device.createShaderModule({
          code: index === 0 ? copyVideoToTextureFragmentSource : copyVideoToTextureInvertYFragmentSource,
          label: `BabylonWebGPUDevice${this._engine.uniqueId}_CopyVideoToTexture_FragmentShader_${index === 0 ? "DontInvertY" : "InvertY"}`
        });
        modules = this._videoCompiledShaders[index] = [vertexModule, fragmentModule];
      }
      const pipeline = this._device.createRenderPipeline({
        label: `BabylonWebGPUDevice${this._engine.uniqueId}_InternalVideoPipeline_${format}_${index === 0 ? "DontInvertY" : "InvertY"}`,
        layout: "auto",
        vertex: {
          module: modules[0],
          entryPoint: "main"
        },
        fragment: {
          module: modules[1],
          entryPoint: "main",
          targets: [
            {
              format
            }
          ]
        },
        primitive: {
          topology: "triangle-strip",
          stripIndexFormat: "uint16"
        }
      });
      pipelineAndBGL = this._videoPipelines[format][index] = [pipeline, pipeline.getBindGroupLayout(0)];
    }
    return pipelineAndBGL;
  }
  setCommandEncoder(encoder) {
    this._commandEncoderForCreation = encoder;
  }
  copyVideoToTexture(video, texture, format, invertY = false, commandEncoder) {
    const useOwnCommandEncoder = commandEncoder === void 0;
    const [pipeline, bindGroupLayout] = this._getVideoPipeline(format, invertY ? VideoPipelineType.InvertY : VideoPipelineType.DontInvertY);
    if (useOwnCommandEncoder) {
      commandEncoder = this._device.createCommandEncoder({});
    }
    commandEncoder.pushDebugGroup?.(`copy video to texture - invertY=${invertY}`);
    const webgpuHardwareTexture = texture._hardwareTexture;
    const renderPassDescriptor = {
      label: `BabylonWebGPUDevice${this._engine.uniqueId}_copyVideoToTexture_${format}_${invertY ? "InvertY" : "DontInvertY"}${texture.label ? "_" + texture.label : ""}`,
      colorAttachments: [
        {
          view: webgpuHardwareTexture.underlyingResource.createView({
            format,
            dimension: "2d",
            mipLevelCount: 1,
            baseArrayLayer: 0,
            baseMipLevel: 0,
            arrayLayerCount: 1,
            aspect: "all"
          }),
          loadOp: "load",
          storeOp: "store"
        }
      ]
    };
    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
    const descriptor = {
      layout: bindGroupLayout,
      entries: [
        {
          binding: 0,
          resource: this._videoSampler
        },
        {
          binding: 1,
          resource: this._device.importExternalTexture({
            source: video.underlyingResource
          })
        }
      ]
    };
    const bindGroup = this._device.createBindGroup(descriptor);
    passEncoder.setPipeline(pipeline);
    passEncoder.setBindGroup(0, bindGroup);
    passEncoder.draw(4, 1, 0, 0);
    passEncoder.end();
    commandEncoder.popDebugGroup?.();
    if (useOwnCommandEncoder) {
      this._device.queue.submit([commandEncoder.finish()]);
      commandEncoder = null;
    }
  }
  invertYPreMultiplyAlpha(gpuOrHdwTexture, width, height, format, invertY = false, premultiplyAlpha = false, faceIndex = 0, mipLevel = 0, layers = 1, ofstX = 0, ofstY = 0, rectWidth = 0, rectHeight = 0, commandEncoder, allowGPUOptimization) {
    const useRect = rectWidth !== 0;
    const useOwnCommandEncoder = commandEncoder === void 0;
    const [pipeline, bindGroupLayout] = this._getPipeline(format, useRect ? PipelineType.InvertYPremultiplyAlphaWithOfst : PipelineType.InvertYPremultiplyAlpha, {
      invertY,
      premultiplyAlpha
    });
    faceIndex = Math.max(faceIndex, 0);
    if (useOwnCommandEncoder) {
      commandEncoder = this._device.createCommandEncoder({});
    }
    commandEncoder.pushDebugGroup?.(`internal process texture - invertY=${invertY} premultiplyAlpha=${premultiplyAlpha}`);
    let gpuTexture;
    if (WebGPUTextureHelper.IsHardwareTexture(gpuOrHdwTexture)) {
      gpuTexture = gpuOrHdwTexture.underlyingResource;
      if (!(invertY && !premultiplyAlpha && layers === 1 && faceIndex === 0)) {
        gpuOrHdwTexture = void 0;
      }
    } else {
      gpuTexture = gpuOrHdwTexture;
      gpuOrHdwTexture = void 0;
    }
    if (!gpuTexture) {
      return;
    }
    if (useRect) {
      this._bufferManager.setRawData(this._ubCopyWithOfst, 0, new Float32Array([ofstX, ofstY, rectWidth, rectHeight]), 0, 4 * 4);
    }
    const webgpuHardwareTexture = gpuOrHdwTexture;
    const outputTexture = webgpuHardwareTexture?._copyInvertYTempTexture ?? this.createTexture({ width, height, layers: 1 }, false, false, false, false, false, format, 1, commandEncoder, 1 | 16 | 4, void 0, "TempTextureForCopyWithInvertY");
    const renderPassDescriptor = webgpuHardwareTexture?._copyInvertYRenderPassDescr ?? {
      label: `BabylonWebGPUDevice${this._engine.uniqueId}_invertYPreMultiplyAlpha_${format}_${invertY ? "InvertY" : "DontInvertY"}_${premultiplyAlpha ? "PremultiplyAlpha" : "DontPremultiplyAlpha"}`,
      colorAttachments: [
        {
          view: outputTexture.createView({
            format,
            dimension: "2d",
            baseMipLevel: 0,
            mipLevelCount: 1,
            arrayLayerCount: 1,
            baseArrayLayer: 0
          }),
          loadOp: "load",
          storeOp: "store"
        }
      ]
    };
    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
    let bindGroup = useRect ? webgpuHardwareTexture?._copyInvertYBindGroupWithOfst : webgpuHardwareTexture?._copyInvertYBindGroup;
    if (!bindGroup) {
      const descriptor = {
        layout: bindGroupLayout,
        entries: [
          {
            binding: 0,
            resource: gpuTexture.createView({
              format,
              dimension: "2d",
              baseMipLevel: mipLevel,
              mipLevelCount: 1,
              arrayLayerCount: layers,
              baseArrayLayer: faceIndex
            })
          }
        ]
      };
      if (useRect) {
        descriptor.entries.push({
          binding: 1,
          resource: {
            buffer: this._ubCopyWithOfst
          }
        });
      }
      bindGroup = this._device.createBindGroup(descriptor);
    }
    passEncoder.setPipeline(pipeline);
    passEncoder.setBindGroup(0, bindGroup);
    passEncoder.draw(4, 1, 0, 0);
    passEncoder.end();
    commandEncoder.copyTextureToTexture({
      texture: outputTexture
    }, {
      texture: gpuTexture,
      mipLevel,
      origin: {
        x: 0,
        y: 0,
        z: faceIndex
      }
    }, {
      width: rectWidth || width,
      height: rectHeight || height,
      depthOrArrayLayers: 1
    });
    if (webgpuHardwareTexture) {
      webgpuHardwareTexture._copyInvertYTempTexture = outputTexture;
      webgpuHardwareTexture._copyInvertYRenderPassDescr = renderPassDescriptor;
      if (useRect) {
        webgpuHardwareTexture._copyInvertYBindGroupWithOfst = bindGroup;
      } else {
        webgpuHardwareTexture._copyInvertYBindGroup = bindGroup;
      }
    } else {
      this._deferredReleaseTextures.push([outputTexture, null]);
    }
    commandEncoder.popDebugGroup?.();
    if (useOwnCommandEncoder) {
      this._device.queue.submit([commandEncoder.finish()]);
      commandEncoder = null;
    }
  }
  //------------------------------------------------------------------------------
  //                               Creation
  //------------------------------------------------------------------------------
  createTexture(imageBitmap, hasMipmaps = false, generateMipmaps = false, invertY = false, premultiplyAlpha = false, is3D = false, format = "rgba8unorm", sampleCount = 1, commandEncoder, usage = -1, additionalUsages = 0, label) {
    sampleCount = WebGPUTextureHelper.GetSample(sampleCount);
    const layerCount = imageBitmap.layers || 1;
    const textureSize = {
      width: imageBitmap.width,
      height: imageBitmap.height,
      depthOrArrayLayers: layerCount
    };
    const renderAttachmentFlag = renderableTextureFormatToIndex[format] ? 16 : 0;
    const isCompressedFormat = WebGPUTextureHelper.IsCompressedFormat(format);
    const mipLevelCount = hasMipmaps ? WebGPUTextureHelper.ComputeNumMipmapLevels(imageBitmap.width, imageBitmap.height) : 1;
    const usages = usage >= 0 ? usage : 1 | 2 | 4;
    additionalUsages |= hasMipmaps && !isCompressedFormat ? 1 | renderAttachmentFlag : 0;
    if (!isCompressedFormat && !is3D) {
      additionalUsages |= renderAttachmentFlag | 2;
    }
    const gpuTexture = this._device.createTexture({
      label: `BabylonWebGPUDevice${this._engine.uniqueId}_Texture${is3D ? "3D" : "2D"}_${label ? label + "_" : ""}${textureSize.width}x${textureSize.height}x${textureSize.depthOrArrayLayers}_${hasMipmaps ? "wmips" : "womips"}_${format}_samples${sampleCount}`,
      size: textureSize,
      dimension: is3D ? "3d" : "2d",
      format,
      usage: usages | additionalUsages,
      sampleCount,
      mipLevelCount
    });
    if (WebGPUTextureHelper.IsImageBitmap(imageBitmap)) {
      this.updateTexture(imageBitmap, gpuTexture, imageBitmap.width, imageBitmap.height, layerCount, format, 0, 0, invertY, premultiplyAlpha, 0, 0);
      if (hasMipmaps && generateMipmaps) {
        this.generateMipmaps(gpuTexture, format, mipLevelCount, 0, is3D, commandEncoder);
      }
    }
    return gpuTexture;
  }
  createCubeTexture(imageBitmaps, hasMipmaps = false, generateMipmaps = false, invertY = false, premultiplyAlpha = false, format = "rgba8unorm", sampleCount = 1, commandEncoder, usage = -1, additionalUsages = 0, label) {
    sampleCount = WebGPUTextureHelper.GetSample(sampleCount);
    const width = WebGPUTextureHelper.IsImageBitmapArray(imageBitmaps) ? imageBitmaps[0].width : imageBitmaps.width;
    const height = WebGPUTextureHelper.IsImageBitmapArray(imageBitmaps) ? imageBitmaps[0].height : imageBitmaps.height;
    const renderAttachmentFlag = renderableTextureFormatToIndex[format] ? 16 : 0;
    const isCompressedFormat = WebGPUTextureHelper.IsCompressedFormat(format);
    const mipLevelCount = hasMipmaps ? WebGPUTextureHelper.ComputeNumMipmapLevels(width, height) : 1;
    const usages = usage >= 0 ? usage : 1 | 2 | 4;
    additionalUsages |= hasMipmaps && !isCompressedFormat ? 1 | renderAttachmentFlag : 0;
    if (!isCompressedFormat) {
      additionalUsages |= renderAttachmentFlag | 2;
    }
    const gpuTexture = this._device.createTexture({
      label: `BabylonWebGPUDevice${this._engine.uniqueId}_TextureCube_${label ? label + "_" : ""}${width}x${height}x6_${hasMipmaps ? "wmips" : "womips"}_${format}_samples${sampleCount}`,
      size: {
        width,
        height,
        depthOrArrayLayers: 6
      },
      dimension: "2d",
      format,
      usage: usages | additionalUsages,
      sampleCount,
      mipLevelCount
    });
    if (WebGPUTextureHelper.IsImageBitmapArray(imageBitmaps)) {
      this.updateCubeTextures(imageBitmaps, gpuTexture, width, height, format, invertY, premultiplyAlpha, 0, 0);
      if (hasMipmaps && generateMipmaps) {
        this.generateCubeMipmaps(gpuTexture, format, mipLevelCount, commandEncoder);
      }
    }
    return gpuTexture;
  }
  generateCubeMipmaps(gpuTexture, format, mipLevelCount, commandEncoder) {
    const useOwnCommandEncoder = commandEncoder === void 0;
    if (useOwnCommandEncoder) {
      commandEncoder = this._device.createCommandEncoder({});
    }
    commandEncoder.pushDebugGroup?.(`create cube mipmaps - ${mipLevelCount} levels`);
    for (let f = 0; f < 6; ++f) {
      this.generateMipmaps(gpuTexture, format, mipLevelCount, f, false, commandEncoder);
    }
    commandEncoder.popDebugGroup?.();
    if (useOwnCommandEncoder) {
      this._device.queue.submit([commandEncoder.finish()]);
      commandEncoder = null;
    }
  }
  generateMipmaps(gpuOrHdwTexture, format, mipLevelCount, faceIndex = 0, is3D = false, commandEncoder) {
    const useOwnCommandEncoder = commandEncoder === void 0;
    const [pipeline, bindGroupLayout] = this._getPipeline(format);
    faceIndex = Math.max(faceIndex, 0);
    if (useOwnCommandEncoder) {
      commandEncoder = this._device.createCommandEncoder({});
    }
    commandEncoder.pushDebugGroup?.(`create mipmaps for face #${faceIndex} - ${mipLevelCount} levels`);
    let gpuTexture;
    if (WebGPUTextureHelper.IsHardwareTexture(gpuOrHdwTexture)) {
      gpuTexture = gpuOrHdwTexture.underlyingResource;
      gpuOrHdwTexture._mipmapGenRenderPassDescr = gpuOrHdwTexture._mipmapGenRenderPassDescr || [];
      gpuOrHdwTexture._mipmapGenBindGroup = gpuOrHdwTexture._mipmapGenBindGroup || [];
    } else {
      gpuTexture = gpuOrHdwTexture;
      gpuOrHdwTexture = void 0;
    }
    if (!gpuTexture) {
      return;
    }
    const webgpuHardwareTexture = gpuOrHdwTexture;
    for (let i = 1; i < mipLevelCount; ++i) {
      const renderPassDescriptor = webgpuHardwareTexture?._mipmapGenRenderPassDescr[faceIndex]?.[i - 1] ?? {
        label: `BabylonWebGPUDevice${this._engine.uniqueId}_generateMipmaps_${format}_faceIndex${faceIndex}_level${i}`,
        colorAttachments: [
          {
            view: gpuTexture.createView({
              format,
              dimension: is3D ? "3d" : "2d",
              baseMipLevel: i,
              mipLevelCount: 1,
              arrayLayerCount: 1,
              baseArrayLayer: faceIndex
            }),
            loadOp: "load",
            storeOp: "store"
          }
        ]
      };
      if (webgpuHardwareTexture) {
        webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex] = webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex] || [];
        webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex][i - 1] = renderPassDescriptor;
      }
      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
      const bindGroup = webgpuHardwareTexture?._mipmapGenBindGroup[faceIndex]?.[i - 1] ?? this._device.createBindGroup({
        layout: bindGroupLayout,
        entries: [
          {
            binding: 0,
            resource: gpuTexture.createView({
              format,
              dimension: is3D ? "3d" : "2d",
              baseMipLevel: i - 1,
              mipLevelCount: 1,
              arrayLayerCount: 1,
              baseArrayLayer: faceIndex
            })
          },
          {
            binding: 1,
            resource: this._mipmapSampler
          }
        ]
      });
      if (webgpuHardwareTexture) {
        webgpuHardwareTexture._mipmapGenBindGroup[faceIndex] = webgpuHardwareTexture._mipmapGenBindGroup[faceIndex] || [];
        webgpuHardwareTexture._mipmapGenBindGroup[faceIndex][i - 1] = bindGroup;
      }
      passEncoder.setPipeline(pipeline);
      passEncoder.setBindGroup(0, bindGroup);
      passEncoder.draw(4, 1, 0, 0);
      passEncoder.end();
    }
    commandEncoder.popDebugGroup?.();
    if (useOwnCommandEncoder) {
      this._device.queue.submit([commandEncoder.finish()]);
      commandEncoder = null;
    }
  }
  createGPUTextureForInternalTexture(texture, width, height, depth, creationFlags, dontCreateMSAATexture) {
    if (!texture._hardwareTexture) {
      texture._hardwareTexture = new WebGPUHardwareTexture(this._engine);
    }
    if (width === void 0) {
      width = texture.width;
    }
    if (height === void 0) {
      height = texture.height;
    }
    if (depth === void 0) {
      depth = texture.depth;
    }
    const gpuTextureWrapper = texture._hardwareTexture;
    const isStorageTexture = ((creationFlags ?? 0) & 1) !== 0;
    gpuTextureWrapper.format = WebGPUTextureHelper.GetWebGPUTextureFormat(texture.type, texture.format, texture._useSRGBBuffer);
    gpuTextureWrapper.textureUsages = texture._source === 5 || texture.source === 6 ? 4 | 1 | 16 : texture._source === 12 ? 4 | 16 : -1;
    gpuTextureWrapper.textureAdditionalUsages = isStorageTexture ? 8 : 0;
    const hasMipMaps = texture.generateMipMaps;
    const layerCount = depth || 1;
    let mipmapCount;
    if (texture._maxLodLevel !== null) {
      mipmapCount = texture._maxLodLevel;
    } else {
      mipmapCount = hasMipMaps ? WebGPUTextureHelper.ComputeNumMipmapLevels(width, height) : 1;
    }
    if (texture.isCube) {
      const gpuTexture = this.createCubeTexture({ width, height }, texture.generateMipMaps, texture.generateMipMaps, texture.invertY, false, gpuTextureWrapper.format, 1, this._commandEncoderForCreation, gpuTextureWrapper.textureUsages, gpuTextureWrapper.textureAdditionalUsages, texture.label);
      gpuTextureWrapper.set(gpuTexture);
      const arrayLayerCount = texture.is3D ? 1 : layerCount;
      const format = WebGPUTextureHelper.GetDepthFormatOnly(gpuTextureWrapper.format);
      const aspect = WebGPUTextureHelper.HasDepthAndStencilAspects(gpuTextureWrapper.format) ? "depth-only" : "all";
      const dimension = texture.is2DArray ? "cube-array" : "cube";
      gpuTextureWrapper.createView({
        label: `BabylonWebGPUDevice${this._engine.uniqueId}_TextureViewCube${texture.is2DArray ? "_Array" + arrayLayerCount : ""}_${width}x${height}_${hasMipMaps ? "wmips" : "womips"}_${format}_${dimension}_${aspect}_${texture.label ?? "noname"}`,
        format,
        dimension,
        mipLevelCount: mipmapCount,
        baseArrayLayer: 0,
        baseMipLevel: 0,
        arrayLayerCount: 6,
        aspect
      }, isStorageTexture);
    } else {
      const gpuTexture = this.createTexture({ width, height, layers: layerCount }, texture.generateMipMaps, texture.generateMipMaps, texture.invertY, false, texture.is3D, gpuTextureWrapper.format, 1, this._commandEncoderForCreation, gpuTextureWrapper.textureUsages, gpuTextureWrapper.textureAdditionalUsages, texture.label);
      gpuTextureWrapper.set(gpuTexture);
      const arrayLayerCount = texture.is3D ? 1 : layerCount;
      const format = WebGPUTextureHelper.GetDepthFormatOnly(gpuTextureWrapper.format);
      const aspect = WebGPUTextureHelper.HasDepthAndStencilAspects(gpuTextureWrapper.format) ? "depth-only" : "all";
      const dimension = texture.is2DArray ? "2d-array" : texture.is3D ? "3d" : "2d";
      gpuTextureWrapper.createView({
        label: `BabylonWebGPUDevice${this._engine.uniqueId}_TextureView${texture.is3D ? "3D" : "2D"}${texture.is2DArray ? "_Array" + arrayLayerCount : ""}_${width}x${height}${texture.is3D ? "x" + layerCount : ""}_${hasMipMaps ? "wmips" : "womips"}_${format}_${dimension}_${aspect}_${texture.label ?? "noname"}`,
        format,
        dimension,
        mipLevelCount: mipmapCount,
        baseArrayLayer: 0,
        baseMipLevel: 0,
        arrayLayerCount,
        aspect
      }, isStorageTexture);
    }
    texture.width = texture.baseWidth = width;
    texture.height = texture.baseHeight = height;
    texture.depth = texture.baseDepth = depth;
    if (!dontCreateMSAATexture) {
      this.createMSAATexture(texture, texture.samples);
    }
    return gpuTextureWrapper;
  }
  createMSAATexture(texture, samples, releaseExisting = true, index = 0) {
    const gpuTextureWrapper = texture._hardwareTexture;
    if (releaseExisting) {
      gpuTextureWrapper?.releaseMSAATexture();
    }
    if (!gpuTextureWrapper || (samples ?? 1) <= 1) {
      return;
    }
    const width = texture.width;
    const height = texture.height;
    const gpuMSAATexture = this.createTexture({ width, height, layers: 1 }, false, false, false, false, false, gpuTextureWrapper.format, samples, this._commandEncoderForCreation, 16, 0, texture.label ? "MSAA_" + texture.label : "MSAA");
    gpuTextureWrapper.setMSAATexture(gpuMSAATexture, index);
  }
  //------------------------------------------------------------------------------
  //                                  Update
  //------------------------------------------------------------------------------
  updateCubeTextures(imageBitmaps, gpuTexture, width, height, format, invertY = false, premultiplyAlpha = false, offsetX = 0, offsetY = 0) {
    const faces = [0, 3, 1, 4, 2, 5];
    for (let f = 0; f < faces.length; ++f) {
      const imageBitmap = imageBitmaps[faces[f]];
      this.updateTexture(imageBitmap, gpuTexture, width, height, 1, format, f, 0, invertY, premultiplyAlpha, offsetX, offsetY);
    }
  }
  // TODO WEBGPU handle data source not being in the same format than the destination texture?
  updateTexture(imageBitmap, texture, width, height, layers, format, faceIndex = 0, mipLevel = 0, invertY = false, premultiplyAlpha = false, offsetX = 0, offsetY = 0, allowGPUOptimization) {
    const gpuTexture = WebGPUTextureHelper.IsInternalTexture(texture) ? texture._hardwareTexture.underlyingResource : texture;
    const blockInformation = WebGPUTextureHelper.GetBlockInformationFromFormat(format);
    const gpuOrHdwTexture = WebGPUTextureHelper.IsInternalTexture(texture) ? texture._hardwareTexture : texture;
    const textureCopyView = {
      texture: gpuTexture,
      origin: {
        x: offsetX,
        y: offsetY,
        z: Math.max(faceIndex, 0)
      },
      mipLevel,
      premultipliedAlpha: premultiplyAlpha
    };
    const textureExtent = {
      width: Math.ceil(width / blockInformation.width) * blockInformation.width,
      height: Math.ceil(height / blockInformation.height) * blockInformation.height,
      depthOrArrayLayers: layers || 1
    };
    if (imageBitmap.byteLength !== void 0) {
      imageBitmap = imageBitmap;
      const bytesPerRow = Math.ceil(width / blockInformation.width) * blockInformation.length;
      const aligned = Math.ceil(bytesPerRow / 256) * 256 === bytesPerRow;
      if (aligned) {
        const commandEncoder = this._device.createCommandEncoder({});
        const buffer = this._bufferManager.createRawBuffer(imageBitmap.byteLength, BufferUsage.MapWrite | BufferUsage.CopySrc, true, "TempBufferForUpdateTexture" + (gpuTexture ? "_" + gpuTexture.label : ""));
        const arrayBuffer = buffer.getMappedRange();
        new Uint8Array(arrayBuffer).set(imageBitmap);
        buffer.unmap();
        commandEncoder.copyBufferToTexture({
          buffer,
          offset: 0,
          bytesPerRow,
          rowsPerImage: height
        }, textureCopyView, textureExtent);
        this._device.queue.submit([commandEncoder.finish()]);
        this._bufferManager.releaseBuffer(buffer);
      } else {
        this._device.queue.writeTexture(textureCopyView, imageBitmap, {
          offset: 0,
          bytesPerRow,
          rowsPerImage: height
        }, textureExtent);
      }
      if (invertY || premultiplyAlpha) {
        if (WebGPUTextureHelper.IsInternalTexture(texture)) {
          const dontUseRect = offsetX === 0 && offsetY === 0 && width === texture.width && height === texture.height;
          this.invertYPreMultiplyAlpha(gpuOrHdwTexture, texture.width, texture.height, format, invertY, premultiplyAlpha, faceIndex, mipLevel, layers || 1, offsetX, offsetY, dontUseRect ? 0 : width, dontUseRect ? 0 : height, void 0, allowGPUOptimization);
        } else {
          throw "updateTexture: Can't process the texture data because a GPUTexture was provided instead of an InternalTexture!";
        }
      }
    } else {
      imageBitmap = imageBitmap;
      this._device.queue.copyExternalImageToTexture({ source: imageBitmap, flipY: invertY }, textureCopyView, textureExtent);
    }
  }
  readPixels(texture, x, y, width, height, format, faceIndex = 0, mipLevel = 0, buffer = null, noDataConversion = false) {
    const blockInformation = WebGPUTextureHelper.GetBlockInformationFromFormat(format);
    const bytesPerRow = Math.ceil(width / blockInformation.width) * blockInformation.length;
    const bytesPerRowAligned = Math.ceil(bytesPerRow / 256) * 256;
    const size = bytesPerRowAligned * height;
    const gpuBuffer = this._bufferManager.createRawBuffer(size, BufferUsage.MapRead | BufferUsage.CopyDst, void 0, "TempBufferForReadPixels" + (texture.label ? "_" + texture.label : ""));
    const commandEncoder = this._device.createCommandEncoder({});
    commandEncoder.copyTextureToBuffer({
      texture,
      mipLevel,
      origin: {
        x,
        y,
        z: Math.max(faceIndex, 0)
      }
    }, {
      buffer: gpuBuffer,
      offset: 0,
      bytesPerRow: bytesPerRowAligned
    }, {
      width,
      height,
      depthOrArrayLayers: 1
    });
    this._device.queue.submit([commandEncoder.finish()]);
    return this._bufferManager.readDataFromBuffer(gpuBuffer, size, width, height, bytesPerRow, bytesPerRowAligned, WebGPUTextureHelper.GetTextureTypeFromFormat(format), 0, buffer, true, noDataConversion);
  }
  //------------------------------------------------------------------------------
  //                              Dispose
  //------------------------------------------------------------------------------
  releaseTexture(texture) {
    if (WebGPUTextureHelper.IsInternalTexture(texture)) {
      const hardwareTexture = texture._hardwareTexture;
      const irradianceTexture = texture._irradianceTexture;
      this._deferredReleaseTextures.push([hardwareTexture, irradianceTexture]);
    } else {
      this._deferredReleaseTextures.push([texture, null]);
    }
  }
  destroyDeferredTextures() {
    for (let i = 0; i < this._deferredReleaseTextures.length; ++i) {
      const [hardwareTexture, irradianceTexture] = this._deferredReleaseTextures[i];
      if (hardwareTexture) {
        if (WebGPUTextureHelper.IsHardwareTexture(hardwareTexture)) {
          hardwareTexture.release();
        } else {
          hardwareTexture.destroy();
        }
      }
      irradianceTexture?.dispose();
    }
    this._deferredReleaseTextures.length = 0;
  }
};

// node_modules/@babylonjs/core/Meshes/WebGPU/webgpuDataBuffer.js
var WebGPUDataBuffer = class extends DataBuffer {
  set buffer(buffer) {
    this._buffer = buffer;
  }
  constructor(resource, capacity = 0) {
    super();
    this.engineId = -1;
    this.capacity = capacity;
    if (resource) {
      this._buffer = resource;
    }
  }
  get underlyingResource() {
    return this._buffer;
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuBufferManager.js
var WebGPUBufferManager = class _WebGPUBufferManager {
  static _IsGPUBuffer(buffer) {
    return buffer.underlyingResource === void 0;
  }
  static _FlagsToString(flags, suffix = "") {
    let result = suffix;
    for (let i = 0; i <= 9; ++i) {
      if (flags & 1 << i) {
        if (result) {
          result += "_";
        }
        result += BufferUsage[1 << i];
      }
    }
    return result;
  }
  constructor(engine, device) {
    this._deferredReleaseBuffers = [];
    this._engine = engine;
    this._device = device;
  }
  createRawBuffer(viewOrSize, flags, mappedAtCreation = false, label) {
    const alignedLength = viewOrSize.byteLength !== void 0 ? viewOrSize.byteLength + 3 & ~3 : viewOrSize + 3 & ~3;
    const verticesBufferDescriptor = {
      label: "BabylonWebGPUDevice" + this._engine.uniqueId + "_" + _WebGPUBufferManager._FlagsToString(flags, label ?? "Buffer") + "_size" + alignedLength,
      mappedAtCreation,
      size: alignedLength,
      usage: flags
    };
    return this._device.createBuffer(verticesBufferDescriptor);
  }
  createBuffer(viewOrSize, flags, label) {
    const isView = viewOrSize.byteLength !== void 0;
    const dataBuffer = new WebGPUDataBuffer();
    const labelId = "DataBufferUniqueId=" + dataBuffer.uniqueId;
    dataBuffer.buffer = this.createRawBuffer(viewOrSize, flags, void 0, label ? labelId + "-" + label : labelId);
    dataBuffer.references = 1;
    dataBuffer.capacity = isView ? viewOrSize.byteLength : viewOrSize;
    dataBuffer.engineId = this._engine.uniqueId;
    if (isView) {
      this.setSubData(dataBuffer, 0, viewOrSize);
    }
    return dataBuffer;
  }
  // This calls GPUBuffer.writeBuffer() with no alignment corrections
  // dstByteOffset and byteLength must both be aligned to 4 bytes and bytes moved must be within src and dst arrays
  setRawData(buffer, dstByteOffset, src, srcByteOffset, byteLength) {
    srcByteOffset += src.byteOffset;
    this._device.queue.writeBuffer(buffer, dstByteOffset, src.buffer, srcByteOffset, byteLength);
  }
  // This calls GPUBuffer.writeBuffer() with alignment corrections (dstByteOffset and byteLength will be aligned to 4 byte boundaries)
  // If alignment is needed, src must be a full copy of dataBuffer, or at least should be large enough to cope with the additional bytes copied because of alignment!
  setSubData(dataBuffer, dstByteOffset, src, srcByteOffset = 0, byteLength = 0) {
    const buffer = dataBuffer.underlyingResource;
    byteLength = byteLength || src.byteLength - srcByteOffset;
    const startPre = dstByteOffset & 3;
    srcByteOffset -= startPre;
    dstByteOffset -= startPre;
    const originalByteLength = byteLength;
    byteLength = byteLength + startPre + 3 & ~3;
    const backingBufferSize = src.buffer.byteLength - src.byteOffset;
    if (backingBufferSize < byteLength) {
      const tmpBuffer = new Uint8Array(byteLength);
      tmpBuffer.set(new Uint8Array(src.buffer, src.byteOffset + srcByteOffset, originalByteLength));
      src = tmpBuffer;
      srcByteOffset = 0;
    }
    this.setRawData(buffer, dstByteOffset, src, srcByteOffset, byteLength);
  }
  _getHalfFloatAsFloatRGBAArrayBuffer(dataLength, arrayBuffer, destArray) {
    if (!destArray) {
      destArray = new Float32Array(dataLength);
    }
    const srcData = new Uint16Array(arrayBuffer);
    while (dataLength--) {
      destArray[dataLength] = FromHalfFloat(srcData[dataLength]);
    }
    return destArray;
  }
  readDataFromBuffer(gpuBuffer, size, width, height, bytesPerRow, bytesPerRowAligned, type = 0, offset = 0, buffer = null, destroyBuffer = true, noDataConversion = false) {
    const floatFormat = type === 1 ? 2 : type === 2 ? 1 : 0;
    const engineId = this._engine.uniqueId;
    return new Promise((resolve, reject) => {
      gpuBuffer.mapAsync(1, offset, size).then(() => {
        const copyArrayBuffer = gpuBuffer.getMappedRange(offset, size);
        let data = buffer;
        if (noDataConversion) {
          if (data === null) {
            data = allocateAndCopyTypedBuffer(type, size, true, copyArrayBuffer);
          } else {
            data = allocateAndCopyTypedBuffer(type, data.buffer, void 0, copyArrayBuffer);
          }
        } else {
          if (data === null) {
            switch (floatFormat) {
              case 0:
                data = new Uint8Array(size);
                data.set(new Uint8Array(copyArrayBuffer));
                break;
              case 1:
                data = this._getHalfFloatAsFloatRGBAArrayBuffer(size / 2, copyArrayBuffer);
                break;
              case 2:
                data = new Float32Array(size / 4);
                data.set(new Float32Array(copyArrayBuffer));
                break;
            }
          } else {
            switch (floatFormat) {
              case 0:
                data = new Uint8Array(data.buffer);
                data.set(new Uint8Array(copyArrayBuffer));
                break;
              case 1:
                data = this._getHalfFloatAsFloatRGBAArrayBuffer(size / 2, copyArrayBuffer, buffer);
                break;
              case 2:
                data = new Float32Array(data.buffer);
                data.set(new Float32Array(copyArrayBuffer));
                break;
            }
          }
        }
        if (bytesPerRow !== bytesPerRowAligned) {
          if (floatFormat === 1 && !noDataConversion) {
            bytesPerRow *= 2;
            bytesPerRowAligned *= 2;
          }
          const data2 = new Uint8Array(data.buffer);
          let offset2 = bytesPerRow, offset22 = 0;
          for (let y = 1; y < height; ++y) {
            offset22 = y * bytesPerRowAligned;
            for (let x = 0; x < bytesPerRow; ++x) {
              data2[offset2++] = data2[offset22++];
            }
          }
          if (floatFormat !== 0 && !noDataConversion) {
            data = new Float32Array(data2.buffer, 0, offset2 / 4);
          } else {
            data = new Uint8Array(data2.buffer, 0, offset2);
          }
        }
        gpuBuffer.unmap();
        if (destroyBuffer) {
          this.releaseBuffer(gpuBuffer);
        }
        resolve(data);
      }, (reason) => {
        if (this._engine.isDisposed || this._engine.uniqueId !== engineId) {
          resolve(new Uint8Array());
        } else {
          reject(reason);
        }
      });
    });
  }
  releaseBuffer(buffer) {
    if (_WebGPUBufferManager._IsGPUBuffer(buffer)) {
      this._deferredReleaseBuffers.push(buffer);
      return true;
    }
    buffer.references--;
    if (buffer.references === 0) {
      this._deferredReleaseBuffers.push(buffer.underlyingResource);
      return true;
    }
    return false;
  }
  destroyDeferredBuffers() {
    for (let i = 0; i < this._deferredReleaseBuffers.length; ++i) {
      this._deferredReleaseBuffers[i].destroy();
    }
    this._deferredReleaseBuffers.length = 0;
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuCacheSampler.js
var filterToBits = [
  0 | 0 << 1 | 0 << 2,
  // not used
  0 | 0 << 1 | 0 << 2,
  // TEXTURE_NEAREST_SAMPLINGMODE / TEXTURE_NEAREST_NEAREST
  1 | 1 << 1 | 0 << 2,
  // TEXTURE_BILINEAR_SAMPLINGMODE / TEXTURE_LINEAR_LINEAR
  1 | 1 << 1 | 1 << 2,
  // TEXTURE_TRILINEAR_SAMPLINGMODE / TEXTURE_LINEAR_LINEAR_MIPLINEAR
  0 | 0 << 1 | 0 << 2,
  // TEXTURE_NEAREST_NEAREST_MIPNEAREST
  0 | 1 << 1 | 0 << 2,
  // TEXTURE_NEAREST_LINEAR_MIPNEAREST
  0 | 1 << 1 | 1 << 2,
  // TEXTURE_NEAREST_LINEAR_MIPLINEAR
  0 | 1 << 1 | 0 << 2,
  // TEXTURE_NEAREST_LINEAR
  0 | 0 << 1 | 1 << 2,
  // TEXTURE_NEAREST_NEAREST_MIPLINEAR
  1 | 0 << 1 | 0 << 2,
  // TEXTURE_LINEAR_NEAREST_MIPNEAREST
  1 | 0 << 1 | 1 << 2,
  // TEXTURE_LINEAR_NEAREST_MIPLINEAR
  1 | 1 << 1 | 0 << 2,
  // TEXTURE_LINEAR_LINEAR_MIPNEAREST
  1 | 0 << 1 | 0 << 2
  // TEXTURE_LINEAR_NEAREST
];
var comparisonFunctionToBits = [
  0 << 3 | 0 << 4 | 0 << 5 | 0 << 6,
  // undefined
  0 << 3 | 0 << 4 | 0 << 5 | 1 << 6,
  // NEVER
  0 << 3 | 0 << 4 | 1 << 5 | 0 << 6,
  // LESS
  0 << 3 | 0 << 4 | 1 << 5 | 1 << 6,
  // EQUAL
  0 << 3 | 1 << 4 | 0 << 5 | 0 << 6,
  // LEQUAL
  0 << 3 | 1 << 4 | 0 << 5 | 1 << 6,
  // GREATER
  0 << 3 | 1 << 4 | 1 << 5 | 0 << 6,
  // NOTEQUAL
  0 << 3 | 1 << 4 | 1 << 5 | 1 << 6,
  // GEQUAL
  1 << 3 | 0 << 4 | 0 << 5 | 0 << 6
  // ALWAYS
];
var filterNoMipToBits = [
  0 << 7,
  // not used
  1 << 7,
  // TEXTURE_NEAREST_SAMPLINGMODE / TEXTURE_NEAREST_NEAREST
  1 << 7,
  // TEXTURE_BILINEAR_SAMPLINGMODE / TEXTURE_LINEAR_LINEAR
  0 << 7,
  // TEXTURE_TRILINEAR_SAMPLINGMODE / TEXTURE_LINEAR_LINEAR_MIPLINEAR
  0 << 7,
  // TEXTURE_NEAREST_NEAREST_MIPNEAREST
  0 << 7,
  // TEXTURE_NEAREST_LINEAR_MIPNEAREST
  0 << 7,
  // TEXTURE_NEAREST_LINEAR_MIPLINEAR
  1 << 7,
  // TEXTURE_NEAREST_LINEAR
  0 << 7,
  // TEXTURE_NEAREST_NEAREST_MIPLINEAR
  0 << 7,
  // TEXTURE_LINEAR_NEAREST_MIPNEAREST
  0 << 7,
  // TEXTURE_LINEAR_NEAREST_MIPLINEAR
  0 << 7,
  // TEXTURE_LINEAR_LINEAR_MIPNEAREST
  1 << 7
  // TEXTURE_LINEAR_NEAREST
];
var WebGPUCacheSampler = class _WebGPUCacheSampler {
  constructor(device) {
    this._samplers = {};
    this._device = device;
    this.disabled = false;
  }
  static GetSamplerHashCode(sampler) {
    const anisotropy = sampler._cachedAnisotropicFilteringLevel ? sampler._cachedAnisotropicFilteringLevel : 1;
    const code = filterToBits[sampler.samplingMode] + comparisonFunctionToBits[(sampler._comparisonFunction || 514) - 512 + 1] + filterNoMipToBits[sampler.samplingMode] + // handle the lodMinClamp = lodMaxClamp = 0 case when no filter used for mip mapping
    ((sampler._cachedWrapU ?? 1) << 8) + ((sampler._cachedWrapV ?? 1) << 10) + ((sampler._cachedWrapR ?? 1) << 12) + ((sampler.useMipMaps ? 1 : 0) << 14) + // need to factor this in because _getSamplerFilterDescriptor depends on samplingMode AND useMipMaps!
    (anisotropy << 15);
    return code;
  }
  static _GetSamplerFilterDescriptor(sampler, anisotropy) {
    let magFilter, minFilter, mipmapFilter, lodMinClamp, lodMaxClamp;
    const useMipMaps = sampler.useMipMaps;
    switch (sampler.samplingMode) {
      case 11:
        magFilter = "linear";
        minFilter = "linear";
        mipmapFilter = "nearest";
        if (!useMipMaps) {
          lodMinClamp = lodMaxClamp = 0;
        }
        break;
      case 3:
      case 3:
        magFilter = "linear";
        minFilter = "linear";
        if (!useMipMaps) {
          mipmapFilter = "nearest";
          lodMinClamp = lodMaxClamp = 0;
        } else {
          mipmapFilter = "linear";
        }
        break;
      case 8:
        magFilter = "nearest";
        minFilter = "nearest";
        if (!useMipMaps) {
          mipmapFilter = "nearest";
          lodMinClamp = lodMaxClamp = 0;
        } else {
          mipmapFilter = "linear";
        }
        break;
      case 4:
        magFilter = "nearest";
        minFilter = "nearest";
        mipmapFilter = "nearest";
        if (!useMipMaps) {
          lodMinClamp = lodMaxClamp = 0;
        }
        break;
      case 5:
        magFilter = "nearest";
        minFilter = "linear";
        mipmapFilter = "nearest";
        if (!useMipMaps) {
          lodMinClamp = lodMaxClamp = 0;
        }
        break;
      case 6:
        magFilter = "nearest";
        minFilter = "linear";
        if (!useMipMaps) {
          mipmapFilter = "nearest";
          lodMinClamp = lodMaxClamp = 0;
        } else {
          mipmapFilter = "linear";
        }
        break;
      case 7:
        magFilter = "nearest";
        minFilter = "linear";
        mipmapFilter = "nearest";
        lodMinClamp = lodMaxClamp = 0;
        break;
      case 1:
      case 1:
        magFilter = "nearest";
        minFilter = "nearest";
        mipmapFilter = "nearest";
        lodMinClamp = lodMaxClamp = 0;
        break;
      case 9:
        magFilter = "linear";
        minFilter = "nearest";
        mipmapFilter = "nearest";
        if (!useMipMaps) {
          lodMinClamp = lodMaxClamp = 0;
        }
        break;
      case 10:
        magFilter = "linear";
        minFilter = "nearest";
        if (!useMipMaps) {
          mipmapFilter = "nearest";
          lodMinClamp = lodMaxClamp = 0;
        } else {
          mipmapFilter = "linear";
        }
        break;
      case 2:
      case 2:
        magFilter = "linear";
        minFilter = "linear";
        if (anisotropy > 1) {
          mipmapFilter = "linear";
        } else {
          mipmapFilter = "nearest";
          lodMinClamp = lodMaxClamp = 0;
        }
        break;
      case 12:
        magFilter = "linear";
        minFilter = "nearest";
        mipmapFilter = "nearest";
        lodMinClamp = lodMaxClamp = 0;
        break;
      default:
        magFilter = "nearest";
        minFilter = "nearest";
        mipmapFilter = "nearest";
        lodMinClamp = lodMaxClamp = 0;
        break;
    }
    if (anisotropy > 1 && (lodMinClamp !== 0 || lodMaxClamp !== 0)) {
      return {
        magFilter: "linear",
        minFilter: "linear",
        mipmapFilter: "linear",
        anisotropyEnabled: true
      };
    }
    return {
      magFilter,
      minFilter,
      mipmapFilter,
      lodMinClamp,
      lodMaxClamp
    };
  }
  static _GetWrappingMode(mode) {
    switch (mode) {
      case 1:
        return "repeat";
      case 0:
        return "clamp-to-edge";
      case 2:
        return "mirror-repeat";
    }
    return "repeat";
  }
  static _GetSamplerWrappingDescriptor(sampler) {
    return {
      addressModeU: this._GetWrappingMode(sampler._cachedWrapU),
      addressModeV: this._GetWrappingMode(sampler._cachedWrapV),
      addressModeW: this._GetWrappingMode(sampler._cachedWrapR)
    };
  }
  static _GetSamplerDescriptor(sampler, label) {
    let anisotropy = (sampler.useMipMaps || sampler.samplingMode === 2) && sampler._cachedAnisotropicFilteringLevel ? sampler._cachedAnisotropicFilteringLevel : 1;
    if (sampler.samplingMode !== 11 && sampler.samplingMode !== 3 && sampler.samplingMode !== 2) {
      anisotropy = 1;
    }
    const filterDescriptor = this._GetSamplerFilterDescriptor(sampler, anisotropy);
    return {
      label,
      ...filterDescriptor,
      ...this._GetSamplerWrappingDescriptor(sampler),
      compare: sampler._comparisonFunction ? _WebGPUCacheSampler.GetCompareFunction(sampler._comparisonFunction) : void 0,
      maxAnisotropy: filterDescriptor.anisotropyEnabled ? anisotropy : 1
    };
  }
  static GetCompareFunction(compareFunction) {
    switch (compareFunction) {
      case 519:
        return "always";
      case 514:
        return "equal";
      case 516:
        return "greater";
      case 518:
        return "greater-equal";
      case 513:
        return "less";
      case 515:
        return "less-equal";
      case 512:
        return "never";
      case 517:
        return "not-equal";
      default:
        return "less";
    }
  }
  getSampler(sampler, bypassCache = false, hash = 0, label) {
    if (this.disabled) {
      return this._device.createSampler(_WebGPUCacheSampler._GetSamplerDescriptor(sampler, label));
    }
    if (bypassCache) {
      hash = 0;
    } else if (hash === 0) {
      hash = _WebGPUCacheSampler.GetSamplerHashCode(sampler);
    }
    let gpuSampler = bypassCache ? void 0 : this._samplers[hash];
    if (!gpuSampler) {
      gpuSampler = this._device.createSampler(_WebGPUCacheSampler._GetSamplerDescriptor(sampler, label));
      if (!bypassCache) {
        this._samplers[hash] = gpuSampler;
      }
    }
    return gpuSampler;
  }
};

// node_modules/@babylonjs/core/Buffers/buffer.nonFloatVertexBuffers.js
var vertexBufferKindForNonFloatProcessing = {
  [VertexBuffer.PositionKind]: true,
  [VertexBuffer.NormalKind]: true,
  [VertexBuffer.TangentKind]: true,
  [VertexBuffer.UVKind]: true,
  [VertexBuffer.UV2Kind]: true,
  [VertexBuffer.UV3Kind]: true,
  [VertexBuffer.UV4Kind]: true,
  [VertexBuffer.UV5Kind]: true,
  [VertexBuffer.UV6Kind]: true,
  [VertexBuffer.ColorKind]: true,
  [VertexBuffer.ColorInstanceKind]: true,
  [VertexBuffer.MatricesIndicesKind]: true,
  [VertexBuffer.MatricesWeightsKind]: true,
  [VertexBuffer.MatricesIndicesExtraKind]: true,
  [VertexBuffer.MatricesWeightsExtraKind]: true
};
function isSignedType(type) {
  switch (type) {
    case VertexBuffer.BYTE:
    case VertexBuffer.SHORT:
    case VertexBuffer.INT:
    case VertexBuffer.FLOAT:
      return true;
    case VertexBuffer.UNSIGNED_BYTE:
    case VertexBuffer.UNSIGNED_SHORT:
    case VertexBuffer.UNSIGNED_INT:
      return false;
    default:
      throw new Error(`Invalid type '${type}'`);
  }
}
function checkNonFloatVertexBuffers(vertexBuffers, effect) {
  const engine = effect.getEngine();
  const pipelineContext = effect._pipelineContext;
  if (!pipelineContext?.vertexBufferKindToType) {
    return;
  }
  let shaderProcessingContext = null;
  for (const kind in vertexBuffers) {
    const currentVertexBuffer = vertexBuffers[kind];
    if (!currentVertexBuffer || !vertexBufferKindForNonFloatProcessing[kind]) {
      continue;
    }
    const currentVertexBufferType = currentVertexBuffer.normalized ? VertexBuffer.FLOAT : currentVertexBuffer.type;
    const vertexBufferType = pipelineContext.vertexBufferKindToType[kind];
    if (currentVertexBufferType !== VertexBuffer.FLOAT && vertexBufferType === void 0 || vertexBufferType !== void 0 && vertexBufferType !== currentVertexBufferType) {
      if (!shaderProcessingContext) {
        shaderProcessingContext = engine._getShaderProcessingContext(effect.shaderLanguage, false);
      }
      pipelineContext.vertexBufferKindToType[kind] = currentVertexBufferType;
      if (currentVertexBufferType !== VertexBuffer.FLOAT) {
        shaderProcessingContext.vertexBufferKindToNumberOfComponents[kind] = VertexBuffer.DeduceStride(kind);
        if (isSignedType(currentVertexBufferType)) {
          shaderProcessingContext.vertexBufferKindToNumberOfComponents[kind] *= -1;
        }
      }
    }
  }
  if (shaderProcessingContext) {
    const parallelShaderCompile = engine._caps.parallelShaderCompile;
    engine._caps.parallelShaderCompile = void 0;
    effect._processShaderCodeAsync(null, engine._features._checkNonFloatVertexBuffersDontRecreatePipelineContext, shaderProcessingContext);
    engine._caps.parallelShaderCompile = parallelShaderCompile;
  }
}

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuCacheRenderPipeline.js
var StatePosition;
(function(StatePosition2) {
  StatePosition2[StatePosition2["StencilReadMask"] = 0] = "StencilReadMask";
  StatePosition2[StatePosition2["StencilWriteMask"] = 1] = "StencilWriteMask";
  StatePosition2[StatePosition2["DepthBias"] = 2] = "DepthBias";
  StatePosition2[StatePosition2["DepthBiasSlopeScale"] = 3] = "DepthBiasSlopeScale";
  StatePosition2[StatePosition2["DepthStencilState"] = 4] = "DepthStencilState";
  StatePosition2[StatePosition2["MRTAttachments1"] = 5] = "MRTAttachments1";
  StatePosition2[StatePosition2["MRTAttachments2"] = 6] = "MRTAttachments2";
  StatePosition2[StatePosition2["RasterizationState"] = 7] = "RasterizationState";
  StatePosition2[StatePosition2["ColorStates"] = 8] = "ColorStates";
  StatePosition2[StatePosition2["ShaderStage"] = 9] = "ShaderStage";
  StatePosition2[StatePosition2["TextureStage"] = 10] = "TextureStage";
  StatePosition2[StatePosition2["VertexState"] = 11] = "VertexState";
  StatePosition2[StatePosition2["NumStates"] = 12] = "NumStates";
})(StatePosition || (StatePosition = {}));
var alphaBlendFactorToIndex = {
  0: 1,
  // Zero
  1: 2,
  // One
  768: 3,
  // SrcColor
  769: 4,
  // OneMinusSrcColor
  770: 5,
  // SrcAlpha
  771: 6,
  // OneMinusSrcAlpha
  772: 7,
  // DstAlpha
  773: 8,
  // OneMinusDstAlpha
  774: 9,
  // DstColor
  775: 10,
  // OneMinusDstColor
  776: 11,
  // SrcAlphaSaturated
  32769: 12,
  // BlendColor
  32770: 13,
  // OneMinusBlendColor
  32771: 12,
  // BlendColor (alpha)
  32772: 13
  // OneMinusBlendColor (alpha)
};
var stencilOpToIndex = {
  0: 0,
  // ZERO
  7680: 1,
  // KEEP
  7681: 2,
  // REPLACE
  7682: 3,
  // INCR
  7683: 4,
  // DECR
  5386: 5,
  // INVERT
  34055: 6,
  // INCR_WRAP
  34056: 7
  // DECR_WRAP
};
var WebGPUCacheRenderPipeline = class _WebGPUCacheRenderPipeline {
  constructor(device, emptyVertexBuffer) {
    this.mrtTextureCount = 0;
    this._device = device;
    this._useTextureStage = true;
    this._states = new Array(30);
    this._statesLength = 0;
    this._stateDirtyLowestIndex = 0;
    this._emptyVertexBuffer = emptyVertexBuffer;
    this._mrtFormats = [];
    this._parameter = { token: void 0, pipeline: null };
    this.disabled = false;
    this.vertexBuffers = [];
    this._kMaxVertexBufferStride = device.limits.maxVertexBufferArrayStride || 2048;
    this.reset();
  }
  reset() {
    this._isDirty = true;
    this.vertexBuffers.length = 0;
    this.setAlphaToCoverage(false);
    this.resetDepthCullingState();
    this.setClampDepth(false);
    this.setDepthBias(0);
    this._webgpuColorFormat = [
      "bgra8unorm"
      /* WebGPUConstants.TextureFormat.BGRA8Unorm */
    ];
    this.setColorFormat(
      "bgra8unorm"
      /* WebGPUConstants.TextureFormat.BGRA8Unorm */
    );
    this.setMRT([]);
    this.setAlphaBlendEnabled(false);
    this.setAlphaBlendFactors([null, null, null, null], [null, null]);
    this.setWriteMask(15);
    this.setDepthStencilFormat(
      "depth24plus-stencil8"
      /* WebGPUConstants.TextureFormat.Depth24PlusStencil8 */
    );
    this.setStencilEnabled(false);
    this.resetStencilState();
    this.setBuffers(null, null, null);
    this._setTextureState(0);
  }
  get colorFormats() {
    return this._mrtAttachments1 > 0 ? this._mrtFormats : this._webgpuColorFormat;
  }
  getRenderPipeline(fillMode, effect, sampleCount, textureState = 0) {
    sampleCount = WebGPUTextureHelper.GetSample(sampleCount);
    if (this.disabled) {
      const topology2 = _WebGPUCacheRenderPipeline._GetTopology(fillMode);
      this._setVertexState(effect);
      this._setTextureState(textureState);
      this._parameter.pipeline = this._createRenderPipeline(effect, topology2, sampleCount);
      _WebGPUCacheRenderPipeline.NumCacheMiss++;
      _WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame++;
      return this._parameter.pipeline;
    }
    this._setShaderStage(effect.uniqueId);
    this._setRasterizationState(fillMode, sampleCount);
    this._setColorStates();
    this._setDepthStencilState();
    this._setVertexState(effect);
    this._setTextureState(textureState);
    this.lastStateDirtyLowestIndex = this._stateDirtyLowestIndex;
    if (!this._isDirty && this._parameter.pipeline) {
      this._stateDirtyLowestIndex = this._statesLength;
      _WebGPUCacheRenderPipeline.NumCacheHitWithoutHash++;
      return this._parameter.pipeline;
    }
    this._getRenderPipeline(this._parameter);
    this._isDirty = false;
    this._stateDirtyLowestIndex = this._statesLength;
    if (this._parameter.pipeline) {
      _WebGPUCacheRenderPipeline.NumCacheHitWithHash++;
      return this._parameter.pipeline;
    }
    const topology = _WebGPUCacheRenderPipeline._GetTopology(fillMode);
    this._parameter.pipeline = this._createRenderPipeline(effect, topology, sampleCount);
    this._setRenderPipeline(this._parameter);
    _WebGPUCacheRenderPipeline.NumCacheMiss++;
    _WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame++;
    return this._parameter.pipeline;
  }
  endFrame() {
    _WebGPUCacheRenderPipeline.NumPipelineCreationLastFrame = _WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame;
    _WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame = 0;
  }
  setAlphaToCoverage(enabled) {
    this._alphaToCoverageEnabled = enabled;
  }
  setFrontFace(frontFace) {
    this._frontFace = frontFace;
  }
  setCullEnabled(enabled) {
    this._cullEnabled = enabled;
  }
  setCullFace(cullFace) {
    this._cullFace = cullFace;
  }
  setClampDepth(clampDepth) {
    this._clampDepth = clampDepth;
  }
  resetDepthCullingState() {
    this.setDepthCullingState(false, 2, 1, 0, 0, true, true, 519);
  }
  setDepthCullingState(cullEnabled, frontFace, cullFace, zOffset, zOffsetUnits, depthTestEnabled, depthWriteEnabled, depthCompare) {
    this._depthWriteEnabled = depthWriteEnabled;
    this._depthTestEnabled = depthTestEnabled;
    this._depthCompare = (depthCompare ?? 519) - 512;
    this._cullFace = cullFace;
    this._cullEnabled = cullEnabled;
    this._frontFace = frontFace;
    this.setDepthBiasSlopeScale(zOffset);
    this.setDepthBias(zOffsetUnits);
  }
  setDepthBias(depthBias) {
    if (this._depthBias !== depthBias) {
      this._depthBias = depthBias;
      this._states[StatePosition.DepthBias] = depthBias;
      this._isDirty = true;
      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.DepthBias);
    }
  }
  /*public setDepthBiasClamp(depthBiasClamp: number): void {
      if (this._depthBiasClamp !== depthBiasClamp) {
          this._depthBiasClamp = depthBiasClamp;
          this._states[StatePosition.DepthBiasClamp] = depthBiasClamp.toString();
          this._isDirty = true;
      }
  }*/
  setDepthBiasSlopeScale(depthBiasSlopeScale) {
    if (this._depthBiasSlopeScale !== depthBiasSlopeScale) {
      this._depthBiasSlopeScale = depthBiasSlopeScale;
      this._states[StatePosition.DepthBiasSlopeScale] = depthBiasSlopeScale;
      this._isDirty = true;
      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.DepthBiasSlopeScale);
    }
  }
  setColorFormat(format) {
    this._webgpuColorFormat[0] = format;
    this._colorFormat = renderableTextureFormatToIndex[format ?? ""];
  }
  setMRTAttachments(attachments) {
    this.mrtAttachments = attachments;
    let mask = 0;
    for (let i = 0; i < attachments.length; ++i) {
      if (attachments[i] !== 0) {
        mask += 1 << i;
      }
    }
    if (this._mrtEnabledMask !== mask) {
      this._mrtEnabledMask = mask;
      this._isDirty = true;
      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.MRTAttachments1);
    }
  }
  setMRT(textureArray, textureCount) {
    textureCount = textureCount ?? textureArray.length;
    if (textureCount > 10) {
      throw "Can't handle more than 10 attachments for a MRT in cache render pipeline!";
    }
    this.mrtTextureArray = textureArray;
    this.mrtTextureCount = textureCount;
    this._mrtEnabledMask = 65535;
    const bits = [0, 0];
    let indexBits = 0, mask = 0, numRT = 0;
    for (let i = 0; i < textureCount; ++i) {
      const texture = textureArray[i];
      const gpuWrapper = texture?._hardwareTexture;
      this._mrtFormats[numRT] = gpuWrapper?.format ?? this._webgpuColorFormat[0];
      bits[indexBits] += renderableTextureFormatToIndex[this._mrtFormats[numRT] ?? ""] << mask;
      mask += 6;
      numRT++;
      if (mask >= 32) {
        mask = 0;
        indexBits++;
      }
    }
    this._mrtFormats.length = numRT;
    if (this._mrtAttachments1 !== bits[0] || this._mrtAttachments2 !== bits[1]) {
      this._mrtAttachments1 = bits[0];
      this._mrtAttachments2 = bits[1];
      this._states[StatePosition.MRTAttachments1] = bits[0];
      this._states[StatePosition.MRTAttachments2] = bits[1];
      this._isDirty = true;
      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.MRTAttachments1);
    }
  }
  setAlphaBlendEnabled(enabled) {
    this._alphaBlendEnabled = enabled;
  }
  setAlphaBlendFactors(factors, operations) {
    this._alphaBlendFuncParams = factors;
    this._alphaBlendEqParams = operations;
  }
  setWriteMask(mask) {
    this._writeMask = mask;
  }
  setDepthStencilFormat(format) {
    this._webgpuDepthStencilFormat = format;
    this._depthStencilFormat = format === void 0 ? 0 : renderableTextureFormatToIndex[format];
  }
  setDepthTestEnabled(enabled) {
    this._depthTestEnabled = enabled;
  }
  setDepthWriteEnabled(enabled) {
    this._depthWriteEnabled = enabled;
  }
  setDepthCompare(func) {
    this._depthCompare = (func ?? 519) - 512;
  }
  setStencilEnabled(enabled) {
    this._stencilEnabled = enabled;
  }
  setStencilCompare(func) {
    this._stencilFrontCompare = (func ?? 519) - 512;
  }
  setStencilDepthFailOp(op) {
    this._stencilFrontDepthFailOp = op === null ? 1 : stencilOpToIndex[op];
  }
  setStencilPassOp(op) {
    this._stencilFrontPassOp = op === null ? 2 : stencilOpToIndex[op];
  }
  setStencilFailOp(op) {
    this._stencilFrontFailOp = op === null ? 1 : stencilOpToIndex[op];
  }
  setStencilReadMask(mask) {
    if (this._stencilReadMask !== mask) {
      this._stencilReadMask = mask;
      this._states[StatePosition.StencilReadMask] = mask;
      this._isDirty = true;
      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.StencilReadMask);
    }
  }
  setStencilWriteMask(mask) {
    if (this._stencilWriteMask !== mask) {
      this._stencilWriteMask = mask;
      this._states[StatePosition.StencilWriteMask] = mask;
      this._isDirty = true;
      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.StencilWriteMask);
    }
  }
  resetStencilState() {
    this.setStencilState(false, 519, 7680, 7681, 7680, 255, 255);
  }
  setStencilState(stencilEnabled, compare, depthFailOp, passOp, failOp, readMask, writeMask) {
    this._stencilEnabled = stencilEnabled;
    this._stencilFrontCompare = (compare ?? 519) - 512;
    this._stencilFrontDepthFailOp = depthFailOp === null ? 1 : stencilOpToIndex[depthFailOp];
    this._stencilFrontPassOp = passOp === null ? 2 : stencilOpToIndex[passOp];
    this._stencilFrontFailOp = failOp === null ? 1 : stencilOpToIndex[failOp];
    this.setStencilReadMask(readMask);
    this.setStencilWriteMask(writeMask);
  }
  setBuffers(vertexBuffers, indexBuffer, overrideVertexBuffers) {
    this._vertexBuffers = vertexBuffers;
    this._overrideVertexBuffers = overrideVertexBuffers;
    this._indexBuffer = indexBuffer;
  }
  static _GetTopology(fillMode) {
    switch (fillMode) {
      // Triangle views
      case 0:
        return "triangle-list";
      case 2:
        return "point-list";
      case 1:
        return "line-list";
      // Draw modes
      case 3:
        return "point-list";
      case 4:
        return "line-list";
      case 5:
        throw "LineLoop is an unsupported fillmode in WebGPU";
      case 6:
        return "line-strip";
      case 7:
        return "triangle-strip";
      case 8:
        throw "TriangleFan is an unsupported fillmode in WebGPU";
      default:
        return "triangle-list";
    }
  }
  static _GetAphaBlendOperation(operation) {
    switch (operation) {
      case 32774:
        return "add";
      case 32778:
        return "subtract";
      case 32779:
        return "reverse-subtract";
      case 32775:
        return "min";
      case 32776:
        return "max";
      default:
        return "add";
    }
  }
  static _GetAphaBlendFactor(factor) {
    switch (factor) {
      case 0:
        return "zero";
      case 1:
        return "one";
      case 768:
        return "src";
      case 769:
        return "one-minus-src";
      case 770:
        return "src-alpha";
      case 771:
        return "one-minus-src-alpha";
      case 772:
        return "dst-alpha";
      case 773:
        return "one-minus-dst-alpha";
      case 774:
        return "dst";
      case 775:
        return "one-minus-dst";
      case 776:
        return "src-alpha-saturated";
      case 32769:
        return "constant";
      case 32770:
        return "one-minus-constant";
      case 32771:
        return "constant";
      case 32772:
        return "one-minus-constant";
      case 35065:
        return "src1";
      case 35066:
        return "one-minus-src1";
      case 34185:
        return "src1-alpha";
      case 35067:
        return "one-minus-src1-alpha";
      default:
        return "one";
    }
  }
  static _GetCompareFunction(compareFunction) {
    switch (compareFunction) {
      case 0:
        return "never";
      case 1:
        return "less";
      case 2:
        return "equal";
      case 3:
        return "less-equal";
      case 4:
        return "greater";
      case 5:
        return "not-equal";
      case 6:
        return "greater-equal";
      case 7:
        return "always";
    }
    return "never";
  }
  static _GetStencilOpFunction(operation) {
    switch (operation) {
      case 0:
        return "zero";
      case 1:
        return "keep";
      case 2:
        return "replace";
      case 3:
        return "increment-clamp";
      case 4:
        return "decrement-clamp";
      case 5:
        return "invert";
      case 6:
        return "increment-wrap";
      case 7:
        return "decrement-wrap";
    }
    return "keep";
  }
  static _GetVertexInputDescriptorFormat(vertexBuffer) {
    const type = vertexBuffer.type;
    const normalized = vertexBuffer.normalized;
    const size = vertexBuffer.getSize();
    switch (type) {
      case VertexBuffer.BYTE:
        switch (size) {
          case 1:
          case 2:
            return normalized ? "snorm8x2" : "sint8x2";
          case 3:
          case 4:
            return normalized ? "snorm8x4" : "sint8x4";
        }
        break;
      case VertexBuffer.UNSIGNED_BYTE:
        switch (size) {
          case 1:
          case 2:
            return normalized ? "unorm8x2" : "uint8x2";
          case 3:
          case 4:
            return normalized ? "unorm8x4" : "uint8x4";
        }
        break;
      case VertexBuffer.SHORT:
        switch (size) {
          case 1:
          case 2:
            return normalized ? "snorm16x2" : "sint16x2";
          case 3:
          case 4:
            return normalized ? "snorm16x4" : "sint16x4";
        }
        break;
      case VertexBuffer.UNSIGNED_SHORT:
        switch (size) {
          case 1:
          case 2:
            return normalized ? "unorm16x2" : "uint16x2";
          case 3:
          case 4:
            return normalized ? "unorm16x4" : "uint16x4";
        }
        break;
      case VertexBuffer.INT:
        switch (size) {
          case 1:
            return "sint32";
          case 2:
            return "sint32x2";
          case 3:
            return "sint32x3";
          case 4:
            return "sint32x4";
        }
        break;
      case VertexBuffer.UNSIGNED_INT:
        switch (size) {
          case 1:
            return "uint32";
          case 2:
            return "uint32x2";
          case 3:
            return "uint32x3";
          case 4:
            return "uint32x4";
        }
        break;
      case VertexBuffer.FLOAT:
        switch (size) {
          case 1:
            return "float32";
          case 2:
            return "float32x2";
          case 3:
            return "float32x3";
          case 4:
            return "float32x4";
        }
        break;
    }
    throw new Error(`Invalid Format '${vertexBuffer.getKind()}' - type=${type}, normalized=${normalized}, size=${size}`);
  }
  _getAphaBlendState() {
    if (!this._alphaBlendEnabled) {
      return null;
    }
    return {
      srcFactor: _WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[2]),
      dstFactor: _WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[3]),
      operation: _WebGPUCacheRenderPipeline._GetAphaBlendOperation(this._alphaBlendEqParams[1])
    };
  }
  _getColorBlendState() {
    if (!this._alphaBlendEnabled) {
      return null;
    }
    return {
      srcFactor: _WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[0]),
      dstFactor: _WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[1]),
      operation: _WebGPUCacheRenderPipeline._GetAphaBlendOperation(this._alphaBlendEqParams[0])
    };
  }
  _setShaderStage(id) {
    if (this._shaderId !== id) {
      this._shaderId = id;
      this._states[StatePosition.ShaderStage] = id;
      this._isDirty = true;
      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.ShaderStage);
    }
  }
  _setRasterizationState(topology, sampleCount) {
    const frontFace = this._frontFace;
    const cullMode = this._cullEnabled ? this._cullFace : 0;
    const clampDepth = this._clampDepth ? 1 : 0;
    const alphaToCoverage = this._alphaToCoverageEnabled ? 1 : 0;
    const rasterizationState = frontFace - 1 + (cullMode << 1) + (clampDepth << 3) + (alphaToCoverage << 4) + (topology << 5) + (sampleCount << 8);
    if (this._rasterizationState !== rasterizationState) {
      this._rasterizationState = rasterizationState;
      this._states[StatePosition.RasterizationState] = this._rasterizationState;
      this._isDirty = true;
      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.RasterizationState);
    }
  }
  _setColorStates() {
    let colorStates = ((this._writeMask ? 1 : 0) << 22) + (this._colorFormat << 23) + ((this._depthWriteEnabled ? 1 : 0) << 29);
    if (this._alphaBlendEnabled) {
      colorStates += ((this._alphaBlendFuncParams[0] === null ? 2 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[0]]) << 0) + ((this._alphaBlendFuncParams[1] === null ? 2 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[1]]) << 4) + ((this._alphaBlendFuncParams[2] === null ? 2 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[2]]) << 8) + ((this._alphaBlendFuncParams[3] === null ? 2 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[3]]) << 12) + ((this._alphaBlendEqParams[0] === null ? 1 : this._alphaBlendEqParams[0] - 32773) << 16) + ((this._alphaBlendEqParams[1] === null ? 1 : this._alphaBlendEqParams[1] - 32773) << 19);
    }
    if (colorStates !== this._colorStates) {
      this._colorStates = colorStates;
      this._states[StatePosition.ColorStates] = this._colorStates;
      this._isDirty = true;
      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.ColorStates);
    }
  }
  _setDepthStencilState() {
    const stencilState = !this._stencilEnabled ? 7 + (1 << 3) + (1 << 6) + (1 << 9) : this._stencilFrontCompare + (this._stencilFrontDepthFailOp << 3) + (this._stencilFrontPassOp << 6) + (this._stencilFrontFailOp << 9);
    const depthStencilState = this._depthStencilFormat + ((this._depthTestEnabled ? this._depthCompare : 7) << 6) + (stencilState << 10);
    if (this._depthStencilState !== depthStencilState) {
      this._depthStencilState = depthStencilState;
      this._states[StatePosition.DepthStencilState] = this._depthStencilState;
      this._isDirty = true;
      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.DepthStencilState);
    }
  }
  _setVertexState(effect) {
    const currStateLen = this._statesLength;
    let newNumStates = StatePosition.VertexState;
    const webgpuPipelineContext = effect._pipelineContext;
    const attributes = webgpuPipelineContext.shaderProcessingContext.attributeNamesFromEffect;
    const locations = webgpuPipelineContext.shaderProcessingContext.attributeLocationsFromEffect;
    let currentGPUBuffer;
    let numVertexBuffers = 0;
    for (let index = 0; index < attributes.length; index++) {
      const location = locations[index];
      let vertexBuffer = (this._overrideVertexBuffers && this._overrideVertexBuffers[attributes[index]]) ?? this._vertexBuffers[attributes[index]];
      if (!vertexBuffer) {
        vertexBuffer = this._emptyVertexBuffer;
        if (_WebGPUCacheRenderPipeline.LogErrorIfNoVertexBuffer) {
          Logger.Error(`No vertex buffer is provided for the "${attributes[index]}" attribute. A default empty vertex buffer will be used, but this may generate errors in some browsers.`);
        }
      }
      const buffer = vertexBuffer.effectiveBuffer?.underlyingResource;
      if (vertexBuffer._validOffsetRange === void 0) {
        const offset = vertexBuffer.effectiveByteOffset;
        const formatSize = vertexBuffer.getSize(true);
        const byteStride = vertexBuffer.effectiveByteStride;
        vertexBuffer._validOffsetRange = offset + formatSize <= this._kMaxVertexBufferStride && byteStride === 0 || byteStride !== 0 && offset + formatSize <= byteStride;
      }
      if (!(currentGPUBuffer && currentGPUBuffer === buffer && vertexBuffer._validOffsetRange)) {
        this.vertexBuffers[numVertexBuffers++] = vertexBuffer;
        currentGPUBuffer = vertexBuffer._validOffsetRange ? buffer : null;
      }
      const vid = vertexBuffer.hashCode + (location << 7);
      this._isDirty = this._isDirty || this._states[newNumStates] !== vid;
      this._states[newNumStates++] = vid;
    }
    this.vertexBuffers.length = numVertexBuffers;
    this._statesLength = newNumStates;
    this._isDirty = this._isDirty || newNumStates !== currStateLen;
    if (this._isDirty) {
      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.VertexState);
    }
  }
  _setTextureState(textureState) {
    if (this._textureState !== textureState) {
      this._textureState = textureState;
      this._states[StatePosition.TextureStage] = this._textureState;
      this._isDirty = true;
      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.TextureStage);
    }
  }
  _createPipelineLayout(webgpuPipelineContext) {
    if (this._useTextureStage) {
      return this._createPipelineLayoutWithTextureStage(webgpuPipelineContext);
    }
    const bindGroupLayouts = [];
    const bindGroupLayoutEntries = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries;
    for (let i = 0; i < bindGroupLayoutEntries.length; i++) {
      const setDefinition = bindGroupLayoutEntries[i];
      bindGroupLayouts[i] = this._device.createBindGroupLayout({
        entries: setDefinition
      });
    }
    webgpuPipelineContext.bindGroupLayouts[0] = bindGroupLayouts;
    return this._device.createPipelineLayout({ bindGroupLayouts });
  }
  _createPipelineLayoutWithTextureStage(webgpuPipelineContext) {
    const shaderProcessingContext = webgpuPipelineContext.shaderProcessingContext;
    const bindGroupLayoutEntries = shaderProcessingContext.bindGroupLayoutEntries;
    let bitVal = 1;
    for (let i = 0; i < bindGroupLayoutEntries.length; i++) {
      const setDefinition = bindGroupLayoutEntries[i];
      for (let j = 0; j < setDefinition.length; j++) {
        const entry = bindGroupLayoutEntries[i][j];
        if (entry.texture) {
          const name3 = shaderProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding].name;
          const textureInfo = shaderProcessingContext.availableTextures[name3];
          const samplerInfo = textureInfo.autoBindSampler ? shaderProcessingContext.availableSamplers[name3 + `Sampler`] : null;
          let sampleType = textureInfo.sampleType;
          let samplerType = samplerInfo?.type ?? "filtering";
          if (this._textureState & bitVal && sampleType !== "depth") {
            if (textureInfo.autoBindSampler) {
              samplerType = "non-filtering";
            }
            sampleType = "unfilterable-float";
          }
          entry.texture.sampleType = sampleType;
          if (samplerInfo) {
            const binding = shaderProcessingContext.bindGroupLayoutEntryInfo[samplerInfo.binding.groupIndex][samplerInfo.binding.bindingIndex].index;
            bindGroupLayoutEntries[samplerInfo.binding.groupIndex][binding].sampler.type = samplerType;
          }
          bitVal = bitVal << 1;
        }
      }
    }
    const bindGroupLayouts = [];
    for (let i = 0; i < bindGroupLayoutEntries.length; ++i) {
      bindGroupLayouts[i] = this._device.createBindGroupLayout({
        entries: bindGroupLayoutEntries[i]
      });
    }
    webgpuPipelineContext.bindGroupLayouts[this._textureState] = bindGroupLayouts;
    return this._device.createPipelineLayout({ bindGroupLayouts });
  }
  _getVertexInputDescriptor(effect) {
    const descriptors = [];
    const webgpuPipelineContext = effect._pipelineContext;
    const attributes = webgpuPipelineContext.shaderProcessingContext.attributeNamesFromEffect;
    const locations = webgpuPipelineContext.shaderProcessingContext.attributeLocationsFromEffect;
    let currentGPUBuffer;
    let currentGPUAttributes;
    for (let index = 0; index < attributes.length; index++) {
      const location = locations[index];
      let vertexBuffer = (this._overrideVertexBuffers && this._overrideVertexBuffers[attributes[index]]) ?? this._vertexBuffers[attributes[index]];
      if (!vertexBuffer) {
        vertexBuffer = this._emptyVertexBuffer;
      }
      let buffer = vertexBuffer.effectiveBuffer?.underlyingResource;
      let offset = vertexBuffer.effectiveByteOffset;
      const invalidOffsetRange = !vertexBuffer._validOffsetRange;
      if (!(currentGPUBuffer && currentGPUAttributes && currentGPUBuffer === buffer) || invalidOffsetRange) {
        const vertexBufferDescriptor = {
          arrayStride: vertexBuffer.effectiveByteStride,
          stepMode: vertexBuffer.getIsInstanced() ? "instance" : "vertex",
          attributes: []
        };
        descriptors.push(vertexBufferDescriptor);
        currentGPUAttributes = vertexBufferDescriptor.attributes;
        if (invalidOffsetRange) {
          offset = 0;
          buffer = null;
        }
      }
      currentGPUAttributes.push({
        shaderLocation: location,
        offset,
        format: _WebGPUCacheRenderPipeline._GetVertexInputDescriptorFormat(vertexBuffer)
      });
      currentGPUBuffer = buffer;
    }
    return descriptors;
  }
  _createRenderPipeline(effect, topology, sampleCount) {
    const webgpuPipelineContext = effect._pipelineContext;
    const inputStateDescriptor = this._getVertexInputDescriptor(effect);
    const pipelineLayout = this._createPipelineLayout(webgpuPipelineContext);
    const colorStates = [];
    const alphaBlend = this._getAphaBlendState();
    const colorBlend = this._getColorBlendState();
    if (this._vertexBuffers) {
      checkNonFloatVertexBuffers(this._vertexBuffers, effect);
    }
    if (this._mrtAttachments1 > 0) {
      for (let i = 0; i < this._mrtFormats.length; ++i) {
        const format = this._mrtFormats[i];
        if (format) {
          const descr = {
            format,
            writeMask: (this._mrtEnabledMask & 1 << i) !== 0 ? this._writeMask : 0
          };
          if (alphaBlend && colorBlend) {
            descr.blend = {
              alpha: alphaBlend,
              color: colorBlend
            };
          }
          colorStates.push(descr);
        } else {
          colorStates.push(null);
        }
      }
    } else {
      if (this._webgpuColorFormat[0]) {
        const descr = {
          format: this._webgpuColorFormat[0],
          writeMask: this._writeMask
        };
        if (alphaBlend && colorBlend) {
          descr.blend = {
            alpha: alphaBlend,
            color: colorBlend
          };
        }
        colorStates.push(descr);
      } else {
        colorStates.push(null);
      }
    }
    const stencilFrontBack = {
      compare: _WebGPUCacheRenderPipeline._GetCompareFunction(
        this._stencilEnabled ? this._stencilFrontCompare : 7
        /* ALWAYS */
      ),
      depthFailOp: _WebGPUCacheRenderPipeline._GetStencilOpFunction(
        this._stencilEnabled ? this._stencilFrontDepthFailOp : 1
        /* KEEP */
      ),
      failOp: _WebGPUCacheRenderPipeline._GetStencilOpFunction(
        this._stencilEnabled ? this._stencilFrontFailOp : 1
        /* KEEP */
      ),
      passOp: _WebGPUCacheRenderPipeline._GetStencilOpFunction(
        this._stencilEnabled ? this._stencilFrontPassOp : 1
        /* KEEP */
      )
    };
    const topologyIsTriangle = topology === "triangle-list" || topology === "triangle-strip";
    let stripIndexFormat = void 0;
    if (topology === "line-strip" || topology === "triangle-strip") {
      stripIndexFormat = !this._indexBuffer || this._indexBuffer.is32Bits ? "uint32" : "uint16";
    }
    const depthStencilFormatHasStencil = this._webgpuDepthStencilFormat ? WebGPUTextureHelper.HasStencilAspect(this._webgpuDepthStencilFormat) : false;
    return this._device.createRenderPipeline({
      label: `RenderPipeline_${colorStates[0]?.format ?? "nooutput"}_${this._webgpuDepthStencilFormat ?? "nodepth"}_samples${sampleCount}_textureState${this._textureState}`,
      layout: pipelineLayout,
      vertex: {
        module: webgpuPipelineContext.stages.vertexStage.module,
        entryPoint: webgpuPipelineContext.stages.vertexStage.entryPoint,
        buffers: inputStateDescriptor
      },
      primitive: {
        topology,
        stripIndexFormat,
        frontFace: this._frontFace === 1 ? "ccw" : "cw",
        cullMode: !this._cullEnabled ? "none" : this._cullFace === 2 ? "front" : "back"
      },
      fragment: !webgpuPipelineContext.stages.fragmentStage ? void 0 : {
        module: webgpuPipelineContext.stages.fragmentStage.module,
        entryPoint: webgpuPipelineContext.stages.fragmentStage.entryPoint,
        targets: colorStates
      },
      multisample: {
        count: sampleCount
        /*mask,
        alphaToCoverageEnabled,*/
      },
      depthStencil: this._webgpuDepthStencilFormat === void 0 ? void 0 : {
        depthWriteEnabled: this._depthWriteEnabled,
        depthCompare: this._depthTestEnabled ? _WebGPUCacheRenderPipeline._GetCompareFunction(this._depthCompare) : "always",
        format: this._webgpuDepthStencilFormat,
        stencilFront: this._stencilEnabled && depthStencilFormatHasStencil ? stencilFrontBack : void 0,
        stencilBack: this._stencilEnabled && depthStencilFormatHasStencil ? stencilFrontBack : void 0,
        stencilReadMask: this._stencilEnabled && depthStencilFormatHasStencil ? this._stencilReadMask : void 0,
        stencilWriteMask: this._stencilEnabled && depthStencilFormatHasStencil ? this._stencilWriteMask : void 0,
        depthBias: this._depthBias,
        depthBiasClamp: topologyIsTriangle ? this._depthBiasClamp : 0,
        depthBiasSlopeScale: topologyIsTriangle ? this._depthBiasSlopeScale : 0
      }
    });
  }
};
WebGPUCacheRenderPipeline.LogErrorIfNoVertexBuffer = false;
WebGPUCacheRenderPipeline.NumCacheHitWithoutHash = 0;
WebGPUCacheRenderPipeline.NumCacheHitWithHash = 0;
WebGPUCacheRenderPipeline.NumCacheMiss = 0;
WebGPUCacheRenderPipeline.NumPipelineCreationLastFrame = 0;
WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame = 0;

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuCacheRenderPipelineTree.js
var NodeState = class {
  constructor() {
    this.values = {};
  }
  count() {
    let countNode = 0, countPipeline = this.pipeline ? 1 : 0;
    for (const value in this.values) {
      const node = this.values[value];
      const [childCountNodes, childCoundPipeline] = node.count();
      countNode += childCountNodes;
      countPipeline += childCoundPipeline;
      countNode++;
    }
    return [countNode, countPipeline];
  }
};
var WebGPUCacheRenderPipelineTree = class _WebGPUCacheRenderPipelineTree extends WebGPUCacheRenderPipeline {
  static GetNodeCounts() {
    const counts = _WebGPUCacheRenderPipelineTree._Cache.count();
    return { nodeCount: counts[0], pipelineCount: counts[1] };
  }
  static _GetPipelines(node, pipelines, curPath, curPathLen) {
    if (node.pipeline) {
      const path = curPath.slice();
      path.length = curPathLen;
      pipelines.push(path);
    }
    for (const value in node.values) {
      const nnode = node.values[value];
      curPath[curPathLen] = parseInt(value);
      _WebGPUCacheRenderPipelineTree._GetPipelines(nnode, pipelines, curPath, curPathLen + 1);
    }
  }
  static GetPipelines() {
    const pipelines = [];
    _WebGPUCacheRenderPipelineTree._GetPipelines(_WebGPUCacheRenderPipelineTree._Cache, pipelines, [], 0);
    return pipelines;
  }
  static ResetCache() {
    _WebGPUCacheRenderPipelineTree._Cache = new NodeState();
  }
  reset() {
    this._nodeStack = [];
    this._nodeStack[0] = _WebGPUCacheRenderPipelineTree._Cache;
    super.reset();
  }
  _getRenderPipeline(param) {
    let node = this._nodeStack[this._stateDirtyLowestIndex];
    for (let i = this._stateDirtyLowestIndex; i < this._statesLength; ++i) {
      let nn = node.values[this._states[i]];
      if (!nn) {
        nn = new NodeState();
        node.values[this._states[i]] = nn;
      }
      node = nn;
      this._nodeStack[i + 1] = node;
    }
    param.token = node;
    param.pipeline = node.pipeline;
  }
  _setRenderPipeline(param) {
    param.token.pipeline = param.pipeline;
  }
};
WebGPUCacheRenderPipelineTree._Cache = new NodeState();

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuStencilStateComposer.js
var WebGPUStencilStateComposer = class extends StencilStateComposer {
  constructor(cache) {
    super(false);
    this._cache = cache;
    this.reset();
  }
  get func() {
    return this._func;
  }
  set func(value) {
    if (this._func === value) {
      return;
    }
    this._func = value;
    this._cache.setStencilCompare(value);
  }
  get funcMask() {
    return this._funcMask;
  }
  set funcMask(value) {
    if (this._funcMask === value) {
      return;
    }
    this._funcMask = value;
    this._cache.setStencilReadMask(value);
  }
  get opStencilFail() {
    return this._opStencilFail;
  }
  set opStencilFail(value) {
    if (this._opStencilFail === value) {
      return;
    }
    this._opStencilFail = value;
    this._cache.setStencilFailOp(value);
  }
  get opDepthFail() {
    return this._opDepthFail;
  }
  set opDepthFail(value) {
    if (this._opDepthFail === value) {
      return;
    }
    this._opDepthFail = value;
    this._cache.setStencilDepthFailOp(value);
  }
  get opStencilDepthPass() {
    return this._opStencilDepthPass;
  }
  set opStencilDepthPass(value) {
    if (this._opStencilDepthPass === value) {
      return;
    }
    this._opStencilDepthPass = value;
    this._cache.setStencilPassOp(value);
  }
  get mask() {
    return this._mask;
  }
  set mask(value) {
    if (this._mask === value) {
      return;
    }
    this._mask = value;
    this._cache.setStencilWriteMask(value);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled === value) {
      return;
    }
    this._enabled = value;
    this._cache.setStencilEnabled(value);
  }
  reset() {
    super.reset();
    this._cache.resetStencilState();
  }
  apply() {
    const stencilMaterialEnabled = this.stencilMaterial?.enabled;
    this.enabled = stencilMaterialEnabled ? this.stencilMaterial.enabled : this.stencilGlobal.enabled;
    if (!this.enabled) {
      return;
    }
    this.func = stencilMaterialEnabled ? this.stencilMaterial.func : this.stencilGlobal.func;
    this.funcRef = stencilMaterialEnabled ? this.stencilMaterial.funcRef : this.stencilGlobal.funcRef;
    this.funcMask = stencilMaterialEnabled ? this.stencilMaterial.funcMask : this.stencilGlobal.funcMask;
    this.opStencilFail = stencilMaterialEnabled ? this.stencilMaterial.opStencilFail : this.stencilGlobal.opStencilFail;
    this.opDepthFail = stencilMaterialEnabled ? this.stencilMaterial.opDepthFail : this.stencilGlobal.opDepthFail;
    this.opStencilDepthPass = stencilMaterialEnabled ? this.stencilMaterial.opStencilDepthPass : this.stencilGlobal.opStencilDepthPass;
    this.mask = stencilMaterialEnabled ? this.stencilMaterial.mask : this.stencilGlobal.mask;
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuDepthCullingState.js
var WebGPUDepthCullingState = class extends DepthCullingState {
  /**
   * Initializes the state.
   * @param cache
   */
  constructor(cache) {
    super(false);
    this._cache = cache;
    this.reset();
  }
  get zOffset() {
    return this._zOffset;
  }
  set zOffset(value) {
    if (this._zOffset === value) {
      return;
    }
    this._zOffset = value;
    this._isZOffsetDirty = true;
    this._cache.setDepthBiasSlopeScale(value);
  }
  get zOffsetUnits() {
    return this._zOffsetUnits;
  }
  set zOffsetUnits(value) {
    if (this._zOffsetUnits === value) {
      return;
    }
    this._zOffsetUnits = value;
    this._isZOffsetDirty = true;
    this._cache.setDepthBias(value);
  }
  get cullFace() {
    return this._cullFace;
  }
  set cullFace(value) {
    if (this._cullFace === value) {
      return;
    }
    this._cullFace = value;
    this._isCullFaceDirty = true;
    this._cache.setCullFace(value ?? 1);
  }
  get cull() {
    return this._cull;
  }
  set cull(value) {
    if (this._cull === value) {
      return;
    }
    this._cull = value;
    this._isCullDirty = true;
    this._cache.setCullEnabled(!!value);
  }
  get depthFunc() {
    return this._depthFunc;
  }
  set depthFunc(value) {
    if (this._depthFunc === value) {
      return;
    }
    this._depthFunc = value;
    this._isDepthFuncDirty = true;
    this._cache.setDepthCompare(value);
  }
  get depthMask() {
    return this._depthMask;
  }
  set depthMask(value) {
    if (this._depthMask === value) {
      return;
    }
    this._depthMask = value;
    this._isDepthMaskDirty = true;
    this._cache.setDepthWriteEnabled(value);
  }
  get depthTest() {
    return this._depthTest;
  }
  set depthTest(value) {
    if (this._depthTest === value) {
      return;
    }
    this._depthTest = value;
    this._isDepthTestDirty = true;
    this._cache.setDepthTestEnabled(value);
  }
  get frontFace() {
    return this._frontFace;
  }
  set frontFace(value) {
    if (this._frontFace === value) {
      return;
    }
    this._frontFace = value;
    this._isFrontFaceDirty = true;
    this._cache.setFrontFace(value ?? 2);
  }
  reset() {
    super.reset();
    this._cache.resetDepthCullingState();
  }
  apply() {
  }
};

// node_modules/@babylonjs/core/Materials/Textures/externalTexture.js
var ExternalTexture = class {
  /**
   * Checks if a texture is an external or internal texture
   * @param texture the external or internal texture
   * @returns true if the texture is an external texture, else false
   */
  static IsExternalTexture(texture) {
    return texture.underlyingResource !== void 0;
  }
  /**
   * Get the class name of the texture.
   * @returns "ExternalTexture"
   */
  getClassName() {
    return "ExternalTexture";
  }
  /**
   * Gets the underlying texture object
   */
  get underlyingResource() {
    return this._video;
  }
  /**
   * Constructs the texture
   * @param video The video the texture should be wrapped around
   */
  constructor(video) {
    this.useMipMaps = false;
    this.type = 16;
    this.format = 4294967295;
    this._video = video;
    this.uniqueId = InternalTexture._Counter++;
  }
  /**
   * Get if the texture is ready to be used (downloaded, converted, mip mapped...).
   * @returns true if fully ready
   */
  isReady() {
    return this._video.readyState >= this._video.HAVE_CURRENT_DATA;
  }
  /**
   * Dispose the texture and release its associated resources.
   */
  dispose() {
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuMaterialContext.js
var WebGPUMaterialContext = class _WebGPUMaterialContext {
  get forceBindGroupCreation() {
    return this._numExternalTextures > 0;
  }
  get hasFloatOrDepthTextures() {
    return this._numFloatOrDepthTextures > 0;
  }
  constructor() {
    this.uniqueId = _WebGPUMaterialContext._Counter++;
    this.updateId = 0;
    this.textureState = 0;
    this.reset();
  }
  reset() {
    this.samplers = {};
    this.textures = {};
    this.isDirty = true;
    this._numFloatOrDepthTextures = 0;
    this._numExternalTextures = 0;
  }
  setSampler(name3, sampler) {
    let samplerCache = this.samplers[name3];
    let currentHashCode = -1;
    if (!samplerCache) {
      this.samplers[name3] = samplerCache = { sampler, hashCode: 0 };
    } else {
      currentHashCode = samplerCache.hashCode;
    }
    samplerCache.sampler = sampler;
    samplerCache.hashCode = sampler ? WebGPUCacheSampler.GetSamplerHashCode(sampler) : 0;
    const isDirty = currentHashCode !== samplerCache.hashCode;
    if (isDirty) {
      this.updateId++;
    }
    this.isDirty || (this.isDirty = isDirty);
  }
  setTexture(name3, texture) {
    let textureCache = this.textures[name3];
    let currentTextureId = -1;
    if (!textureCache) {
      this.textures[name3] = textureCache = { texture, isFloatOrDepthTexture: false, isExternalTexture: false };
    } else {
      currentTextureId = textureCache.texture?.uniqueId ?? -1;
    }
    if (textureCache.isExternalTexture) {
      this._numExternalTextures--;
    }
    if (textureCache.isFloatOrDepthTexture) {
      this._numFloatOrDepthTextures--;
    }
    if (texture) {
      textureCache.isFloatOrDepthTexture = texture.type === 1 || texture.format >= 13 && texture.format <= 18;
      textureCache.isExternalTexture = ExternalTexture.IsExternalTexture(texture);
      if (textureCache.isFloatOrDepthTexture) {
        this._numFloatOrDepthTextures++;
      }
      if (textureCache.isExternalTexture) {
        this._numExternalTextures++;
      }
    } else {
      textureCache.isFloatOrDepthTexture = false;
      textureCache.isExternalTexture = false;
    }
    textureCache.texture = texture;
    const isDirty = currentTextureId !== (texture?.uniqueId ?? -1);
    if (isDirty) {
      this.updateId++;
    }
    this.isDirty || (this.isDirty = isDirty);
  }
};
WebGPUMaterialContext._Counter = 0;

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuDrawContext.js
var WebGPUDrawContext = class _WebGPUDrawContext {
  isDirty(materialContextUpdateId) {
    return this._isDirty || this._materialContextUpdateId !== materialContextUpdateId;
  }
  resetIsDirty(materialContextUpdateId) {
    this._isDirty = false;
    this._materialContextUpdateId = materialContextUpdateId;
  }
  get useInstancing() {
    return this._useInstancing;
  }
  set useInstancing(use) {
    if (this._useInstancing === use) {
      return;
    }
    if (!use) {
      if (this.indirectDrawBuffer) {
        this._bufferManager.releaseBuffer(this.indirectDrawBuffer);
      }
      this.indirectDrawBuffer = void 0;
      this._indirectDrawData = void 0;
    } else {
      this.indirectDrawBuffer = this._bufferManager.createRawBuffer(20, BufferUsage.CopyDst | BufferUsage.Indirect | BufferUsage.Storage, void 0, "IndirectDrawBuffer");
      this._indirectDrawData = new Uint32Array(5);
      this._indirectDrawData[3] = 0;
      this._indirectDrawData[4] = 0;
    }
    this._useInstancing = use;
    this._currentInstanceCount = -1;
  }
  constructor(bufferManager) {
    this._bufferManager = bufferManager;
    this.uniqueId = _WebGPUDrawContext._Counter++;
    this._useInstancing = false;
    this._currentInstanceCount = 0;
    this.reset();
  }
  reset() {
    this.buffers = {};
    this._isDirty = true;
    this._materialContextUpdateId = 0;
    this.fastBundle = void 0;
    this.bindGroups = void 0;
  }
  setBuffer(name3, buffer) {
    this._isDirty || (this._isDirty = buffer?.uniqueId !== this.buffers[name3]?.uniqueId);
    this.buffers[name3] = buffer;
  }
  setIndirectData(indexOrVertexCount, instanceCount, firstIndexOrVertex) {
    if (instanceCount === this._currentInstanceCount || !this.indirectDrawBuffer || !this._indirectDrawData) {
      return;
    }
    this._currentInstanceCount = instanceCount;
    this._indirectDrawData[0] = indexOrVertexCount;
    this._indirectDrawData[1] = instanceCount;
    this._indirectDrawData[2] = firstIndexOrVertex;
    this._bufferManager.setRawData(this.indirectDrawBuffer, 0, this._indirectDrawData, 0, 20);
  }
  dispose() {
    if (this.indirectDrawBuffer) {
      this._bufferManager.releaseBuffer(this.indirectDrawBuffer);
      this.indirectDrawBuffer = void 0;
      this._indirectDrawData = void 0;
    }
    this.fastBundle = void 0;
    this.bindGroups = void 0;
    this.buffers = void 0;
  }
};
WebGPUDrawContext._Counter = 0;

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuCacheBindGroups.js
var bufferIdStart = 1 << 20;
var textureIdStart = 2 ** 35;
var WebGPUBindGroupCacheNode = class {
  constructor() {
    this.values = {};
  }
};
var WebGPUCacheBindGroups = class _WebGPUCacheBindGroups {
  static get Statistics() {
    return {
      totalCreated: _WebGPUCacheBindGroups.NumBindGroupsCreatedTotal,
      lastFrameCreated: _WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame,
      lookupLastFrame: _WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame,
      noLookupLastFrame: _WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame
    };
  }
  static ResetCache() {
    _WebGPUCacheBindGroups._Cache = new WebGPUBindGroupCacheNode();
    _WebGPUCacheBindGroups.NumBindGroupsCreatedTotal = 0;
    _WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame = 0;
    _WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame = 0;
    _WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame = 0;
    _WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame = 0;
    _WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame = 0;
    _WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame = 0;
  }
  constructor(device, cacheSampler, engine) {
    this.disabled = false;
    this._device = device;
    this._cacheSampler = cacheSampler;
    this._engine = engine;
  }
  endFrame() {
    _WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame = _WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame;
    _WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame = _WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame;
    _WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame = _WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame;
    _WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame = 0;
    _WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame = 0;
    _WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame = 0;
  }
  /**
   * Cache is currently based on the uniform/storage buffers, samplers and textures used by the binding groups.
   * Note that all uniform buffers have an offset of 0 in Babylon and we don't have a use case where we would have the same buffer used with different capacity values:
   * that means we don't need to factor in the offset/size of the buffer in the cache, only the id
   * @param webgpuPipelineContext
   * @param drawContext
   * @param materialContext
   * @returns a bind group array
   */
  getBindGroups(webgpuPipelineContext, drawContext, materialContext) {
    let bindGroups = void 0;
    let node = _WebGPUCacheBindGroups._Cache;
    const cacheIsDisabled = this.disabled || materialContext.forceBindGroupCreation;
    if (!cacheIsDisabled) {
      if (!drawContext.isDirty(materialContext.updateId) && !materialContext.isDirty) {
        _WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame++;
        return drawContext.bindGroups;
      }
      for (const bufferName of webgpuPipelineContext.shaderProcessingContext.bufferNames) {
        const uboId = (drawContext.buffers[bufferName]?.uniqueId ?? 0) + bufferIdStart;
        let nextNode = node.values[uboId];
        if (!nextNode) {
          nextNode = new WebGPUBindGroupCacheNode();
          node.values[uboId] = nextNode;
        }
        node = nextNode;
      }
      for (const samplerName of webgpuPipelineContext.shaderProcessingContext.samplerNames) {
        const samplerHashCode = materialContext.samplers[samplerName]?.hashCode ?? 0;
        let nextNode = node.values[samplerHashCode];
        if (!nextNode) {
          nextNode = new WebGPUBindGroupCacheNode();
          node.values[samplerHashCode] = nextNode;
        }
        node = nextNode;
      }
      for (const textureName of webgpuPipelineContext.shaderProcessingContext.textureNames) {
        const textureId = (materialContext.textures[textureName]?.texture?.uniqueId ?? 0) + textureIdStart;
        let nextNode = node.values[textureId];
        if (!nextNode) {
          nextNode = new WebGPUBindGroupCacheNode();
          node.values[textureId] = nextNode;
        }
        node = nextNode;
      }
      bindGroups = node.bindGroups;
    }
    drawContext.resetIsDirty(materialContext.updateId);
    materialContext.isDirty = false;
    if (bindGroups) {
      drawContext.bindGroups = bindGroups;
      _WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame++;
      return bindGroups;
    }
    bindGroups = [];
    drawContext.bindGroups = bindGroups;
    if (!cacheIsDisabled) {
      node.bindGroups = bindGroups;
    }
    _WebGPUCacheBindGroups.NumBindGroupsCreatedTotal++;
    _WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame++;
    const bindGroupLayouts = webgpuPipelineContext.bindGroupLayouts[materialContext.textureState];
    for (let i = 0; i < webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries.length; i++) {
      const setDefinition = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries[i];
      const entries = webgpuPipelineContext.shaderProcessingContext.bindGroupEntries[i];
      for (let j = 0; j < setDefinition.length; j++) {
        const entry = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries[i][j];
        const entryInfo = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding];
        const name3 = entryInfo.nameInArrayOfTexture ?? entryInfo.name;
        if (entry.sampler) {
          const bindingInfo = materialContext.samplers[name3];
          if (bindingInfo) {
            const sampler = bindingInfo.sampler;
            if (!sampler) {
              if (this._engine.dbgSanityChecks) {
                Logger.Error(`Trying to bind a null sampler! entry=${JSON.stringify(entry)}, name=${name3}, bindingInfo=${JSON.stringify(bindingInfo, (key, value) => key === "texture" ? "<no dump>" : value)}, materialContext.uniqueId=${materialContext.uniqueId}`, 50);
              }
              continue;
            }
            entries[j].resource = this._cacheSampler.getSampler(sampler, false, bindingInfo.hashCode, sampler.label);
          } else {
            Logger.Error(`Sampler "${name3}" could not be bound. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(materialContext, (key, value) => key === "texture" || key === "sampler" ? "<no dump>" : value)}`, 50);
          }
        } else if (entry.texture || entry.storageTexture) {
          const bindingInfo = materialContext.textures[name3];
          if (bindingInfo) {
            if (this._engine.dbgSanityChecks && bindingInfo.texture === null) {
              Logger.Error(`Trying to bind a null texture! entry=${JSON.stringify(entry)}, bindingInfo=${JSON.stringify(bindingInfo, (key, value) => key === "texture" ? "<no dump>" : value)}, materialContext.uniqueId=${materialContext.uniqueId}`, 50);
              continue;
            }
            const hardwareTexture = bindingInfo.texture._hardwareTexture;
            if (this._engine.dbgSanityChecks && (!hardwareTexture || entry.texture && !hardwareTexture.view || entry.storageTexture && !hardwareTexture.viewForWriting)) {
              Logger.Error(`Trying to bind a null gpu texture or view! entry=${JSON.stringify(entry)}, name=${name3}, bindingInfo=${JSON.stringify(bindingInfo, (key, value) => key === "texture" ? "<no dump>" : value)}, isReady=${bindingInfo.texture?.isReady}, materialContext.uniqueId=${materialContext.uniqueId}`, 50);
              continue;
            }
            entries[j].resource = entry.storageTexture ? hardwareTexture.viewForWriting : hardwareTexture.view;
          } else {
            Logger.Error(`Texture "${name3}" could not be bound. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(materialContext, (key, value) => key === "texture" || key === "sampler" ? "<no dump>" : value)}`, 50);
          }
        } else if (entry.externalTexture) {
          const bindingInfo = materialContext.textures[name3];
          if (bindingInfo) {
            if (this._engine.dbgSanityChecks && bindingInfo.texture === null) {
              Logger.Error(`Trying to bind a null external texture! entry=${JSON.stringify(entry)}, name=${name3}, bindingInfo=${JSON.stringify(bindingInfo, (key, value) => key === "texture" ? "<no dump>" : value)}, materialContext.uniqueId=${materialContext.uniqueId}`, 50);
              continue;
            }
            const externalTexture = bindingInfo.texture.underlyingResource;
            if (this._engine.dbgSanityChecks && !externalTexture) {
              Logger.Error(`Trying to bind a null gpu external texture! entry=${JSON.stringify(entry)}, name=${name3}, bindingInfo=${JSON.stringify(bindingInfo, (key, value) => key === "texture" ? "<no dump>" : value)}, isReady=${bindingInfo.texture?.isReady}, materialContext.uniqueId=${materialContext.uniqueId}`, 50);
              continue;
            }
            entries[j].resource = this._device.importExternalTexture({ source: externalTexture });
          } else {
            Logger.Error(`Texture "${name3}" could not be bound. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(materialContext, (key, value) => key === "texture" || key === "sampler" ? "<no dump>" : value)}`, 50);
          }
        } else if (entry.buffer) {
          const dataBuffer = drawContext.buffers[name3];
          if (dataBuffer) {
            const webgpuBuffer = dataBuffer.underlyingResource;
            entries[j].resource.buffer = webgpuBuffer;
            entries[j].resource.size = dataBuffer.capacity;
          } else {
            Logger.Error(`Can't find buffer "${name3}". entry=${JSON.stringify(entry)}, buffers=${JSON.stringify(drawContext.buffers)}, drawContext.uniqueId=${drawContext.uniqueId}`, 50);
          }
        }
      }
      const groupLayout = bindGroupLayouts[i];
      bindGroups[i] = this._device.createBindGroup({
        layout: groupLayout,
        entries
      });
    }
    return bindGroups;
  }
};
WebGPUCacheBindGroups.NumBindGroupsCreatedTotal = 0;
WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame = 0;
WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame = 0;
WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame = 0;
WebGPUCacheBindGroups._Cache = new WebGPUBindGroupCacheNode();
WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame = 0;
WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame = 0;
WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame = 0;

// node_modules/@babylonjs/core/ShadersWGSL/clearQuad.vertex.js
var name = "clearQuadVertexShader";
var shader = `uniform depthValue: f32;const pos=array(
vec2f(-1.0,1.0),
vec2f(1.0,1.0),
vec2f(-1.0,-1.0),
vec2f(1.0,-1.0)
);
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {
#define CUSTOM_VERTEX_MAIN_BEGIN
vertexOutputs.position=vec4f(pos[input.vertexIndex],uniforms.depthValue,1.0);
#define CUSTOM_VERTEX_MAIN_END
}
`;
if (!ShaderStore.ShadersStoreWGSL[name]) {
  ShaderStore.ShadersStoreWGSL[name] = shader;
}

// node_modules/@babylonjs/core/ShadersWGSL/clearQuad.fragment.js
var name2 = "clearQuadPixelShader";
var shader2 = `uniform color: vec4f;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=uniforms.color;}
`;
if (!ShaderStore.ShadersStoreWGSL[name2]) {
  ShaderStore.ShadersStoreWGSL[name2] = shader2;
}

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuClearQuad.js
var WebGPUClearQuad = class {
  setDepthStencilFormat(format) {
    this._depthTextureFormat = format;
    this._cacheRenderPipeline.setDepthStencilFormat(format);
  }
  setColorFormat(format) {
    this._cacheRenderPipeline.setColorFormat(format);
  }
  setMRTAttachments(attachments, textureArray, textureCount) {
    this._cacheRenderPipeline.setMRT(textureArray, textureCount);
    this._cacheRenderPipeline.setMRTAttachments(attachments);
  }
  constructor(device, engine, emptyVertexBuffer) {
    this._bindGroups = {};
    this._bundleCache = {};
    this._keyTemp = [];
    this._device = device;
    this._engine = engine;
    this._cacheRenderPipeline = new WebGPUCacheRenderPipelineTree(this._device, emptyVertexBuffer);
    this._cacheRenderPipeline.setDepthTestEnabled(false);
    this._cacheRenderPipeline.setStencilReadMask(255);
    this._effect = engine.createEffect(
      "clearQuad",
      [],
      ["color", "depthValue"],
      void 0,
      void 0,
      void 0,
      void 0,
      void 0,
      void 0,
      1
      /* ShaderLanguage.WGSL */
    );
  }
  clear(renderPass, clearColor, clearDepth, clearStencil, sampleCount = 1) {
    let renderPass2;
    let bundle = null;
    let bundleKey;
    const isRTTPass = !!this._engine._currentRenderTarget;
    if (renderPass) {
      renderPass2 = renderPass;
    } else {
      let idx = 0;
      this._keyTemp.length = 0;
      for (let i = 0; i < this._cacheRenderPipeline.colorFormats.length; ++i) {
        this._keyTemp[idx++] = renderableTextureFormatToIndex[this._cacheRenderPipeline.colorFormats[i] ?? ""];
      }
      const depthStencilFormatIndex = renderableTextureFormatToIndex[this._depthTextureFormat ?? 0];
      this._keyTemp[idx] = (clearColor ? clearColor.r + clearColor.g * 256 + clearColor.b * 256 * 256 + clearColor.a * 256 * 256 * 256 : 0) + (clearDepth ? 2 ** 32 : 0) + (clearStencil ? 2 ** 33 : 0) + (this._engine.useReverseDepthBuffer ? 2 ** 34 : 0) + (isRTTPass ? 2 ** 35 : 0) + (sampleCount > 1 ? 2 ** 36 : 0) + depthStencilFormatIndex * 2 ** 37;
      bundleKey = this._keyTemp.join("_");
      bundle = this._bundleCache[bundleKey];
      if (bundle) {
        return bundle;
      }
      renderPass2 = this._device.createRenderBundleEncoder({
        label: "clearQuadRenderBundle",
        colorFormats: this._cacheRenderPipeline.colorFormats,
        depthStencilFormat: this._depthTextureFormat,
        sampleCount: WebGPUTextureHelper.GetSample(sampleCount)
      });
    }
    this._cacheRenderPipeline.setDepthWriteEnabled(!!clearDepth);
    this._cacheRenderPipeline.setStencilEnabled(!!clearStencil && !!this._depthTextureFormat && WebGPUTextureHelper.HasStencilAspect(this._depthTextureFormat));
    this._cacheRenderPipeline.setStencilWriteMask(clearStencil ? 255 : 0);
    this._cacheRenderPipeline.setStencilCompare(clearStencil ? 519 : 512);
    this._cacheRenderPipeline.setStencilPassOp(clearStencil ? 7681 : 7680);
    this._cacheRenderPipeline.setWriteMask(clearColor ? 15 : 0);
    const pipeline = this._cacheRenderPipeline.getRenderPipeline(7, this._effect, sampleCount);
    const webgpuPipelineContext = this._effect._pipelineContext;
    if (clearColor) {
      this._effect.setDirectColor4("color", clearColor);
    }
    this._effect.setFloat("depthValue", this._engine.useReverseDepthBuffer ? this._engine._clearReverseDepthValue : this._engine._clearDepthValue);
    webgpuPipelineContext.uniformBuffer.update();
    const bufferInternals = isRTTPass ? this._engine._ubInvertY : this._engine._ubDontInvertY;
    const bufferLeftOver = webgpuPipelineContext.uniformBuffer.getBuffer();
    const key = bufferLeftOver.uniqueId + "-" + bufferInternals.uniqueId;
    let bindGroups = this._bindGroups[key];
    if (!bindGroups) {
      const bindGroupLayouts = webgpuPipelineContext.bindGroupLayouts[0];
      bindGroups = this._bindGroups[key] = [];
      bindGroups.push(this._device.createBindGroup({
        label: `clearQuadBindGroup0-${key}`,
        layout: bindGroupLayouts[0],
        entries: []
      }));
      if (!WebGPUShaderProcessingContext._SimplifiedKnownBindings) {
        bindGroups.push(this._device.createBindGroup({
          label: `clearQuadBindGroup1-${key}`,
          layout: bindGroupLayouts[1],
          entries: []
        }));
      }
      bindGroups.push(this._device.createBindGroup({
        label: `clearQuadBindGroup${WebGPUShaderProcessingContext._SimplifiedKnownBindings ? 1 : 2}-${key}`,
        layout: bindGroupLayouts[WebGPUShaderProcessingContext._SimplifiedKnownBindings ? 1 : 2],
        entries: [
          {
            binding: 0,
            resource: {
              buffer: bufferInternals.underlyingResource,
              size: bufferInternals.capacity
            }
          },
          {
            binding: 1,
            resource: {
              buffer: bufferLeftOver.underlyingResource,
              size: bufferLeftOver.capacity
            }
          }
        ]
      }));
    }
    renderPass2.setPipeline(pipeline);
    for (let i = 0; i < bindGroups.length; ++i) {
      renderPass2.setBindGroup(i, bindGroups[i]);
    }
    renderPass2.draw(4, 1, 0, 0);
    if (!renderPass) {
      bundle = renderPass2.finish();
      this._bundleCache[bundleKey] = bundle;
    }
    return bundle;
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuBundleList.js
var WebGPURenderItemViewport = class _WebGPURenderItemViewport {
  constructor(x, y, w, h) {
    this.x = Math.floor(x);
    this.y = Math.floor(y);
    this.w = Math.floor(w);
    this.h = Math.floor(h);
  }
  run(renderPass) {
    renderPass.setViewport(this.x, this.y, this.w, this.h, 0, 1);
  }
  clone() {
    return new _WebGPURenderItemViewport(this.x, this.y, this.w, this.h);
  }
};
var WebGPURenderItemScissor = class _WebGPURenderItemScissor {
  constructor(x, y, w, h) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }
  run(renderPass) {
    renderPass.setScissorRect(this.x, this.y, this.w, this.h);
  }
  clone() {
    return new _WebGPURenderItemScissor(this.x, this.y, this.w, this.h);
  }
};
var WebGPURenderItemStencilRef = class _WebGPURenderItemStencilRef {
  constructor(ref) {
    this.ref = ref;
  }
  run(renderPass) {
    renderPass.setStencilReference(this.ref);
  }
  clone() {
    return new _WebGPURenderItemStencilRef(this.ref);
  }
};
var WebGPURenderItemBlendColor = class _WebGPURenderItemBlendColor {
  constructor(color) {
    this.color = color;
  }
  run(renderPass) {
    renderPass.setBlendConstant(this.color);
  }
  clone() {
    return new _WebGPURenderItemBlendColor(this.color);
  }
};
var WebGPURenderItemBeginOcclusionQuery = class _WebGPURenderItemBeginOcclusionQuery {
  constructor(query) {
    this.query = query;
  }
  run(renderPass) {
    renderPass.beginOcclusionQuery(this.query);
  }
  clone() {
    return new _WebGPURenderItemBeginOcclusionQuery(this.query);
  }
};
var WebGPURenderItemEndOcclusionQuery = class _WebGPURenderItemEndOcclusionQuery {
  constructor() {
  }
  run(renderPass) {
    renderPass.endOcclusionQuery();
  }
  clone() {
    return new _WebGPURenderItemEndOcclusionQuery();
  }
};
var WebGPURenderItemBundles = class _WebGPURenderItemBundles {
  constructor() {
    this.bundles = [];
  }
  run(renderPass) {
    renderPass.executeBundles(this.bundles);
  }
  clone() {
    const cloned = new _WebGPURenderItemBundles();
    cloned.bundles = this.bundles;
    return cloned;
  }
};
var WebGPUBundleList = class _WebGPUBundleList {
  constructor(device) {
    this.numDrawCalls = 0;
    this._device = device;
    this._list = new Array(10);
    this._listLength = 0;
  }
  addBundle(bundle) {
    if (!this._currentItemIsBundle) {
      const item = new WebGPURenderItemBundles();
      this._list[this._listLength++] = item;
      this._currentBundleList = item.bundles;
      this._currentItemIsBundle = true;
    }
    if (bundle) {
      this._currentBundleList.push(bundle);
    }
  }
  _finishBundle() {
    if (this._currentItemIsBundle && this._bundleEncoder) {
      this._currentBundleList.push(this._bundleEncoder.finish());
      this._bundleEncoder = void 0;
      this._currentItemIsBundle = false;
    }
  }
  addItem(item) {
    this._finishBundle();
    this._list[this._listLength++] = item;
    this._currentItemIsBundle = false;
  }
  getBundleEncoder(colorFormats, depthStencilFormat, sampleCount) {
    if (!this._currentItemIsBundle) {
      this.addBundle();
      this._bundleEncoder = this._device.createRenderBundleEncoder({
        colorFormats,
        depthStencilFormat,
        sampleCount: WebGPUTextureHelper.GetSample(sampleCount)
      });
    }
    return this._bundleEncoder;
  }
  close() {
    this._finishBundle();
  }
  run(renderPass) {
    this.close();
    for (let i = 0; i < this._listLength; ++i) {
      this._list[i].run(renderPass);
    }
  }
  reset() {
    this._listLength = 0;
    this._currentItemIsBundle = false;
    this.numDrawCalls = 0;
  }
  clone() {
    this.close();
    const cloned = new _WebGPUBundleList(this._device);
    cloned._list = new Array(this._listLength);
    cloned._listLength = this._listLength;
    cloned.numDrawCalls = this.numDrawCalls;
    for (let i = 0; i < this._listLength; ++i) {
      cloned._list[i] = this._list[i].clone();
    }
    return cloned;
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuQuerySet.js
var WebGPUQuerySet = class {
  get querySet() {
    return this._querySet;
  }
  constructor(engine, count, type, device, bufferManager, canUseMultipleBuffers = true, label) {
    this._dstBuffers = [];
    this._engine = engine;
    this._device = device;
    this._bufferManager = bufferManager;
    this._count = count;
    this._canUseMultipleBuffers = canUseMultipleBuffers;
    this._querySet = device.createQuerySet({
      label: label ?? "QuerySet",
      type,
      count
    });
    this._queryBuffer = bufferManager.createRawBuffer(8 * count, BufferUsage.QueryResolve | BufferUsage.CopySrc, void 0, "QueryBuffer");
    if (!canUseMultipleBuffers) {
      this._dstBuffers.push(this._bufferManager.createRawBuffer(8 * this._count, BufferUsage.MapRead | BufferUsage.CopyDst, void 0, "QueryBufferNoMultipleBuffers"));
    }
  }
  _getBuffer(firstQuery, queryCount) {
    if (!this._canUseMultipleBuffers && this._dstBuffers.length === 0) {
      return null;
    }
    const encoderResult = this._device.createCommandEncoder();
    let buffer;
    if (this._dstBuffers.length === 0) {
      buffer = this._bufferManager.createRawBuffer(8 * this._count, BufferUsage.MapRead | BufferUsage.CopyDst, void 0, "QueryBufferAdditionalBuffer");
    } else {
      buffer = this._dstBuffers[this._dstBuffers.length - 1];
      this._dstBuffers.length--;
    }
    encoderResult.resolveQuerySet(this._querySet, firstQuery, queryCount, this._queryBuffer, 0);
    encoderResult.copyBufferToBuffer(this._queryBuffer, 0, buffer, 0, 8 * queryCount);
    this._device.queue.submit([encoderResult.finish()]);
    return buffer;
  }
  async readValues(firstQuery = 0, queryCount = 1) {
    const buffer = this._getBuffer(firstQuery, queryCount);
    if (buffer === null) {
      return null;
    }
    const engineId = this._engine.uniqueId;
    return buffer.mapAsync(
      1
      /* WebGPUConstants.MapMode.Read */
    ).then(() => {
      const arrayBuf = new BigUint64Array(buffer.getMappedRange()).slice();
      buffer.unmap();
      this._dstBuffers[this._dstBuffers.length] = buffer;
      return arrayBuf;
    }, (err) => {
      if (this._engine.isDisposed || this._engine.uniqueId !== engineId) {
        return null;
      }
      throw err;
    });
  }
  async readValue(firstQuery = 0) {
    const buffer = this._getBuffer(firstQuery, 1);
    if (buffer === null) {
      return null;
    }
    const engineId = this._engine.uniqueId;
    return buffer.mapAsync(
      1
      /* WebGPUConstants.MapMode.Read */
    ).then(() => {
      const arrayBuf = new BigUint64Array(buffer.getMappedRange());
      const value = Number(arrayBuf[0]);
      buffer.unmap();
      this._dstBuffers[this._dstBuffers.length] = buffer;
      return value;
    }, (err) => {
      if (this._engine.isDisposed || this._engine.uniqueId !== engineId) {
        return 0;
      }
      throw err;
    });
  }
  async readTwoValuesAndSubtract(firstQuery = 0) {
    const buffer = this._getBuffer(firstQuery, 2);
    if (buffer === null) {
      return null;
    }
    const engineId = this._engine.uniqueId;
    return buffer.mapAsync(
      1
      /* WebGPUConstants.MapMode.Read */
    ).then(() => {
      const arrayBuf = new BigUint64Array(buffer.getMappedRange());
      const value = Number(arrayBuf[1] - arrayBuf[0]);
      buffer.unmap();
      this._dstBuffers[this._dstBuffers.length] = buffer;
      return value;
    }, (err) => {
      if (this._engine.isDisposed || this._engine.uniqueId !== engineId) {
        return 0;
      }
      throw err;
    });
  }
  dispose() {
    this._querySet.destroy();
    this._bufferManager.releaseBuffer(this._queryBuffer);
    for (let i = 0; i < this._dstBuffers.length; ++i) {
      this._bufferManager.releaseBuffer(this._dstBuffers[i]);
    }
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuTimestampQuery.js
var WebGPUTimestampQuery = class {
  get gpuFrameTimeCounter() {
    return this._gpuFrameTimeCounter;
  }
  constructor(engine, device, bufferManager) {
    this._enabled = false;
    this._gpuFrameTimeCounter = new PerfCounter();
    this._measureDurationState = 0;
    this._engine = engine;
    this._device = device;
    this._bufferManager = bufferManager;
  }
  get enable() {
    return this._enabled;
  }
  set enable(value) {
    if (this._enabled === value) {
      return;
    }
    this._enabled = value;
    this._measureDurationState = 0;
    if (value) {
      try {
        this._measureDuration = new WebGPUDurationMeasure(this._engine, this._device, this._bufferManager, 2e3, "QuerySet_TimestampQuery");
      } catch (e) {
        this._enabled = false;
        Logger.Error("Could not create a WebGPUDurationMeasure!\nError: " + e.message + "\nMake sure timestamp query is supported and enabled in your browser.");
        return;
      }
    } else {
      this._measureDuration.dispose();
    }
  }
  startFrame(commandEncoder) {
    if (this._enabled && this._measureDurationState === 0) {
      this._measureDuration.start(commandEncoder);
      this._measureDurationState = 1;
    }
  }
  endFrame(commandEncoder) {
    if (this._measureDurationState === 1) {
      this._measureDurationState = 2;
      this._measureDuration.stop(commandEncoder).then((duration) => {
        if (duration !== null && duration >= 0) {
          this._gpuFrameTimeCounter.fetchNewFrame();
          this._gpuFrameTimeCounter.addCount(duration, true);
        }
        this._measureDurationState = 0;
      });
    }
  }
  startPass(descriptor, index) {
    if (this._enabled) {
      this._measureDuration.startPass(descriptor, index);
    } else {
      descriptor.timestampWrites = void 0;
    }
  }
  endPass(index, gpuPerfCounter) {
    if (!this._enabled || !gpuPerfCounter) {
      return;
    }
    const currentFrameId = this._engine.frameId;
    this._measureDuration.stopPass(index).then((duration_) => {
      gpuPerfCounter._addDuration(currentFrameId, duration_ !== null && duration_ > 0 ? duration_ : 0);
    });
  }
  dispose() {
    this._measureDuration?.dispose();
  }
};
var WebGPUDurationMeasure = class {
  constructor(engine, device, bufferManager, count = 2, querySetLabel) {
    this._count = count;
    this._querySet = new WebGPUQuerySet(engine, count, "timestamp", device, bufferManager, true, querySetLabel);
  }
  start(encoder) {
    encoder.writeTimestamp?.(this._querySet.querySet, 0);
  }
  async stop(encoder) {
    encoder.writeTimestamp?.(this._querySet.querySet, 1);
    return encoder.writeTimestamp ? this._querySet.readTwoValuesAndSubtract(0) : 0;
  }
  startPass(descriptor, index) {
    if (index + 3 > this._count) {
      throw new Error("WebGPUDurationMeasure: index out of range (" + index + ")");
    }
    descriptor.timestampWrites = {
      querySet: this._querySet.querySet,
      beginningOfPassWriteIndex: index + 2,
      endOfPassWriteIndex: index + 3
    };
  }
  async stopPass(index) {
    return this._querySet.readTwoValuesAndSubtract(index + 2);
  }
  dispose() {
    this._querySet.dispose();
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuOcclusionQuery.js
var WebGPUOcclusionQuery = class {
  get querySet() {
    return this._querySet.querySet;
  }
  get hasQueries() {
    return this._currentTotalIndices !== this._availableIndices.length;
  }
  canBeginQuery(index) {
    if (this._frameQuerySetIsDirty === this._engine.frameId || this._queryFrameId[index] === this._engine.frameId) {
      return false;
    }
    const canBegin = this._engine._getCurrentRenderPassWrapper().renderPassDescriptor.occlusionQuerySet !== void 0;
    if (canBegin) {
      this._queryFrameId[index] = this._engine.frameId;
    }
    return canBegin;
  }
  constructor(engine, device, bufferManager, startCount = 50, incrementCount = 100) {
    this._availableIndices = [];
    this._frameQuerySetIsDirty = -1;
    this._queryFrameId = [];
    this._engine = engine;
    this._device = device;
    this._bufferManager = bufferManager;
    this._frameLastBuffer = -1;
    this._currentTotalIndices = 0;
    this._countIncrement = incrementCount;
    this._allocateNewIndices(startCount);
  }
  createQuery() {
    if (this._availableIndices.length === 0) {
      this._allocateNewIndices();
    }
    const index = this._availableIndices[this._availableIndices.length - 1];
    this._availableIndices.length--;
    return index;
  }
  deleteQuery(index) {
    this._availableIndices[this._availableIndices.length] = index;
  }
  isQueryResultAvailable(index) {
    this._retrieveQueryBuffer();
    return !!this._lastBuffer && index < this._lastBuffer.length;
  }
  getQueryResult(index) {
    return Number(this._lastBuffer?.[index] ?? -1);
  }
  _retrieveQueryBuffer() {
    if (this._lastBuffer && this._frameLastBuffer === this._engine.frameId) {
      return;
    }
    if (this._frameLastBuffer !== this._engine.frameId) {
      this._frameLastBuffer = this._engine.frameId;
      this._querySet.readValues(0, this._currentTotalIndices).then((arrayBuffer) => {
        this._lastBuffer = arrayBuffer;
      });
    }
  }
  _allocateNewIndices(numIndices) {
    numIndices = numIndices ?? this._countIncrement;
    this._delayQuerySetDispose();
    for (let i = 0; i < numIndices; ++i) {
      this._availableIndices.push(this._currentTotalIndices + i);
    }
    this._currentTotalIndices += numIndices;
    this._querySet = new WebGPUQuerySet(this._engine, this._currentTotalIndices, "occlusion", this._device, this._bufferManager, false, "QuerySet_OcclusionQuery_count_" + this._currentTotalIndices);
    this._frameQuerySetIsDirty = this._engine.frameId;
  }
  _delayQuerySetDispose() {
    const querySet = this._querySet;
    if (querySet) {
      setTimeout(() => querySet.dispose, 1e3);
    }
  }
  dispose() {
    this._querySet?.dispose();
    this._availableIndices.length = 0;
  }
};

// node_modules/@babylonjs/core/Engines/Processors/shaderCodeInliner.js
var ShaderCodeInliner = class _ShaderCodeInliner {
  /** Gets the code after the inlining process */
  get code() {
    return this._sourceCode;
  }
  /**
   * Initializes the inliner
   * @param sourceCode shader code source to inline
   * @param numMaxIterations maximum number of iterations (used to detect recursive calls)
   */
  constructor(sourceCode, numMaxIterations = 20) {
    this.debug = false;
    this._sourceCode = sourceCode;
    this._numMaxIterations = numMaxIterations;
    this._functionDescr = [];
    this.inlineToken = "#define inline";
  }
  /**
   * Start the processing of the shader code
   */
  processCode() {
    if (this.debug) {
      Logger.Log(`Start inlining process (code size=${this._sourceCode.length})...`);
    }
    this._collectFunctions();
    this._processInlining(this._numMaxIterations);
    if (this.debug) {
      Logger.Log("End of inlining process.");
    }
  }
  _collectFunctions() {
    let startIndex = 0;
    while (startIndex < this._sourceCode.length) {
      const inlineTokenIndex = this._sourceCode.indexOf(this.inlineToken, startIndex);
      if (inlineTokenIndex < 0) {
        break;
      }
      const funcParamsStartIndex = this._sourceCode.indexOf("(", inlineTokenIndex + this.inlineToken.length);
      if (funcParamsStartIndex < 0) {
        if (this.debug) {
          Logger.Warn(`Could not find the opening parenthesis after the token. startIndex=${startIndex}`);
        }
        startIndex = inlineTokenIndex + this.inlineToken.length;
        continue;
      }
      const funcNameMatch = _ShaderCodeInliner._RegexpFindFunctionNameAndType.exec(this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex));
      if (!funcNameMatch) {
        if (this.debug) {
          Logger.Warn(`Could not extract the name/type of the function from: ${this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex)}`);
        }
        startIndex = inlineTokenIndex + this.inlineToken.length;
        continue;
      }
      const [funcType, funcName] = [funcNameMatch[3], funcNameMatch[4]];
      const funcParamsEndIndex = ExtractBetweenMarkers("(", ")", this._sourceCode, funcParamsStartIndex);
      if (funcParamsEndIndex < 0) {
        if (this.debug) {
          Logger.Warn(`Could not extract the parameters the function '${funcName}' (type=${funcType}). funcParamsStartIndex=${funcParamsStartIndex}`);
        }
        startIndex = inlineTokenIndex + this.inlineToken.length;
        continue;
      }
      const funcParams = this._sourceCode.substring(funcParamsStartIndex + 1, funcParamsEndIndex);
      const funcBodyStartIndex = SkipWhitespaces(this._sourceCode, funcParamsEndIndex + 1);
      if (funcBodyStartIndex === this._sourceCode.length) {
        if (this.debug) {
          Logger.Warn(`Could not extract the body of the function '${funcName}' (type=${funcType}). funcParamsEndIndex=${funcParamsEndIndex}`);
        }
        startIndex = inlineTokenIndex + this.inlineToken.length;
        continue;
      }
      const funcBodyEndIndex = ExtractBetweenMarkers("{", "}", this._sourceCode, funcBodyStartIndex);
      if (funcBodyEndIndex < 0) {
        if (this.debug) {
          Logger.Warn(`Could not extract the body of the function '${funcName}' (type=${funcType}). funcBodyStartIndex=${funcBodyStartIndex}`);
        }
        startIndex = inlineTokenIndex + this.inlineToken.length;
        continue;
      }
      const funcBody = this._sourceCode.substring(funcBodyStartIndex, funcBodyEndIndex + 1);
      const params = RemoveComments(funcParams).split(",");
      const paramNames = [];
      for (let p = 0; p < params.length; ++p) {
        const param = params[p].trim();
        const idx = param.lastIndexOf(" ");
        if (idx >= 0) {
          paramNames.push(param.substring(idx + 1));
        }
      }
      if (funcType !== "void") {
        paramNames.push("return");
      }
      this._functionDescr.push({
        name: funcName,
        type: funcType,
        parameters: paramNames,
        body: funcBody,
        callIndex: 0
      });
      startIndex = funcBodyEndIndex + 1;
      const partBefore = inlineTokenIndex > 0 ? this._sourceCode.substring(0, inlineTokenIndex) : "";
      const partAfter = funcBodyEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(funcBodyEndIndex + 1) : "";
      this._sourceCode = partBefore + partAfter;
      startIndex -= funcBodyEndIndex + 1 - inlineTokenIndex;
    }
    if (this.debug) {
      Logger.Log(`Collect functions: ${this._functionDescr.length} functions found. functionDescr=${this._functionDescr}`);
    }
  }
  _processInlining(numMaxIterations = 20) {
    while (numMaxIterations-- >= 0) {
      if (!this._replaceFunctionCallsByCode()) {
        break;
      }
    }
    if (this.debug) {
      Logger.Log(`numMaxIterations is ${numMaxIterations} after inlining process`);
    }
    return numMaxIterations >= 0;
  }
  _replaceFunctionCallsByCode() {
    let doAgain = false;
    for (const func of this._functionDescr) {
      const { name: name3, type, parameters, body } = func;
      let startIndex = 0;
      while (startIndex < this._sourceCode.length) {
        const functionCallIndex = this._sourceCode.indexOf(name3, startIndex);
        if (functionCallIndex < 0) {
          break;
        }
        if (functionCallIndex === 0 || IsIdentifierChar(this._sourceCode.charAt(functionCallIndex - 1))) {
          startIndex = functionCallIndex + name3.length;
          continue;
        }
        const callParamsStartIndex = SkipWhitespaces(this._sourceCode, functionCallIndex + name3.length);
        if (callParamsStartIndex === this._sourceCode.length || this._sourceCode.charAt(callParamsStartIndex) !== "(") {
          startIndex = functionCallIndex + name3.length;
          continue;
        }
        const callParamsEndIndex = ExtractBetweenMarkers("(", ")", this._sourceCode, callParamsStartIndex);
        if (callParamsEndIndex < 0) {
          if (this.debug) {
            Logger.Warn(`Could not extract the parameters of the function call. Function '${name3}' (type=${type}). callParamsStartIndex=${callParamsStartIndex}`);
          }
          startIndex = functionCallIndex + name3.length;
          continue;
        }
        const callParams = this._sourceCode.substring(callParamsStartIndex + 1, callParamsEndIndex);
        const splitParameterCall = (s) => {
          const parameters2 = [];
          let curIdx = 0, startParamIdx = 0;
          while (curIdx < s.length) {
            if (s.charAt(curIdx) === "(") {
              const idx2 = ExtractBetweenMarkers("(", ")", s, curIdx);
              if (idx2 < 0) {
                return null;
              }
              curIdx = idx2;
            } else if (s.charAt(curIdx) === ",") {
              parameters2.push(s.substring(startParamIdx, curIdx));
              startParamIdx = curIdx + 1;
            }
            curIdx++;
          }
          if (startParamIdx < curIdx) {
            parameters2.push(s.substring(startParamIdx, curIdx));
          }
          return parameters2;
        };
        const params = splitParameterCall(RemoveComments(callParams));
        if (params === null) {
          if (this.debug) {
            Logger.Warn(`Invalid function call: can't extract the parameters of the function call. Function '${name3}' (type=${type}). callParamsStartIndex=${callParamsStartIndex}, callParams=` + callParams);
          }
          startIndex = functionCallIndex + name3.length;
          continue;
        }
        const paramNames = [];
        for (let p = 0; p < params.length; ++p) {
          const param = params[p].trim();
          paramNames.push(param);
        }
        const retParamName = type !== "void" ? name3 + "_" + func.callIndex++ : null;
        if (retParamName) {
          paramNames.push(retParamName + " =");
        }
        if (paramNames.length !== parameters.length) {
          if (this.debug) {
            Logger.Warn(`Invalid function call: not the same number of parameters for the call than the number expected by the function. Function '${name3}' (type=${type}). function parameters=${parameters}, call parameters=${paramNames}`);
          }
          startIndex = functionCallIndex + name3.length;
          continue;
        }
        startIndex = callParamsEndIndex + 1;
        const funcBody = this._replaceNames(body, parameters, paramNames);
        let partBefore = functionCallIndex > 0 ? this._sourceCode.substring(0, functionCallIndex) : "";
        const partAfter = callParamsEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(callParamsEndIndex + 1) : "";
        if (retParamName) {
          const injectDeclarationIndex = FindBackward(this._sourceCode, functionCallIndex - 1, "\n", "{");
          partBefore = this._sourceCode.substring(0, injectDeclarationIndex + 1);
          const partBetween = this._sourceCode.substring(injectDeclarationIndex + 1, functionCallIndex);
          this._sourceCode = partBefore + type + " " + retParamName + ";\n" + funcBody + "\n" + partBetween + retParamName + partAfter;
          if (this.debug) {
            Logger.Log(`Replace function call by code. Function '${name3}' (type=${type}). injectDeclarationIndex=${injectDeclarationIndex}, call parameters=${paramNames}`);
          }
        } else {
          this._sourceCode = partBefore + funcBody + partAfter;
          startIndex += funcBody.length - (callParamsEndIndex + 1 - functionCallIndex);
          if (this.debug) {
            Logger.Log(`Replace function call by code. Function '${name3}' (type=${type}). functionCallIndex=${functionCallIndex}, call parameters=${paramNames}`);
          }
        }
        doAgain = true;
      }
    }
    return doAgain;
  }
  _replaceNames(code, sources, destinations) {
    for (let i = 0; i < sources.length; ++i) {
      const source = new RegExp(EscapeRegExp(sources[i]), "g"), sourceLen = sources[i].length, destination = destinations[i];
      code = code.replace(source, (match, ...args) => {
        const offset = args[0];
        if (IsIdentifierChar(code.charAt(offset - 1)) || IsIdentifierChar(code.charAt(offset + sourceLen))) {
          return sources[i];
        }
        return destination;
      });
    }
    return code;
  }
};
ShaderCodeInliner._RegexpFindFunctionNameAndType = /((\s+?)(\w+)\s+(\w+)\s*?)$/;

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuTintWASM.js
var WebGPUTintWASM = class _WebGPUTintWASM {
  async initTwgsl(twgslOptions) {
    if (_WebGPUTintWASM._Twgsl) {
      return;
    }
    twgslOptions = twgslOptions || {};
    twgslOptions = {
      ..._WebGPUTintWASM._TWgslDefaultOptions,
      ...twgslOptions
    };
    if (twgslOptions.twgsl) {
      _WebGPUTintWASM._Twgsl = twgslOptions.twgsl;
      return Promise.resolve();
    }
    if (twgslOptions.jsPath && twgslOptions.wasmPath) {
      await Tools.LoadBabylonScriptAsync(twgslOptions.jsPath);
    }
    if (self.twgsl) {
      _WebGPUTintWASM._Twgsl = await self.twgsl(Tools.GetBabylonScriptURL(twgslOptions.wasmPath));
      return Promise.resolve();
    }
    return Promise.reject("twgsl is not available.");
  }
  convertSpirV2WGSL(code, disableUniformityAnalysis = false) {
    const ccode = _WebGPUTintWASM._Twgsl.convertSpirV2WGSL(code, _WebGPUTintWASM.DisableUniformityAnalysis || disableUniformityAnalysis);
    if (_WebGPUTintWASM.ShowWGSLShaderCode) {
      Logger.Log(ccode);
      Logger.Log("***********************************************");
    }
    return _WebGPUTintWASM.DisableUniformityAnalysis || disableUniformityAnalysis ? "diagnostic(off, derivative_uniformity);\n" + ccode : ccode;
  }
};
WebGPUTintWASM._TWgslDefaultOptions = {
  jsPath: `${Tools._DefaultCdnUrl}/twgsl/twgsl.js`,
  wasmPath: `${Tools._DefaultCdnUrl}/twgsl/twgsl.wasm`
};
WebGPUTintWASM.ShowWGSLShaderCode = false;
WebGPUTintWASM.DisableUniformityAnalysis = false;
WebGPUTintWASM._Twgsl = null;

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuSnapshotRendering.js
var WebGPUSnapshotRendering = class {
  constructor(engine, renderingMode, bundleList) {
    this._record = false;
    this._play = false;
    this._playBundleListIndex = 0;
    this._allBundleLists = [];
    this._enabled = false;
    this.showDebugLogs = false;
    this._engine = engine;
    this._mode = renderingMode;
    this._bundleList = bundleList;
  }
  get enabled() {
    return this._enabled;
  }
  get play() {
    return this._play;
  }
  get record() {
    return this._record;
  }
  set enabled(activate) {
    this._log("enabled", `activate=${activate}, mode=${this._mode}`);
    this._allBundleLists.length = 0;
    this._record = this._enabled = activate;
    this._play = false;
    if (activate) {
      this._modeSaved = this._mode;
      this._mode = 0;
    }
  }
  get mode() {
    return this._mode;
  }
  set mode(mode) {
    if (this._record) {
      this._modeSaved = mode;
    } else {
      this._mode = mode;
    }
  }
  endRenderPass(currentRenderPass) {
    if (!this._record && !this._play) {
      return false;
    }
    let bundleList = null;
    if (this._record) {
      bundleList = this._bundleList.clone();
      this._allBundleLists.push(bundleList);
      this._bundleList.reset();
      this._log("endRenderPass", `bundleList recorded at position #${this._allBundleLists.length - 1}`);
    } else {
      if (this._playBundleListIndex >= this._allBundleLists.length) {
        this._log("endRenderPass", `empty or out-of-sync bundleList (_allBundleLists.length=${this._allBundleLists.length}, playBundleListIndex=${this._playBundleListIndex})`);
      } else {
        this._log("endRenderPass", `run bundleList #${this._playBundleListIndex}`);
        bundleList = this._allBundleLists[this._playBundleListIndex++];
      }
    }
    if (bundleList) {
      bundleList.run(currentRenderPass);
      if (this._mode === 1) {
        this._engine._reportDrawCall(bundleList.numDrawCalls);
      }
    }
    return true;
  }
  endFrame() {
    if (this._record) {
      this._record = false;
      this._play = true;
      this._mode = this._modeSaved;
      this._log("endFrame", "bundles recorded, switching to play mode");
    }
    this._playBundleListIndex = 0;
  }
  reset() {
    this._log("reset", "called");
    if (this._record) {
      this._mode = this._modeSaved;
    }
    this.enabled = false;
    this.enabled = true;
  }
  _log(funcName, message) {
    if (this.showDebugLogs) {
      Logger.Log(`[Frame: ${this._engine.frameId}] WebGPUSnapshotRendering:${funcName} - ${message}`);
    }
  }
};

// node_modules/@babylonjs/core/Buffers/buffer.align.js
var isLittleEndian = (() => {
  const array = new Uint8Array(4);
  const view = new Uint32Array(array.buffer);
  return !!((view[0] = 1) & array[0]);
})();
Object.defineProperty(VertexBuffer.prototype, "effectiveByteStride", {
  get: function() {
    return this._alignedBuffer && this._alignedBuffer.byteStride || this.byteStride;
  },
  enumerable: true,
  configurable: true
});
Object.defineProperty(VertexBuffer.prototype, "effectiveByteOffset", {
  get: function() {
    return this._alignedBuffer ? 0 : this.byteOffset;
  },
  enumerable: true,
  configurable: true
});
Object.defineProperty(VertexBuffer.prototype, "effectiveBuffer", {
  get: function() {
    return this._alignedBuffer && this._alignedBuffer.getBuffer() || this._buffer.getBuffer();
  },
  enumerable: true,
  configurable: true
});
VertexBuffer.prototype._rebuild = function() {
  this._buffer?._rebuild();
  this._alignedBuffer?._rebuild();
};
VertexBuffer.prototype.dispose = function() {
  if (this._ownsBuffer) {
    this._buffer.dispose();
  }
  this._alignedBuffer?.dispose();
  this._alignedBuffer = void 0;
  this._isDisposed = true;
};
VertexBuffer.prototype.getWrapperBuffer = function() {
  return this._alignedBuffer || this._buffer;
};
VertexBuffer.prototype._alignBuffer = function() {
  const data = this._buffer.getData();
  if (!this.engine._features.forceVertexBufferStrideAndOffsetMultiple4Bytes || this.byteStride % 4 === 0 && this.byteOffset % 4 === 0 || !data) {
    return;
  }
  const typeByteLength = VertexBuffer.GetTypeByteLength(this.type);
  const alignedByteStride = this.byteStride + 3 & ~3;
  const alignedSize = alignedByteStride / typeByteLength;
  const totalVertices = this._maxVerticesCount;
  const totalByteLength = totalVertices * alignedByteStride;
  const totalLength = totalByteLength / typeByteLength;
  let sourceData;
  if (Array.isArray(data)) {
    const sourceDataAsFloat = new Float32Array(data);
    sourceData = new DataView(sourceDataAsFloat.buffer, sourceDataAsFloat.byteOffset, sourceDataAsFloat.byteLength);
  } else if (data instanceof ArrayBuffer) {
    sourceData = new DataView(data, 0, data.byteLength);
  } else {
    sourceData = new DataView(data.buffer, data.byteOffset, data.byteLength);
  }
  let alignedData;
  if (this.type === VertexBuffer.BYTE) {
    alignedData = new Int8Array(totalLength);
  } else if (this.type === VertexBuffer.UNSIGNED_BYTE) {
    alignedData = new Uint8Array(totalLength);
  } else if (this.type === VertexBuffer.SHORT) {
    alignedData = new Int16Array(totalLength);
  } else if (this.type === VertexBuffer.UNSIGNED_SHORT) {
    alignedData = new Uint16Array(totalLength);
  } else if (this.type === VertexBuffer.INT) {
    alignedData = new Int32Array(totalLength);
  } else if (this.type === VertexBuffer.UNSIGNED_INT) {
    alignedData = new Uint32Array(totalLength);
  } else {
    alignedData = new Float32Array(totalLength);
  }
  const numComponents = this.getSize();
  let sourceOffset = this.byteOffset;
  for (let i = 0; i < totalVertices; ++i) {
    for (let j = 0; j < numComponents; ++j) {
      switch (this.type) {
        case VertexBuffer.BYTE:
          alignedData[i * alignedSize + j] = sourceData.getInt8(sourceOffset + j);
          break;
        case VertexBuffer.UNSIGNED_BYTE:
          alignedData[i * alignedSize + j] = sourceData.getUint8(sourceOffset + j);
          break;
        case VertexBuffer.SHORT:
          alignedData[i * alignedSize + j] = sourceData.getInt16(sourceOffset + j * 2, isLittleEndian);
          break;
        case VertexBuffer.UNSIGNED_SHORT:
          alignedData[i * alignedSize + j] = sourceData.getUint16(sourceOffset + j * 2, isLittleEndian);
          break;
        case VertexBuffer.INT:
          alignedData[i * alignedSize + j] = sourceData.getInt32(sourceOffset + j * 4, isLittleEndian);
          break;
        case VertexBuffer.UNSIGNED_INT:
          alignedData[i * alignedSize + j] = sourceData.getUint32(sourceOffset + j * 4, isLittleEndian);
          break;
        case VertexBuffer.FLOAT:
          alignedData[i * alignedSize + j] = sourceData.getFloat32(sourceOffset + j * 4, isLittleEndian);
          break;
      }
    }
    sourceOffset += this.byteStride;
  }
  this._alignedBuffer?.dispose();
  this._alignedBuffer = new Buffer(this.engine, alignedData, false, alignedByteStride, false, this.getIsInstanced(), true, this.instanceDivisor, (this._label ?? "VertexBuffer") + "_aligned");
};

// node_modules/@babylonjs/core/Audio/audioEngine.js
AbstractEngine.AudioEngineFactory = (hostElement, audioContext, audioDestination) => {
  return new AudioEngine(hostElement, audioContext, audioDestination);
};
var AudioEngine = class {
  /**
   * Gets the current AudioContext if available.
   */
  get audioContext() {
    if (!this._audioContextInitialized) {
      this._initializeAudioContext();
    }
    return this._audioContext;
  }
  /**
   * Instantiates a new audio engine.
   *
   * There should be only one per page as some browsers restrict the number
   * of audio contexts you can create.
   * @param hostElement defines the host element where to display the mute icon if necessary
   * @param audioContext defines the audio context to be used by the audio engine
   * @param audioDestination defines the audio destination node to be used by audio engine
   */
  constructor(hostElement = null, audioContext = null, audioDestination = null) {
    this._audioContext = null;
    this._audioContextInitialized = false;
    this._muteButton = null;
    this._audioDestination = null;
    this.canUseWebAudio = false;
    this.WarnedWebAudioUnsupported = false;
    this.isMP3supported = false;
    this.isOGGsupported = false;
    this.unlocked = false;
    this.useCustomUnlockedButton = false;
    this.onAudioUnlockedObservable = new Observable();
    this.onAudioLockedObservable = new Observable();
    this._tryToRun = false;
    this._onResize = () => {
      this._moveButtonToTopLeft();
    };
    if (!IsWindowObjectExist()) {
      return;
    }
    if (typeof window.AudioContext !== "undefined") {
      this.canUseWebAudio = true;
    }
    const audioElem = document.createElement("audio");
    this._hostElement = hostElement;
    this._audioContext = audioContext;
    this._audioDestination = audioDestination;
    try {
      if (audioElem && !!audioElem.canPlayType && (audioElem.canPlayType('audio/mpeg; codecs="mp3"').replace(/^no$/, "") || audioElem.canPlayType("audio/mp3").replace(/^no$/, ""))) {
        this.isMP3supported = true;
      }
    } catch (e) {
    }
    try {
      if (audioElem && !!audioElem.canPlayType && audioElem.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "")) {
        this.isOGGsupported = true;
      }
    } catch (e) {
    }
  }
  /**
   * Flags the audio engine in Locked state.
   * This happens due to new browser policies preventing audio to autoplay.
   */
  lock() {
    this._triggerSuspendedState();
  }
  /**
   * Unlocks the audio engine once a user action has been done on the dom.
   * This is helpful to resume play once browser policies have been satisfied.
   */
  unlock() {
    if (this._audioContext?.state === "running") {
      this._hideMuteButton();
      if (!this.unlocked) {
        this.unlocked = true;
        this.onAudioUnlockedObservable.notifyObservers(this);
      }
      return;
    }
    if (this._tryToRun) {
      this._audioContext?.suspend().then(() => {
        this._tryToRun = false;
        this._triggerRunningState();
      });
    } else {
      this._triggerRunningState();
    }
  }
  /** @internal */
  _resumeAudioContextOnStateChange() {
    this._audioContext?.addEventListener("statechange", () => {
      if (this.unlocked && this._audioContext?.state !== "running") {
        this._resumeAudioContext();
      }
    }, {
      once: true,
      passive: true,
      signal: AbortSignal.timeout(3e3)
    });
  }
  _resumeAudioContext() {
    if (this._audioContext?.resume) {
      return this._audioContext.resume();
    }
    return Promise.resolve();
  }
  _initializeAudioContext() {
    try {
      if (this.canUseWebAudio) {
        if (!this._audioContext) {
          this._audioContext = new AudioContext();
        }
        this.masterGain = this._audioContext.createGain();
        this.masterGain.gain.value = 1;
        if (!this._audioDestination) {
          this._audioDestination = this._audioContext.destination;
        }
        this.masterGain.connect(this._audioDestination);
        this._audioContextInitialized = true;
        if (this._audioContext.state === "running") {
          this._triggerRunningState();
        }
      }
    } catch (e) {
      this.canUseWebAudio = false;
      Logger.Error("Web Audio: " + e.message);
    }
  }
  _triggerRunningState() {
    if (this._tryToRun) {
      return;
    }
    this._tryToRun = true;
    this._resumeAudioContext().then(() => {
      this._tryToRun = false;
      if (this._muteButton) {
        this._hideMuteButton();
      }
      this.unlocked = true;
      this.onAudioUnlockedObservable.notifyObservers(this);
    }).catch(() => {
      this._tryToRun = false;
      this.unlocked = false;
    });
  }
  _triggerSuspendedState() {
    this.unlocked = false;
    this.onAudioLockedObservable.notifyObservers(this);
    this._displayMuteButton();
  }
  _displayMuteButton() {
    if (this.useCustomUnlockedButton || this._muteButton) {
      return;
    }
    this._muteButton = document.createElement("BUTTON");
    this._muteButton.className = "babylonUnmuteIcon";
    this._muteButton.id = "babylonUnmuteIconBtn";
    this._muteButton.title = "Unmute";
    const imageUrl = !window.SVGSVGElement ? "https://cdn.babylonjs.com/Assets/audio.png" : "data:image/svg+xml;charset=UTF-8,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2239%22%20height%3D%2232%22%20viewBox%3D%220%200%2039%2032%22%3E%3Cpath%20fill%3D%22white%22%20d%3D%22M9.625%2018.938l-0.031%200.016h-4.953q-0.016%200-0.031-0.016v-12.453q0-0.016%200.031-0.016h4.953q0.031%200%200.031%200.016v12.453zM12.125%207.688l8.719-8.703v27.453l-8.719-8.719-0.016-0.047v-9.938zM23.359%207.875l1.406-1.406%204.219%204.203%204.203-4.203%201.422%201.406-4.219%204.219%204.219%204.203-1.484%201.359-4.141-4.156-4.219%204.219-1.406-1.422%204.219-4.203z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E";
    const css = ".babylonUnmuteIcon { position: absolute; left: 20px; top: 20px; height: 40px; width: 60px; background-color: rgba(51,51,51,0.7); background-image: url(" + imageUrl + ");  background-size: 80%; background-repeat:no-repeat; background-position: center; background-position-y: 4px; border: none; outline: none; transition: transform 0.125s ease-out; cursor: pointer; z-index: 9999; } .babylonUnmuteIcon:hover { transform: scale(1.05) } .babylonUnmuteIcon:active { background-color: rgba(51,51,51,1) }";
    const style = document.createElement("style");
    style.appendChild(document.createTextNode(css));
    document.getElementsByTagName("head")[0].appendChild(style);
    document.body.appendChild(this._muteButton);
    this._moveButtonToTopLeft();
    this._muteButton.addEventListener("touchend", () => {
      this._triggerRunningState();
    }, true);
    this._muteButton.addEventListener("click", () => {
      this.unlock();
    }, true);
    window.addEventListener("resize", this._onResize);
  }
  _moveButtonToTopLeft() {
    if (this._hostElement && this._muteButton) {
      this._muteButton.style.top = this._hostElement.offsetTop + 20 + "px";
      this._muteButton.style.left = this._hostElement.offsetLeft + 20 + "px";
    }
  }
  _hideMuteButton() {
    if (this._muteButton) {
      document.body.removeChild(this._muteButton);
      this._muteButton = null;
    }
  }
  /**
   * Destroy and release the resources associated with the audio context.
   */
  dispose() {
    if (this.canUseWebAudio && this._audioContextInitialized) {
      if (this._connectedAnalyser && this._audioContext) {
        this._connectedAnalyser.stopDebugCanvas();
        this._connectedAnalyser.dispose();
        this.masterGain.disconnect();
        this.masterGain.connect(this._audioContext.destination);
        this._connectedAnalyser = null;
      }
      this.masterGain.gain.value = 1;
    }
    this.WarnedWebAudioUnsupported = false;
    this._hideMuteButton();
    window.removeEventListener("resize", this._onResize);
    this.onAudioUnlockedObservable.clear();
    this.onAudioLockedObservable.clear();
  }
  /**
   * Gets the global volume sets on the master gain.
   * @returns the global volume if set or -1 otherwise
   */
  getGlobalVolume() {
    if (this.canUseWebAudio && this._audioContextInitialized) {
      return this.masterGain.gain.value;
    } else {
      return -1;
    }
  }
  /**
   * Sets the global volume of your experience (sets on the master gain).
   * @param newVolume Defines the new global volume of the application
   */
  setGlobalVolume(newVolume) {
    if (this.canUseWebAudio && this._audioContextInitialized) {
      this.masterGain.gain.value = newVolume;
    }
  }
  /**
   * Connect the audio engine to an audio analyser allowing some amazing
   * synchronization between the sounds/music and your visualization (VuMeter for instance).
   * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-the-analyser
   * @param analyser The analyser to connect to the engine
   */
  connectToAnalyser(analyser) {
    if (this._connectedAnalyser) {
      this._connectedAnalyser.stopDebugCanvas();
    }
    if (this.canUseWebAudio && this._audioContextInitialized && this._audioContext) {
      this._connectedAnalyser = analyser;
      this.masterGain.disconnect();
      this._connectedAnalyser.connectAudioNodes(this.masterGain, this._audioContext.destination);
    }
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuExternalTexture.js
var WebGPUExternalTexture = class extends ExternalTexture {
  constructor(video) {
    super(video);
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/Extensions/engine.alpha.js
ThinWebGPUEngine.prototype.setAlphaMode = function(mode, noDepthWriteChange = false) {
  if (this._alphaMode === mode && (mode === 0 && !this._alphaState.alphaBlend || mode !== 0 && this._alphaState.alphaBlend)) {
    if (!noDepthWriteChange) {
      const depthMask = mode === 0;
      if (this.depthCullingState.depthMask !== depthMask) {
        this.setDepthWrite(depthMask);
        this._cacheRenderPipeline.setDepthWriteEnabled(depthMask);
      }
    }
    return;
  }
  switch (mode) {
    case 0:
      this._alphaState.alphaBlend = false;
      break;
    case 7:
      this._alphaState.setAlphaBlendFunctionParameters(1, 771, 1, 1);
      this._alphaState.alphaBlend = true;
      break;
    case 8:
      this._alphaState.setAlphaBlendFunctionParameters(1, 771, 1, 771);
      this._alphaState.alphaBlend = true;
      break;
    case 2:
      this._alphaState.setAlphaBlendFunctionParameters(770, 771, 1, 1);
      this._alphaState.alphaBlend = true;
      break;
    case 6:
      this._alphaState.setAlphaBlendFunctionParameters(1, 1, 0, 1);
      this._alphaState.alphaBlend = true;
      break;
    case 1:
      this._alphaState.setAlphaBlendFunctionParameters(770, 1, 0, 1);
      this._alphaState.alphaBlend = true;
      break;
    case 3:
      this._alphaState.setAlphaBlendFunctionParameters(0, 769, 1, 1);
      this._alphaState.alphaBlend = true;
      break;
    case 4:
      this._alphaState.setAlphaBlendFunctionParameters(774, 0, 1, 1);
      this._alphaState.alphaBlend = true;
      break;
    case 5:
      this._alphaState.setAlphaBlendFunctionParameters(770, 769, 1, 1);
      this._alphaState.alphaBlend = true;
      break;
    case 9:
      this._alphaState.setAlphaBlendFunctionParameters(32769, 32770, 32771, 32772);
      this._alphaState.alphaBlend = true;
      break;
    case 10:
      this._alphaState.setAlphaBlendFunctionParameters(1, 769, 1, 771);
      this._alphaState.alphaBlend = true;
      break;
    case 11:
      this._alphaState.setAlphaBlendFunctionParameters(1, 1, 1, 1);
      this._alphaState.alphaBlend = true;
      break;
    case 12:
      this._alphaState.setAlphaBlendFunctionParameters(772, 1, 0, 0);
      this._alphaState.alphaBlend = true;
      break;
    case 13:
      this._alphaState.setAlphaBlendFunctionParameters(775, 769, 773, 771);
      this._alphaState.alphaBlend = true;
      break;
    case 14:
      this._alphaState.setAlphaBlendFunctionParameters(1, 771, 1, 771);
      this._alphaState.alphaBlend = true;
      break;
    case 15:
      this._alphaState.setAlphaBlendFunctionParameters(1, 1, 1, 0);
      this._alphaState.alphaBlend = true;
      break;
    case 16:
      this._alphaState.setAlphaBlendFunctionParameters(775, 769, 0, 1);
      this._alphaState.alphaBlend = true;
      break;
    case 17:
      this._alphaState.setAlphaBlendFunctionParameters(770, 771, 1, 771);
      this._alphaState.alphaBlend = true;
      break;
  }
  if (!noDepthWriteChange) {
    this.setDepthWrite(mode === 0);
    this._cacheRenderPipeline.setDepthWriteEnabled(mode === 0);
  }
  this._alphaMode = mode;
  this._cacheRenderPipeline.setAlphaBlendEnabled(this._alphaState.alphaBlend);
  this._cacheRenderPipeline.setAlphaBlendFactors(this._alphaState._blendFunctionParameters, this._alphaState._blendEquationParameters);
};
ThinWebGPUEngine.prototype.setAlphaEquation = function(equation) {
  AbstractEngine.prototype.setAlphaEquation.call(this, equation);
  this._cacheRenderPipeline.setAlphaBlendFactors(this._alphaState._blendFunctionParameters, this._alphaState._blendEquationParameters);
};

// node_modules/@babylonjs/core/Engines/WebGPU/Extensions/engine.rawTexture.js
ThinWebGPUEngine.prototype.createRawTexture = function(data, width, height, format, generateMipMaps, invertY, samplingMode, compression = null, type = 0, creationFlags = 0, useSRGBBuffer = false) {
  const texture = new InternalTexture(
    this,
    3
    /* InternalTextureSource.Raw */
  );
  texture.baseWidth = width;
  texture.baseHeight = height;
  texture.width = width;
  texture.height = height;
  texture.format = format;
  texture.generateMipMaps = generateMipMaps;
  texture.samplingMode = samplingMode;
  texture.invertY = invertY;
  texture._compression = compression;
  texture.type = type;
  texture._creationFlags = creationFlags;
  texture._useSRGBBuffer = useSRGBBuffer;
  if (!this._doNotHandleContextLost) {
    texture._bufferView = data;
  }
  this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, void 0, creationFlags);
  this.updateRawTexture(texture, data, format, invertY, compression, type, useSRGBBuffer);
  this._internalTexturesCache.push(texture);
  return texture;
};
ThinWebGPUEngine.prototype.updateRawTexture = function(texture, bufferView, format, invertY, compression = null, type = 0, useSRGBBuffer = false) {
  if (!texture) {
    return;
  }
  if (!this._doNotHandleContextLost) {
    texture._bufferView = bufferView;
    texture.invertY = invertY;
    texture._compression = compression;
    texture._useSRGBBuffer = useSRGBBuffer;
  }
  if (bufferView) {
    const gpuTextureWrapper = texture._hardwareTexture;
    const needConversion = format === 4;
    if (needConversion) {
      bufferView = _convertRGBtoRGBATextureData(bufferView, texture.width, texture.height, type);
    }
    const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
    this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);
    if (texture.generateMipMaps) {
      this._generateMipmaps(texture, this._uploadEncoder);
    }
  }
  texture.isReady = true;
};
ThinWebGPUEngine.prototype.createRawCubeTexture = function(data, size, format, type, generateMipMaps, invertY, samplingMode, compression = null) {
  const texture = new InternalTexture(
    this,
    8
    /* InternalTextureSource.CubeRaw */
  );
  if (type === 1 && !this._caps.textureFloatLinearFiltering) {
    generateMipMaps = false;
    samplingMode = 1;
    Logger.Warn("Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.");
  } else if (type === 2 && !this._caps.textureHalfFloatLinearFiltering) {
    generateMipMaps = false;
    samplingMode = 1;
    Logger.Warn("Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.");
  } else if (type === 1 && !this._caps.textureFloatRender) {
    generateMipMaps = false;
    Logger.Warn("Render to float textures is not supported. Mipmap generation forced to false.");
  } else if (type === 2 && !this._caps.colorBufferFloat) {
    generateMipMaps = false;
    Logger.Warn("Render to half float textures is not supported. Mipmap generation forced to false.");
  }
  texture.isCube = true;
  texture._originalFormat = format;
  texture.format = format === 4 ? 5 : format;
  texture.type = type;
  texture.generateMipMaps = generateMipMaps;
  texture.width = size;
  texture.height = size;
  texture.samplingMode = samplingMode;
  if (!this._doNotHandleContextLost) {
    texture._bufferViewArray = data;
  }
  texture.invertY = invertY;
  texture._compression = compression;
  texture._cachedWrapU = 0;
  texture._cachedWrapV = 0;
  this._textureHelper.createGPUTextureForInternalTexture(texture);
  if (format === 4) {
    const gpuTextureWrapper = texture._hardwareTexture;
    gpuTextureWrapper._originalFormatIsRGB = true;
  }
  if (data) {
    this.updateRawCubeTexture(texture, data, format, type, invertY, compression);
  }
  texture.isReady = true;
  return texture;
};
ThinWebGPUEngine.prototype.updateRawCubeTexture = function(texture, bufferView, _format, type, invertY, compression = null) {
  texture._bufferViewArray = bufferView;
  texture.invertY = invertY;
  texture._compression = compression;
  const gpuTextureWrapper = texture._hardwareTexture;
  const needConversion = gpuTextureWrapper._originalFormatIsRGB;
  const faces = [0, 2, 4, 1, 3, 5];
  const data = [];
  for (let i = 0; i < bufferView.length; ++i) {
    let faceData = bufferView[faces[i]];
    if (needConversion) {
      faceData = _convertRGBtoRGBATextureData(faceData, texture.width, texture.height, type);
    }
    data.push(new Uint8Array(faceData.buffer, faceData.byteOffset, faceData.byteLength));
  }
  this._textureHelper.updateCubeTextures(data, gpuTextureWrapper.underlyingResource, texture.width, texture.height, gpuTextureWrapper.format, invertY, false, 0, 0);
  if (texture.generateMipMaps) {
    this._generateMipmaps(texture, this._uploadEncoder);
  }
  texture.isReady = true;
};
ThinWebGPUEngine.prototype.createRawCubeTextureFromUrl = function(url, scene, size, format, type, noMipmap, callback, mipmapGenerator, onLoad = null, onError = null, samplingMode = 3, invertY = false) {
  const texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);
  scene?.addPendingData(texture);
  texture.url = url;
  texture.isReady = false;
  this._internalTexturesCache.push(texture);
  const onerror = (request, exception) => {
    scene?.removePendingData(texture);
    if (onError && request) {
      onError(request.status + " " + request.statusText, exception);
    }
  };
  const internalCallback = (data) => {
    const width = texture.width;
    const faceDataArrays = callback(data);
    if (!faceDataArrays) {
      return;
    }
    if (mipmapGenerator) {
      const needConversion = format === 4;
      const mipData = mipmapGenerator(faceDataArrays);
      const gpuTextureWrapper = texture._hardwareTexture;
      const faces = [0, 1, 2, 3, 4, 5];
      for (let level = 0; level < mipData.length; level++) {
        const mipSize = width >> level;
        const allFaces = [];
        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
          let mipFaceData = mipData[level][faces[faceIndex]];
          if (needConversion) {
            mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);
          }
          allFaces.push(new Uint8Array(mipFaceData.buffer, mipFaceData.byteOffset, mipFaceData.byteLength));
        }
        this._textureHelper.updateCubeTextures(allFaces, gpuTextureWrapper.underlyingResource, mipSize, mipSize, gpuTextureWrapper.format, invertY, false, 0, 0);
      }
    } else {
      this.updateRawCubeTexture(texture, faceDataArrays, format, type, invertY);
    }
    texture.isReady = true;
    scene?.removePendingData(texture);
    if (onLoad) {
      onLoad();
    }
  };
  this._loadFile(url, (data) => {
    internalCallback(data);
  }, void 0, scene?.offlineProvider, true, onerror);
  return texture;
};
ThinWebGPUEngine.prototype.createRawTexture3D = function(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression = null, textureType = 0, creationFlags = 0) {
  const source = 10;
  const texture = new InternalTexture(this, source);
  texture.baseWidth = width;
  texture.baseHeight = height;
  texture.baseDepth = depth;
  texture.width = width;
  texture.height = height;
  texture.depth = depth;
  texture.format = format;
  texture.type = textureType;
  texture.generateMipMaps = generateMipMaps;
  texture.samplingMode = samplingMode;
  texture.is3D = true;
  texture._creationFlags = creationFlags;
  if (!this._doNotHandleContextLost) {
    texture._bufferView = data;
  }
  this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, void 0, creationFlags);
  this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);
  this._internalTexturesCache.push(texture);
  return texture;
};
ThinWebGPUEngine.prototype.updateRawTexture3D = function(texture, bufferView, format, invertY, compression = null, textureType = 0) {
  if (!this._doNotHandleContextLost) {
    texture._bufferView = bufferView;
    texture.format = format;
    texture.invertY = invertY;
    texture._compression = compression;
  }
  if (bufferView) {
    const gpuTextureWrapper = texture._hardwareTexture;
    const needConversion = format === 4;
    if (needConversion) {
      bufferView = _convertRGBtoRGBATextureData(bufferView, texture.width, texture.height, textureType);
    }
    const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
    this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);
    if (texture.generateMipMaps) {
      this._generateMipmaps(texture, this._uploadEncoder);
    }
  }
  texture.isReady = true;
};
ThinWebGPUEngine.prototype.createRawTexture2DArray = function(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression = null, textureType = 0, creationFlags = 0) {
  const source = 11;
  const texture = new InternalTexture(this, source);
  texture.baseWidth = width;
  texture.baseHeight = height;
  texture.baseDepth = depth;
  texture.width = width;
  texture.height = height;
  texture.depth = depth;
  texture.format = format;
  texture.type = textureType;
  texture.generateMipMaps = generateMipMaps;
  texture.samplingMode = samplingMode;
  texture.is2DArray = true;
  texture._creationFlags = creationFlags;
  if (!this._doNotHandleContextLost) {
    texture._bufferView = data;
  }
  this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, depth, creationFlags);
  this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);
  this._internalTexturesCache.push(texture);
  return texture;
};
ThinWebGPUEngine.prototype.updateRawTexture2DArray = function(texture, bufferView, format, invertY, compression = null, textureType = 0) {
  if (!this._doNotHandleContextLost) {
    texture._bufferView = bufferView;
    texture.format = format;
    texture.invertY = invertY;
    texture._compression = compression;
  }
  if (bufferView) {
    const gpuTextureWrapper = texture._hardwareTexture;
    const needConversion = format === 4;
    if (needConversion) {
      bufferView = _convertRGBtoRGBATextureData(bufferView, texture.width, texture.height, textureType);
    }
    const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
    this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);
    if (texture.generateMipMaps) {
      this._generateMipmaps(texture, this._uploadEncoder);
    }
  }
  texture.isReady = true;
};
function _convertRGBtoRGBATextureData(rgbData, width, height, textureType) {
  let rgbaData;
  let val1 = 1;
  if (textureType === 1) {
    rgbaData = new Float32Array(width * height * 4);
  } else if (textureType === 2) {
    rgbaData = new Uint16Array(width * height * 4);
    val1 = 15360;
  } else if (textureType === 7) {
    rgbaData = new Uint32Array(width * height * 4);
  } else {
    rgbaData = new Uint8Array(width * height * 4);
  }
  for (let x = 0; x < width; x++) {
    for (let y = 0; y < height; y++) {
      const index = (y * width + x) * 3;
      const newIndex = (y * width + x) * 4;
      rgbaData[newIndex + 0] = rgbData[index + 0];
      rgbaData[newIndex + 1] = rgbData[index + 1];
      rgbaData[newIndex + 2] = rgbData[index + 2];
      rgbaData[newIndex + 3] = val1;
    }
  }
  return rgbaData;
}

// node_modules/@babylonjs/core/Engines/WebGPU/Extensions/engine.readTexture.js
ThinWebGPUEngine.prototype._readTexturePixels = function(texture, width, height, faceIndex = -1, level = 0, buffer = null, flushRenderer = true, noDataConversion = false, x = 0, y = 0) {
  const gpuTextureWrapper = texture._hardwareTexture;
  if (flushRenderer) {
    this.flushFramebuffer();
  }
  return this._textureHelper.readPixels(gpuTextureWrapper.underlyingResource, x, y, width, height, gpuTextureWrapper.format, faceIndex, level, buffer, noDataConversion);
};
ThinWebGPUEngine.prototype._readTexturePixelsSync = function() {
  throw "_readTexturePixelsSync is unsupported in WebGPU!";
};

// node_modules/@babylonjs/core/Engines/WebGPU/Extensions/engine.cubeTexture.js
ThinWebGPUEngine.prototype._createDepthStencilCubeTexture = function(size, options) {
  const internalTexture = new InternalTexture(
    this,
    options.generateStencil ? 12 : 14
    /* InternalTextureSource.Depth */
  );
  internalTexture.isCube = true;
  internalTexture.label = options.label;
  const internalOptions = {
    bilinearFiltering: false,
    comparisonFunction: 0,
    generateStencil: false,
    samples: 1,
    depthTextureFormat: options.generateStencil ? 13 : 14,
    ...options
  };
  internalTexture.format = internalOptions.depthTextureFormat;
  this._setupDepthStencilTexture(internalTexture, size, internalOptions.bilinearFiltering, internalOptions.comparisonFunction, internalOptions.samples);
  this._textureHelper.createGPUTextureForInternalTexture(internalTexture);
  const gpuTextureWrapper = internalTexture._hardwareTexture;
  internalTexture.type = WebGPUTextureHelper.GetTextureTypeFromFormat(gpuTextureWrapper.format);
  this._internalTexturesCache.push(internalTexture);
  return internalTexture;
};
ThinWebGPUEngine.prototype.createCubeTexture = function(rootUrl, scene, files, noMipmap, onLoad = null, onError = null, format, forcedExtension = null, createPolynomials = false, lodScale = 0, lodOffset = 0, fallback = null, loaderOptions, useSRGBBuffer = false, buffer = null) {
  return this.createCubeTextureBase(rootUrl, scene, files, !!noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, fallback, null, (texture, imgs) => {
    const imageBitmaps = imgs;
    const width = imageBitmaps[0].width;
    const height = width;
    this._setCubeMapTextureParams(texture, !noMipmap);
    texture.format = format ?? -1;
    const gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);
    this._textureHelper.updateCubeTextures(imageBitmaps, gpuTextureWrapper.underlyingResource, width, height, gpuTextureWrapper.format, false, false, 0, 0);
    if (!noMipmap) {
      this._generateMipmaps(texture, this._uploadEncoder);
    }
    texture.isReady = true;
    texture.onLoadedObservable.notifyObservers(texture);
    texture.onLoadedObservable.clear();
    if (onLoad) {
      onLoad();
    }
  }, !!useSRGBBuffer, buffer);
};
ThinWebGPUEngine.prototype._setCubeMapTextureParams = function(texture, loadMipmap, maxLevel) {
  texture.samplingMode = loadMipmap ? 3 : 2;
  texture._cachedWrapU = 0;
  texture._cachedWrapV = 0;
  if (maxLevel) {
    texture._maxLodLevel = maxLevel;
  }
};
ThinWebGPUEngine.prototype.generateMipMapsForCubemap = function(texture) {
  if (texture.generateMipMaps) {
    const gpuTexture = texture._hardwareTexture?.underlyingResource;
    if (!gpuTexture) {
      this._textureHelper.createGPUTextureForInternalTexture(texture);
    }
    this._generateMipmaps(texture);
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuRenderTargetWrapper.js
var WebGPURenderTargetWrapper = class extends RenderTargetWrapper {
  /**
   * Initializes the render target wrapper
   * @param isMulti true if the wrapper is a multi render target
   * @param isCube true if the wrapper should render to a cube texture
   * @param size size of the render target (width/height/layers)
   * @param engine engine used to create the render target
   * @param label defines the label to use for the wrapper (for debugging purpose only)
   */
  constructor(isMulti, isCube, size, engine, label) {
    super(isMulti, isCube, size, engine, label);
    if (engine.enableGPUTimingMeasurements) {
      this.gpuTimeInFrame = new WebGPUPerfCounter();
    }
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/Extensions/engine.renderTarget.js
ThinWebGPUEngine.prototype._createHardwareRenderTargetWrapper = function(isMulti, isCube, size) {
  const rtWrapper = new WebGPURenderTargetWrapper(isMulti, isCube, size, this);
  this._renderTargetWrapperCache.push(rtWrapper);
  return rtWrapper;
};
ThinWebGPUEngine.prototype.createRenderTargetTexture = function(size, options) {
  const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size);
  const fullOptions = {};
  if (options !== void 0 && typeof options === "object") {
    fullOptions.generateMipMaps = options.generateMipMaps;
    fullOptions.generateDepthBuffer = options.generateDepthBuffer === void 0 ? true : options.generateDepthBuffer;
    fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && options.generateStencilBuffer;
    fullOptions.samplingMode = options.samplingMode === void 0 ? 3 : options.samplingMode;
    fullOptions.creationFlags = options.creationFlags ?? 0;
    fullOptions.noColorAttachment = !!options.noColorAttachment;
    fullOptions.colorAttachment = options.colorAttachment;
    fullOptions.samples = options.samples;
    fullOptions.label = options.label;
    fullOptions.format = options.format;
    fullOptions.type = options.type;
  } else {
    fullOptions.generateMipMaps = options;
    fullOptions.generateDepthBuffer = true;
    fullOptions.generateStencilBuffer = false;
    fullOptions.samplingMode = 3;
    fullOptions.creationFlags = 0;
    fullOptions.noColorAttachment = false;
  }
  const texture = fullOptions.colorAttachment || (fullOptions.noColorAttachment ? null : this._createInternalTexture(
    size,
    fullOptions,
    true,
    5
    /* InternalTextureSource.RenderTarget */
  ));
  rtWrapper.label = fullOptions.label ?? "RenderTargetWrapper";
  rtWrapper._samples = fullOptions.colorAttachment?.samples ?? fullOptions.samples ?? 1;
  rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;
  rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;
  rtWrapper.setTextures(texture);
  if (rtWrapper._generateDepthBuffer || rtWrapper._generateStencilBuffer) {
    rtWrapper.createDepthStencilTexture(
      0,
      false,
      // force false as filtering is not supported for depth textures
      rtWrapper._generateStencilBuffer,
      rtWrapper.samples,
      fullOptions.generateStencilBuffer ? 13 : 14,
      fullOptions.label ? fullOptions.label + "-DepthStencil" : void 0
    );
  }
  if (texture && !fullOptions.colorAttachment) {
    if (options !== void 0 && typeof options === "object" && options.createMipMaps && !fullOptions.generateMipMaps) {
      texture.generateMipMaps = true;
    }
    this._textureHelper.createGPUTextureForInternalTexture(texture, void 0, void 0, void 0, fullOptions.creationFlags);
    if (options !== void 0 && typeof options === "object" && options.createMipMaps && !fullOptions.generateMipMaps) {
      texture.generateMipMaps = false;
    }
  }
  return rtWrapper;
};
ThinWebGPUEngine.prototype._createDepthStencilTexture = function(size, options, wrapper) {
  const internalOptions = {
    bilinearFiltering: false,
    comparisonFunction: 0,
    generateStencil: false,
    samples: 1,
    depthTextureFormat: options.generateStencil ? 13 : 14,
    ...options
  };
  const hasStencil = HasStencilAspect(internalOptions.depthTextureFormat);
  wrapper._depthStencilTextureWithStencil = hasStencil;
  const internalTexture = new InternalTexture(
    this,
    hasStencil ? 12 : 14
    /* InternalTextureSource.Depth */
  );
  internalTexture.label = options.label;
  internalTexture.format = internalOptions.depthTextureFormat;
  internalTexture.type = GetTypeForDepthTexture(internalTexture.format);
  this._setupDepthStencilTexture(internalTexture, size, internalOptions.bilinearFiltering, internalOptions.comparisonFunction, internalOptions.samples);
  this._textureHelper.createGPUTextureForInternalTexture(internalTexture);
  this._internalTexturesCache.push(internalTexture);
  return internalTexture;
};
ThinWebGPUEngine.prototype._setupDepthStencilTexture = function(internalTexture, size, bilinearFiltering, comparisonFunction, samples = 1) {
  const width = size.width ?? size;
  const height = size.height ?? size;
  const layers = size.layers || 0;
  const depth = size.depth || 0;
  internalTexture.baseWidth = width;
  internalTexture.baseHeight = height;
  internalTexture.width = width;
  internalTexture.height = height;
  internalTexture.is2DArray = layers > 0;
  internalTexture.is3D = depth > 0;
  internalTexture.depth = layers || depth;
  internalTexture.isReady = true;
  internalTexture.samples = samples;
  internalTexture.generateMipMaps = false;
  internalTexture.samplingMode = bilinearFiltering ? 2 : 1;
  internalTexture.type = 1;
  internalTexture._comparisonFunction = comparisonFunction;
  internalTexture._cachedWrapU = 0;
  internalTexture._cachedWrapV = 0;
};
ThinWebGPUEngine.prototype.updateRenderTargetTextureSampleCount = function(rtWrapper, samples) {
  if (!rtWrapper || !rtWrapper.texture || rtWrapper.samples === samples) {
    return samples;
  }
  samples = Math.min(samples, this.getCaps().maxMSAASamples);
  this._textureHelper.createMSAATexture(rtWrapper.texture, samples);
  if (rtWrapper._depthStencilTexture) {
    this._textureHelper.createMSAATexture(rtWrapper._depthStencilTexture, samples);
    rtWrapper._depthStencilTexture.samples = samples;
  }
  rtWrapper._samples = samples;
  rtWrapper.texture.samples = samples;
  return samples;
};

// node_modules/@babylonjs/core/Engines/WebGPU/Extensions/engine.renderTargetTexture.js
ThinWebGPUEngine.prototype.setDepthStencilTexture = function(channel, uniform, texture, name3) {
  if (!texture || !texture.depthStencilTexture) {
    this._setTexture(channel, null, void 0, void 0, name3);
  } else {
    this._setTexture(channel, texture, false, true, name3);
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/Extensions/engine.renderTargetCube.js
ThinWebGPUEngine.prototype.createRenderTargetCubeTexture = function(size, options) {
  const rtWrapper = this._createHardwareRenderTargetWrapper(false, true, size);
  const fullOptions = {
    generateMipMaps: true,
    generateDepthBuffer: true,
    generateStencilBuffer: false,
    type: 0,
    samplingMode: 3,
    format: 5,
    samples: 1,
    ...options
  };
  fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && fullOptions.generateStencilBuffer;
  rtWrapper.label = fullOptions.label ?? "RenderTargetWrapper";
  rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;
  rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer;
  const texture = new InternalTexture(
    this,
    5
    /* InternalTextureSource.RenderTarget */
  );
  texture.width = size;
  texture.height = size;
  texture.depth = 0;
  texture.isReady = true;
  texture.isCube = true;
  texture.samples = fullOptions.samples;
  texture.generateMipMaps = fullOptions.generateMipMaps;
  texture.samplingMode = fullOptions.samplingMode;
  texture.type = fullOptions.type;
  texture.format = fullOptions.format;
  this._internalTexturesCache.push(texture);
  rtWrapper.setTextures(texture);
  if (rtWrapper._generateDepthBuffer || rtWrapper._generateStencilBuffer) {
    rtWrapper.createDepthStencilTexture(0, fullOptions.samplingMode === void 0 || fullOptions.samplingMode === 2 || fullOptions.samplingMode === 2 || fullOptions.samplingMode === 3 || fullOptions.samplingMode === 3 || fullOptions.samplingMode === 5 || fullOptions.samplingMode === 6 || fullOptions.samplingMode === 7 || fullOptions.samplingMode === 11, rtWrapper._generateStencilBuffer, rtWrapper.samples);
  }
  if (options && options.createMipMaps && !fullOptions.generateMipMaps) {
    texture.generateMipMaps = true;
  }
  this._textureHelper.createGPUTextureForInternalTexture(texture);
  if (options && options.createMipMaps && !fullOptions.generateMipMaps) {
    texture.generateMipMaps = false;
  }
  return rtWrapper;
};

// node_modules/@babylonjs/core/Misc/coroutine.js
function inlineScheduler(coroutine, onStep, onError) {
  try {
    const step = coroutine.next();
    if (step.done) {
      onStep(step);
    } else if (!step.value) {
      onStep(step);
    } else {
      step.value.then(() => {
        step.value = void 0;
        onStep(step);
      }, onError);
    }
  } catch (error) {
    onError(error);
  }
}
function createYieldingScheduler(yieldAfterMS = 25) {
  let startTime;
  return (coroutine, onStep, onError) => {
    const currentTime = performance.now();
    if (startTime === void 0 || currentTime - startTime > yieldAfterMS) {
      startTime = currentTime;
      setTimeout(() => {
        inlineScheduler(coroutine, onStep, onError);
      }, 0);
    } else {
      inlineScheduler(coroutine, onStep, onError);
    }
  };
}
function runCoroutine(coroutine, scheduler, onSuccess, onError, abortSignal) {
  const resume = () => {
    let reschedule;
    const onStep = (stepResult) => {
      if (stepResult.done) {
        onSuccess(stepResult.value);
      } else {
        if (reschedule === void 0) {
          reschedule = true;
        } else {
          resume();
        }
      }
    };
    do {
      reschedule = void 0;
      if (!abortSignal || !abortSignal.aborted) {
        scheduler(coroutine, onStep, onError);
      } else {
        onError(new Error("Aborted"));
      }
      if (reschedule === void 0) {
        reschedule = false;
      }
    } while (reschedule);
  };
  resume();
}
function runCoroutineSync(coroutine, abortSignal) {
  let result;
  runCoroutine(coroutine, inlineScheduler, (r) => result = r, (e) => {
    throw e;
  }, abortSignal);
  return result;
}
function runCoroutineAsync(coroutine, scheduler, abortSignal) {
  return new Promise((resolve, reject) => {
    runCoroutine(coroutine, scheduler, resolve, reject, abortSignal);
  });
}
function makeSyncFunction(coroutineFactory, abortSignal) {
  return (...params) => {
    return runCoroutineSync(coroutineFactory(...params), abortSignal);
  };
}
function makeAsyncFunction(coroutineFactory, scheduler, abortSignal) {
  return (...params) => {
    return runCoroutineAsync(coroutineFactory(...params), scheduler, abortSignal);
  };
}

// node_modules/@babylonjs/core/Collisions/intersectionInfo.js
var IntersectionInfo = class {
  constructor(bu, bv, distance) {
    this.bu = bu;
    this.bv = bv;
    this.distance = distance;
    this.faceId = 0;
    this.subMeshId = 0;
  }
};

// node_modules/@babylonjs/core/Culling/boundingBox.js
var BoundingBox = class _BoundingBox {
  /**
   * Creates a new bounding box
   * @param min defines the minimum vector (in local space)
   * @param max defines the maximum vector (in local space)
   * @param worldMatrix defines the new world matrix
   */
  constructor(min, max, worldMatrix) {
    this.vectors = BuildArray(8, Vector3.Zero);
    this.center = Vector3.Zero();
    this.centerWorld = Vector3.Zero();
    this.extendSize = Vector3.Zero();
    this.extendSizeWorld = Vector3.Zero();
    this.directions = BuildArray(3, Vector3.Zero);
    this.vectorsWorld = BuildArray(8, Vector3.Zero);
    this.minimumWorld = Vector3.Zero();
    this.maximumWorld = Vector3.Zero();
    this.minimum = Vector3.Zero();
    this.maximum = Vector3.Zero();
    this._drawWrapperFront = null;
    this._drawWrapperBack = null;
    this.reConstruct(min, max, worldMatrix);
  }
  // Methods
  /**
   * Recreates the entire bounding box from scratch as if we call the constructor in place
   * @param min defines the new minimum vector (in local space)
   * @param max defines the new maximum vector (in local space)
   * @param worldMatrix defines the new world matrix
   */
  reConstruct(min, max, worldMatrix) {
    const minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;
    const vectors = this.vectors;
    this.minimum.copyFromFloats(minX, minY, minZ);
    this.maximum.copyFromFloats(maxX, maxY, maxZ);
    vectors[0].copyFromFloats(minX, minY, minZ);
    vectors[1].copyFromFloats(maxX, maxY, maxZ);
    vectors[2].copyFromFloats(maxX, minY, minZ);
    vectors[3].copyFromFloats(minX, maxY, minZ);
    vectors[4].copyFromFloats(minX, minY, maxZ);
    vectors[5].copyFromFloats(maxX, maxY, minZ);
    vectors[6].copyFromFloats(minX, maxY, maxZ);
    vectors[7].copyFromFloats(maxX, minY, maxZ);
    max.addToRef(min, this.center).scaleInPlace(0.5);
    max.subtractToRef(min, this.extendSize).scaleInPlace(0.5);
    this._worldMatrix = worldMatrix || Matrix.IdentityReadOnly;
    this._update(this._worldMatrix);
  }
  /**
   * Scale the current bounding box by applying a scale factor
   * @param factor defines the scale factor to apply
   * @returns the current bounding box
   */
  scale(factor) {
    const tmpVectors = _BoundingBox._TmpVector3;
    const diff = this.maximum.subtractToRef(this.minimum, tmpVectors[0]);
    const len = diff.length();
    diff.normalizeFromLength(len);
    const distance = len * factor;
    const newRadius = diff.scaleInPlace(distance * 0.5);
    const min = this.center.subtractToRef(newRadius, tmpVectors[1]);
    const max = this.center.addToRef(newRadius, tmpVectors[2]);
    this.reConstruct(min, max, this._worldMatrix);
    return this;
  }
  /**
   * Gets the world matrix of the bounding box
   * @returns a matrix
   */
  getWorldMatrix() {
    return this._worldMatrix;
  }
  /**
   * @internal
   */
  _update(world) {
    const minWorld = this.minimumWorld;
    const maxWorld = this.maximumWorld;
    const directions = this.directions;
    const vectorsWorld = this.vectorsWorld;
    const vectors = this.vectors;
    if (!world.isIdentity()) {
      minWorld.setAll(Number.MAX_VALUE);
      maxWorld.setAll(-Number.MAX_VALUE);
      for (let index = 0; index < 8; ++index) {
        const v = vectorsWorld[index];
        Vector3.TransformCoordinatesToRef(vectors[index], world, v);
        minWorld.minimizeInPlace(v);
        maxWorld.maximizeInPlace(v);
      }
      maxWorld.subtractToRef(minWorld, this.extendSizeWorld).scaleInPlace(0.5);
      maxWorld.addToRef(minWorld, this.centerWorld).scaleInPlace(0.5);
    } else {
      minWorld.copyFrom(this.minimum);
      maxWorld.copyFrom(this.maximum);
      for (let index = 0; index < 8; ++index) {
        vectorsWorld[index].copyFrom(vectors[index]);
      }
      this.extendSizeWorld.copyFrom(this.extendSize);
      this.centerWorld.copyFrom(this.center);
    }
    Vector3.FromArrayToRef(world.m, 0, directions[0]);
    Vector3.FromArrayToRef(world.m, 4, directions[1]);
    Vector3.FromArrayToRef(world.m, 8, directions[2]);
    this._worldMatrix = world;
  }
  /**
   * Tests if the bounding box is intersecting the frustum planes
   * @param frustumPlanes defines the frustum planes to test
   * @returns true if there is an intersection
   */
  isInFrustum(frustumPlanes) {
    return _BoundingBox.IsInFrustum(this.vectorsWorld, frustumPlanes);
  }
  /**
   * Tests if the bounding box is entirely inside the frustum planes
   * @param frustumPlanes defines the frustum planes to test
   * @returns true if there is an inclusion
   */
  isCompletelyInFrustum(frustumPlanes) {
    return _BoundingBox.IsCompletelyInFrustum(this.vectorsWorld, frustumPlanes);
  }
  /**
   * Tests if a point is inside the bounding box
   * @param point defines the point to test
   * @returns true if the point is inside the bounding box
   */
  intersectsPoint(point) {
    const min = this.minimumWorld;
    const max = this.maximumWorld;
    const minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;
    const pointX = point.x, pointY = point.y, pointZ = point.z;
    const delta = -Epsilon;
    if (maxX - pointX < delta || delta > pointX - minX) {
      return false;
    }
    if (maxY - pointY < delta || delta > pointY - minY) {
      return false;
    }
    if (maxZ - pointZ < delta || delta > pointZ - minZ) {
      return false;
    }
    return true;
  }
  /**
   * Tests if the bounding box intersects with a bounding sphere
   * @param sphere defines the sphere to test
   * @returns true if there is an intersection
   */
  intersectsSphere(sphere) {
    return _BoundingBox.IntersectsSphere(this.minimumWorld, this.maximumWorld, sphere.centerWorld, sphere.radiusWorld);
  }
  /**
   * Tests if the bounding box intersects with a box defined by a min and max vectors
   * @param min defines the min vector to use
   * @param max defines the max vector to use
   * @returns true if there is an intersection
   */
  intersectsMinMax(min, max) {
    const myMin = this.minimumWorld;
    const myMax = this.maximumWorld;
    const myMinX = myMin.x, myMinY = myMin.y, myMinZ = myMin.z, myMaxX = myMax.x, myMaxY = myMax.y, myMaxZ = myMax.z;
    const minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;
    if (myMaxX < minX || myMinX > maxX) {
      return false;
    }
    if (myMaxY < minY || myMinY > maxY) {
      return false;
    }
    if (myMaxZ < minZ || myMinZ > maxZ) {
      return false;
    }
    return true;
  }
  /**
   * Disposes the resources of the class
   */
  dispose() {
    this._drawWrapperFront?.dispose();
    this._drawWrapperBack?.dispose();
  }
  // Statics
  /**
   * Tests if two bounding boxes are intersections
   * @param box0 defines the first box to test
   * @param box1 defines the second box to test
   * @returns true if there is an intersection
   */
  static Intersects(box0, box1) {
    return box0.intersectsMinMax(box1.minimumWorld, box1.maximumWorld);
  }
  /**
   * Tests if a bounding box defines by a min/max vectors intersects a sphere
   * @param minPoint defines the minimum vector of the bounding box
   * @param maxPoint defines the maximum vector of the bounding box
   * @param sphereCenter defines the sphere center
   * @param sphereRadius defines the sphere radius
   * @returns true if there is an intersection
   */
  static IntersectsSphere(minPoint, maxPoint, sphereCenter, sphereRadius) {
    const vector = _BoundingBox._TmpVector3[0];
    Vector3.ClampToRef(sphereCenter, minPoint, maxPoint, vector);
    const num = Vector3.DistanceSquared(sphereCenter, vector);
    return num <= sphereRadius * sphereRadius;
  }
  /**
   * Tests if a bounding box defined with 8 vectors is entirely inside frustum planes
   * @param boundingVectors defines an array of 8 vectors representing a bounding box
   * @param frustumPlanes defines the frustum planes to test
   * @returns true if there is an inclusion
   */
  static IsCompletelyInFrustum(boundingVectors, frustumPlanes) {
    for (let p = 0; p < 6; ++p) {
      const frustumPlane = frustumPlanes[p];
      for (let i = 0; i < 8; ++i) {
        if (frustumPlane.dotCoordinate(boundingVectors[i]) < 0) {
          return false;
        }
      }
    }
    return true;
  }
  /**
   * Tests if a bounding box defined with 8 vectors intersects frustum planes
   * @param boundingVectors defines an array of 8 vectors representing a bounding box
   * @param frustumPlanes defines the frustum planes to test
   * @returns true if there is an intersection
   */
  static IsInFrustum(boundingVectors, frustumPlanes) {
    for (let p = 0; p < 6; ++p) {
      let canReturnFalse = true;
      const frustumPlane = frustumPlanes[p];
      for (let i = 0; i < 8; ++i) {
        if (frustumPlane.dotCoordinate(boundingVectors[i]) >= 0) {
          canReturnFalse = false;
          break;
        }
      }
      if (canReturnFalse) {
        return false;
      }
    }
    return true;
  }
};
BoundingBox._TmpVector3 = BuildArray(3, Vector3.Zero);

// node_modules/@babylonjs/core/Culling/boundingSphere.js
var BoundingSphere = class _BoundingSphere {
  /**
   * Creates a new bounding sphere
   * @param min defines the minimum vector (in local space)
   * @param max defines the maximum vector (in local space)
   * @param worldMatrix defines the new world matrix
   */
  constructor(min, max, worldMatrix) {
    this.center = Vector3.Zero();
    this.centerWorld = Vector3.Zero();
    this.minimum = Vector3.Zero();
    this.maximum = Vector3.Zero();
    this.reConstruct(min, max, worldMatrix);
  }
  /**
   * Recreates the entire bounding sphere from scratch as if we call the constructor in place
   * @param min defines the new minimum vector (in local space)
   * @param max defines the new maximum vector (in local space)
   * @param worldMatrix defines the new world matrix
   */
  reConstruct(min, max, worldMatrix) {
    this.minimum.copyFrom(min);
    this.maximum.copyFrom(max);
    const distance = Vector3.Distance(min, max);
    max.addToRef(min, this.center).scaleInPlace(0.5);
    this.radius = distance * 0.5;
    this._update(worldMatrix || Matrix.IdentityReadOnly);
  }
  /**
   * Scale the current bounding sphere by applying a scale factor
   * @param factor defines the scale factor to apply
   * @returns the current bounding box
   */
  scale(factor) {
    const newRadius = this.radius * factor;
    const tmpVectors = _BoundingSphere._TmpVector3;
    const tempRadiusVector = tmpVectors[0].setAll(newRadius);
    const min = this.center.subtractToRef(tempRadiusVector, tmpVectors[1]);
    const max = this.center.addToRef(tempRadiusVector, tmpVectors[2]);
    this.reConstruct(min, max, this._worldMatrix);
    return this;
  }
  /**
   * Gets the world matrix of the bounding box
   * @returns a matrix
   */
  getWorldMatrix() {
    return this._worldMatrix;
  }
  // Methods
  /**
   * @internal
   */
  _update(worldMatrix) {
    if (!worldMatrix.isIdentity()) {
      Vector3.TransformCoordinatesToRef(this.center, worldMatrix, this.centerWorld);
      const tempVector = _BoundingSphere._TmpVector3[0];
      Vector3.TransformNormalFromFloatsToRef(1, 1, 1, worldMatrix, tempVector);
      this.radiusWorld = Math.max(Math.abs(tempVector.x), Math.abs(tempVector.y), Math.abs(tempVector.z)) * this.radius;
    } else {
      this.centerWorld.copyFrom(this.center);
      this.radiusWorld = this.radius;
    }
  }
  /**
   * Tests if the bounding sphere is intersecting the frustum planes
   * @param frustumPlanes defines the frustum planes to test
   * @returns true if there is an intersection
   */
  isInFrustum(frustumPlanes) {
    const center = this.centerWorld;
    const radius = this.radiusWorld;
    for (let i = 0; i < 6; i++) {
      if (frustumPlanes[i].dotCoordinate(center) <= -radius) {
        return false;
      }
    }
    return true;
  }
  /**
   * Tests if the bounding sphere center is in between the frustum planes.
   * Used for optimistic fast inclusion.
   * @param frustumPlanes defines the frustum planes to test
   * @returns true if the sphere center is in between the frustum planes
   */
  isCenterInFrustum(frustumPlanes) {
    const center = this.centerWorld;
    for (let i = 0; i < 6; i++) {
      if (frustumPlanes[i].dotCoordinate(center) < 0) {
        return false;
      }
    }
    return true;
  }
  /**
   * Tests if a point is inside the bounding sphere
   * @param point defines the point to test
   * @returns true if the point is inside the bounding sphere
   */
  intersectsPoint(point) {
    const squareDistance = Vector3.DistanceSquared(this.centerWorld, point);
    if (this.radiusWorld * this.radiusWorld < squareDistance) {
      return false;
    }
    return true;
  }
  // Statics
  /**
   * Checks if two sphere intersect
   * @param sphere0 sphere 0
   * @param sphere1 sphere 1
   * @returns true if the spheres intersect
   */
  static Intersects(sphere0, sphere1) {
    const squareDistance = Vector3.DistanceSquared(sphere0.centerWorld, sphere1.centerWorld);
    const radiusSum = sphere0.radiusWorld + sphere1.radiusWorld;
    if (radiusSum * radiusSum < squareDistance) {
      return false;
    }
    return true;
  }
  /**
   * Creates a sphere from a center and a radius
   * @param center The center
   * @param radius radius
   * @param matrix Optional worldMatrix
   * @returns The sphere
   */
  static CreateFromCenterAndRadius(center, radius, matrix) {
    this._TmpVector3[0].copyFrom(center);
    this._TmpVector3[1].copyFromFloats(0, 0, radius);
    this._TmpVector3[2].copyFrom(center);
    this._TmpVector3[0].addInPlace(this._TmpVector3[1]);
    this._TmpVector3[2].subtractInPlace(this._TmpVector3[1]);
    const sphere = new _BoundingSphere(this._TmpVector3[0], this._TmpVector3[2]);
    if (matrix) {
      sphere._worldMatrix = matrix;
    } else {
      sphere._worldMatrix = Matrix.Identity();
    }
    return sphere;
  }
};
BoundingSphere._TmpVector3 = BuildArray(3, Vector3.Zero);

// node_modules/@babylonjs/core/Culling/boundingInfo.js
var _result0 = { min: 0, max: 0 };
var _result1 = { min: 0, max: 0 };
var computeBoxExtents = (axis, box, result) => {
  const p = Vector3.Dot(box.centerWorld, axis);
  const r0 = Math.abs(Vector3.Dot(box.directions[0], axis)) * box.extendSize.x;
  const r1 = Math.abs(Vector3.Dot(box.directions[1], axis)) * box.extendSize.y;
  const r2 = Math.abs(Vector3.Dot(box.directions[2], axis)) * box.extendSize.z;
  const r = r0 + r1 + r2;
  result.min = p - r;
  result.max = p + r;
};
var axisOverlap = (axis, box0, box1) => {
  computeBoxExtents(axis, box0, _result0);
  computeBoxExtents(axis, box1, _result1);
  return !(_result0.min > _result1.max || _result1.min > _result0.max);
};
var BoundingInfo = class _BoundingInfo {
  /**
   * Constructs bounding info
   * @param minimum min vector of the bounding box/sphere
   * @param maximum max vector of the bounding box/sphere
   * @param worldMatrix defines the new world matrix
   */
  constructor(minimum, maximum, worldMatrix) {
    this._isLocked = false;
    this.boundingBox = new BoundingBox(minimum, maximum, worldMatrix);
    this.boundingSphere = new BoundingSphere(minimum, maximum, worldMatrix);
  }
  /**
   * Recreates the entire bounding info from scratch as if we call the constructor in place
   * @param min defines the new minimum vector (in local space)
   * @param max defines the new maximum vector (in local space)
   * @param worldMatrix defines the new world matrix
   */
  reConstruct(min, max, worldMatrix) {
    this.boundingBox.reConstruct(min, max, worldMatrix);
    this.boundingSphere.reConstruct(min, max, worldMatrix);
  }
  /**
   * min vector of the bounding box/sphere
   */
  get minimum() {
    return this.boundingBox.minimum;
  }
  /**
   * max vector of the bounding box/sphere
   */
  get maximum() {
    return this.boundingBox.maximum;
  }
  /**
   * If the info is locked and won't be updated to avoid perf overhead
   */
  get isLocked() {
    return this._isLocked;
  }
  set isLocked(value) {
    this._isLocked = value;
  }
  // Methods
  /**
   * Updates the bounding sphere and box
   * @param world world matrix to be used to update
   */
  update(world) {
    if (this._isLocked) {
      return;
    }
    this.boundingBox._update(world);
    this.boundingSphere._update(world);
  }
  /**
   * Recreate the bounding info to be centered around a specific point given a specific extend.
   * @param center New center of the bounding info
   * @param extend New extend of the bounding info
   * @returns the current bounding info
   */
  centerOn(center, extend) {
    const minimum = _BoundingInfo._TmpVector3[0].copyFrom(center).subtractInPlace(extend);
    const maximum = _BoundingInfo._TmpVector3[1].copyFrom(center).addInPlace(extend);
    this.boundingBox.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());
    this.boundingSphere.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());
    return this;
  }
  /**
   * Grows the bounding info to include the given point.
   * @param point The point that will be included in the current bounding info (in local space)
   * @returns the current bounding info
   */
  encapsulate(point) {
    const minimum = Vector3.Minimize(this.minimum, point);
    const maximum = Vector3.Maximize(this.maximum, point);
    this.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());
    return this;
  }
  /**
   * Grows the bounding info to encapsulate the given bounding info.
   * @param toEncapsulate The bounding info that will be encapsulated in the current bounding info
   * @returns the current bounding info
   */
  encapsulateBoundingInfo(toEncapsulate) {
    const invw = TmpVectors.Matrix[0];
    this.boundingBox.getWorldMatrix().invertToRef(invw);
    const v = TmpVectors.Vector3[0];
    Vector3.TransformCoordinatesToRef(toEncapsulate.boundingBox.minimumWorld, invw, v);
    this.encapsulate(v);
    Vector3.TransformCoordinatesToRef(toEncapsulate.boundingBox.maximumWorld, invw, v);
    this.encapsulate(v);
    return this;
  }
  /**
   * Scale the current bounding info by applying a scale factor
   * @param factor defines the scale factor to apply
   * @returns the current bounding info
   */
  scale(factor) {
    this.boundingBox.scale(factor);
    this.boundingSphere.scale(factor);
    return this;
  }
  /**
   * Returns `true` if the bounding info is within the frustum defined by the passed array of planes.
   * @param frustumPlanes defines the frustum to test
   * @param strategy defines the strategy to use for the culling (default is BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD)
   * The different strategies available are:
   * * BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD most accurate but slower @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_STANDARD
   * * BABYLON.AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY faster but less accurate @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY
   * * BABYLON.AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION can be faster if always visible @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_OPTIMISTIC_INCLUSION
   * * BABYLON.AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY can be faster if always visible @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY
   * @returns true if the bounding info is in the frustum planes
   */
  isInFrustum(frustumPlanes, strategy = 0) {
    const inclusionTest = strategy === 2 || strategy === 3;
    if (inclusionTest) {
      if (this.boundingSphere.isCenterInFrustum(frustumPlanes)) {
        return true;
      }
    }
    if (!this.boundingSphere.isInFrustum(frustumPlanes)) {
      return false;
    }
    const bSphereOnlyTest = strategy === 1 || strategy === 3;
    if (bSphereOnlyTest) {
      return true;
    }
    return this.boundingBox.isInFrustum(frustumPlanes);
  }
  /**
   * Gets the world distance between the min and max points of the bounding box
   */
  get diagonalLength() {
    const boundingBox = this.boundingBox;
    const diag = boundingBox.maximumWorld.subtractToRef(boundingBox.minimumWorld, _BoundingInfo._TmpVector3[0]);
    return diag.length();
  }
  /**
   * Checks if a cullable object (mesh...) is in the camera frustum
   * Unlike isInFrustum this checks the full bounding box
   * @param frustumPlanes Camera near/planes
   * @returns true if the object is in frustum otherwise false
   */
  isCompletelyInFrustum(frustumPlanes) {
    return this.boundingBox.isCompletelyInFrustum(frustumPlanes);
  }
  /**
   * @internal
   */
  _checkCollision(collider) {
    return collider._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);
  }
  /**
   * Checks if a point is inside the bounding box and bounding sphere or the mesh
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect
   * @param point the point to check intersection with
   * @returns if the point intersects
   */
  intersectsPoint(point) {
    if (!this.boundingSphere.centerWorld) {
      return false;
    }
    if (!this.boundingSphere.intersectsPoint(point)) {
      return false;
    }
    if (!this.boundingBox.intersectsPoint(point)) {
      return false;
    }
    return true;
  }
  /**
   * Checks if another bounding info intersects the bounding box and bounding sphere or the mesh
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect
   * @param boundingInfo the bounding info to check intersection with
   * @param precise if the intersection should be done using OBB
   * @returns if the bounding info intersects
   */
  intersects(boundingInfo, precise) {
    if (!BoundingSphere.Intersects(this.boundingSphere, boundingInfo.boundingSphere)) {
      return false;
    }
    if (!BoundingBox.Intersects(this.boundingBox, boundingInfo.boundingBox)) {
      return false;
    }
    if (!precise) {
      return true;
    }
    const box0 = this.boundingBox;
    const box1 = boundingInfo.boundingBox;
    if (!axisOverlap(box0.directions[0], box0, box1)) {
      return false;
    }
    if (!axisOverlap(box0.directions[1], box0, box1)) {
      return false;
    }
    if (!axisOverlap(box0.directions[2], box0, box1)) {
      return false;
    }
    if (!axisOverlap(box1.directions[0], box0, box1)) {
      return false;
    }
    if (!axisOverlap(box1.directions[1], box0, box1)) {
      return false;
    }
    if (!axisOverlap(box1.directions[2], box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[0]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[1]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[2]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[0]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[1]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[2]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[0]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[1]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[2]), box0, box1)) {
      return false;
    }
    return true;
  }
};
BoundingInfo._TmpVector3 = BuildArray(2, Vector3.Zero);

// node_modules/@babylonjs/core/Meshes/subMesh.js
var SubMesh = class _SubMesh {
  /**
   * Gets material defines used by the effect associated to the sub mesh
   */
  get materialDefines() {
    return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.defines : this._getDrawWrapper()?.defines;
  }
  /**
   * Sets material defines used by the effect associated to the sub mesh
   */
  set materialDefines(defines) {
    const drawWrapper = this._mainDrawWrapperOverride ?? this._getDrawWrapper(void 0, true);
    drawWrapper.defines = defines;
  }
  /**
   * @internal
   */
  _getDrawWrapper(passId, createIfNotExisting = false) {
    passId = passId ?? this._engine.currentRenderPassId;
    let drawWrapper = this._drawWrappers[passId];
    if (!drawWrapper && createIfNotExisting) {
      this._drawWrappers[passId] = drawWrapper = new DrawWrapper(this._mesh.getScene().getEngine());
    }
    return drawWrapper;
  }
  /**
   * @internal
   */
  _removeDrawWrapper(passId, disposeWrapper = true, immediate = false) {
    if (disposeWrapper) {
      this._drawWrappers[passId]?.dispose(immediate);
    }
    this._drawWrappers[passId] = void 0;
  }
  /**
   * Gets associated (main) effect (possibly the effect override if defined)
   */
  get effect() {
    return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.effect : this._getDrawWrapper()?.effect ?? null;
  }
  /** @internal */
  get _drawWrapper() {
    return this._mainDrawWrapperOverride ?? this._getDrawWrapper(void 0, true);
  }
  /** @internal */
  get _drawWrapperOverride() {
    return this._mainDrawWrapperOverride;
  }
  /**
   * @internal
   */
  _setMainDrawWrapperOverride(wrapper) {
    this._mainDrawWrapperOverride = wrapper;
  }
  /**
   * Sets associated effect (effect used to render this submesh)
   * @param effect defines the effect to associate with
   * @param defines defines the set of defines used to compile this effect
   * @param materialContext material context associated to the effect
   * @param resetContext true to reset the draw context
   */
  setEffect(effect, defines = null, materialContext, resetContext = true) {
    const drawWrapper = this._drawWrapper;
    drawWrapper.setEffect(effect, defines, resetContext);
    if (materialContext !== void 0) {
      drawWrapper.materialContext = materialContext;
    }
    if (!effect) {
      drawWrapper.defines = null;
      drawWrapper.materialContext = void 0;
    }
  }
  /**
   * Resets the draw wrappers cache
   * @param passId If provided, releases only the draw wrapper corresponding to this render pass id
   * @param immediate If true, the draw wrapper will dispose the effect immediately (false by default)
   */
  resetDrawCache(passId, immediate = false) {
    if (this._drawWrappers) {
      if (passId !== void 0) {
        this._removeDrawWrapper(passId, true, immediate);
        return;
      } else {
        for (const drawWrapper of this._drawWrappers) {
          drawWrapper?.dispose(immediate);
        }
      }
    }
    this._drawWrappers = [];
  }
  /**
   * Add a new submesh to a mesh
   * @param materialIndex defines the material index to use
   * @param verticesStart defines vertex index start
   * @param verticesCount defines vertices count
   * @param indexStart defines index start
   * @param indexCount defines indices count
   * @param mesh defines the parent mesh
   * @param renderingMesh defines an optional rendering mesh
   * @param createBoundingBox defines if bounding box should be created for this submesh
   * @returns the new submesh
   */
  static AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox = true) {
    return new _SubMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox);
  }
  /**
   * Creates a new submesh
   * @param materialIndex defines the material index to use
   * @param verticesStart defines vertex index start
   * @param verticesCount defines vertices count
   * @param indexStart defines index start
   * @param indexCount defines indices count
   * @param mesh defines the parent mesh
   * @param renderingMesh defines an optional rendering mesh
   * @param createBoundingBox defines if bounding box should be created for this submesh
   * @param addToMesh defines a boolean indicating that the submesh must be added to the mesh.subMeshes array (true by default)
   */
  constructor(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox = true, addToMesh = true) {
    this.materialIndex = materialIndex;
    this.verticesStart = verticesStart;
    this.verticesCount = verticesCount;
    this.indexStart = indexStart;
    this.indexCount = indexCount;
    this._mainDrawWrapperOverride = null;
    this._linesIndexCount = 0;
    this._linesIndexBuffer = null;
    this._lastColliderWorldVertices = null;
    this._lastColliderTransformMatrix = null;
    this._wasDispatched = false;
    this._renderId = 0;
    this._alphaIndex = 0;
    this._distanceToCamera = 0;
    this._currentMaterial = null;
    this._mesh = mesh;
    this._renderingMesh = renderingMesh || mesh;
    if (addToMesh) {
      mesh.subMeshes.push(this);
    }
    this._engine = this._mesh.getScene().getEngine();
    this.resetDrawCache();
    this._trianglePlanes = [];
    this._id = mesh.subMeshes.length - 1;
    if (createBoundingBox) {
      this.refreshBoundingInfo();
      mesh.computeWorldMatrix(true);
    }
  }
  /**
   * Returns true if this submesh covers the entire parent mesh
   * @ignorenaming
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  get IsGlobal() {
    return this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices() && this.indexStart === 0 && this.indexCount === this._mesh.getTotalIndices();
  }
  /**
   * Returns the submesh BoundingInfo object
   * @returns current bounding info (or mesh's one if the submesh is global)
   */
  getBoundingInfo() {
    if (this.IsGlobal || this._mesh.hasThinInstances) {
      return this._mesh.getBoundingInfo();
    }
    return this._boundingInfo;
  }
  /**
   * Sets the submesh BoundingInfo
   * @param boundingInfo defines the new bounding info to use
   * @returns the SubMesh
   */
  setBoundingInfo(boundingInfo) {
    this._boundingInfo = boundingInfo;
    return this;
  }
  /**
   * Returns the mesh of the current submesh
   * @returns the parent mesh
   */
  getMesh() {
    return this._mesh;
  }
  /**
   * Returns the rendering mesh of the submesh
   * @returns the rendering mesh (could be different from parent mesh)
   */
  getRenderingMesh() {
    return this._renderingMesh;
  }
  /**
   * Returns the replacement mesh of the submesh
   * @returns the replacement mesh (could be different from parent mesh)
   */
  getReplacementMesh() {
    return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;
  }
  /**
   * Returns the effective mesh of the submesh
   * @returns the effective mesh (could be different from parent mesh)
   */
  getEffectiveMesh() {
    const replacementMesh = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;
    return replacementMesh ? replacementMesh : this._renderingMesh;
  }
  /**
   * Returns the submesh material
   * @param getDefaultMaterial Defines whether or not to get the default material if nothing has been defined.
   * @returns null or the current material
   */
  getMaterial(getDefaultMaterial = true) {
    const rootMaterial = this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId) ?? this._renderingMesh.material;
    if (!rootMaterial) {
      return getDefaultMaterial && this._mesh.getScene()._hasDefaultMaterial ? this._mesh.getScene().defaultMaterial : null;
    } else if (this._isMultiMaterial(rootMaterial)) {
      const effectiveMaterial = rootMaterial.getSubMaterial(this.materialIndex);
      if (this._currentMaterial !== effectiveMaterial) {
        this._currentMaterial = effectiveMaterial;
        this.resetDrawCache();
      }
      return effectiveMaterial;
    }
    return rootMaterial;
  }
  _isMultiMaterial(material) {
    return material.getSubMaterial !== void 0;
  }
  // Methods
  /**
   * Sets a new updated BoundingInfo object to the submesh
   * @param data defines an optional position array to use to determine the bounding info
   * @returns the SubMesh
   */
  refreshBoundingInfo(data = null) {
    this._lastColliderWorldVertices = null;
    if (this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) {
      return this;
    }
    if (!data) {
      data = this._renderingMesh.getVerticesData(VertexBuffer.PositionKind);
    }
    if (!data) {
      this._boundingInfo = this._mesh.getBoundingInfo();
      return this;
    }
    const indices = this._renderingMesh.getIndices();
    let extend;
    if (this.indexStart === 0 && this.indexCount === indices.length) {
      const boundingInfo = this._renderingMesh.getBoundingInfo();
      extend = { minimum: boundingInfo.minimum.clone(), maximum: boundingInfo.maximum.clone() };
    } else {
      extend = extractMinAndMaxIndexed(data, indices, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);
    }
    if (this._boundingInfo) {
      this._boundingInfo.reConstruct(extend.minimum, extend.maximum);
    } else {
      this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);
    }
    return this;
  }
  /**
   * @internal
   */
  _checkCollision(collider) {
    const boundingInfo = this.getBoundingInfo();
    return boundingInfo._checkCollision(collider);
  }
  /**
   * Updates the submesh BoundingInfo
   * @param world defines the world matrix to use to update the bounding info
   * @returns the submesh
   */
  updateBoundingInfo(world) {
    let boundingInfo = this.getBoundingInfo();
    if (!boundingInfo) {
      this.refreshBoundingInfo();
      boundingInfo = this.getBoundingInfo();
    }
    if (boundingInfo) {
      boundingInfo.update(world);
    }
    return this;
  }
  /**
   * True is the submesh bounding box intersects the frustum defined by the passed array of planes.
   * @param frustumPlanes defines the frustum planes
   * @returns true if the submesh is intersecting with the frustum
   */
  isInFrustum(frustumPlanes) {
    const boundingInfo = this.getBoundingInfo();
    if (!boundingInfo) {
      return false;
    }
    return boundingInfo.isInFrustum(frustumPlanes, this._mesh.cullingStrategy);
  }
  /**
   * True is the submesh bounding box is completely inside the frustum defined by the passed array of planes
   * @param frustumPlanes defines the frustum planes
   * @returns true if the submesh is inside the frustum
   */
  isCompletelyInFrustum(frustumPlanes) {
    const boundingInfo = this.getBoundingInfo();
    if (!boundingInfo) {
      return false;
    }
    return boundingInfo.isCompletelyInFrustum(frustumPlanes);
  }
  /**
   * Renders the submesh
   * @param enableAlphaMode defines if alpha needs to be used
   * @returns the submesh
   */
  render(enableAlphaMode) {
    this._renderingMesh.render(this, enableAlphaMode, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : void 0);
    return this;
  }
  /**
   * @internal
   */
  _getLinesIndexBuffer(indices, engine) {
    if (!this._linesIndexBuffer) {
      const adjustedIndexCount = Math.floor(this.indexCount / 3) * 6;
      const shouldUseUint32 = this.verticesStart + this.verticesCount > 65535;
      const linesIndices = shouldUseUint32 ? new Uint32Array(adjustedIndexCount) : new Uint16Array(adjustedIndexCount);
      let offset = 0;
      if (indices.length === 0) {
        for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {
          linesIndices[offset++] = index;
          linesIndices[offset++] = index + 1;
          linesIndices[offset++] = index + 1;
          linesIndices[offset++] = index + 2;
          linesIndices[offset++] = index + 2;
          linesIndices[offset++] = index;
        }
      } else {
        for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {
          linesIndices[offset++] = indices[index];
          linesIndices[offset++] = indices[index + 1];
          linesIndices[offset++] = indices[index + 1];
          linesIndices[offset++] = indices[index + 2];
          linesIndices[offset++] = indices[index + 2];
          linesIndices[offset++] = indices[index];
        }
      }
      this._linesIndexBuffer = engine.createIndexBuffer(linesIndices);
      this._linesIndexCount = linesIndices.length;
    }
    return this._linesIndexBuffer;
  }
  /**
   * Checks if the submesh intersects with a ray
   * @param ray defines the ray to test
   * @returns true is the passed ray intersects the submesh bounding box
   */
  canIntersects(ray) {
    const boundingInfo = this.getBoundingInfo();
    if (!boundingInfo) {
      return false;
    }
    return ray.intersectsBox(boundingInfo.boundingBox);
  }
  /**
   * Intersects current submesh with a ray
   * @param ray defines the ray to test
   * @param positions defines mesh's positions array
   * @param indices defines mesh's indices array
   * @param fastCheck defines if the first intersection will be used (and not the closest)
   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
   * @returns intersection info or null if no intersection
   */
  intersects(ray, positions, indices, fastCheck, trianglePredicate) {
    const material = this.getMaterial();
    if (!material) {
      return null;
    }
    let step = 3;
    let checkStopper = false;
    switch (material.fillMode) {
      case 3:
      case 5:
      case 6:
      case 8:
        return null;
      case 7:
        step = 1;
        checkStopper = true;
        break;
      default:
        break;
    }
    if (material.fillMode === 4) {
      if (!indices.length) {
        return this._intersectUnIndexedLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);
      }
      return this._intersectLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);
    } else {
      if (!indices.length && this._mesh._unIndexed) {
        return this._intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate);
      }
      return this._intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate);
    }
  }
  /**
   * @internal
   */
  _intersectLines(ray, positions, indices, intersectionThreshold, fastCheck) {
    let intersectInfo = null;
    for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 2) {
      const p0 = positions[indices[index]];
      const p1 = positions[indices[index + 1]];
      const length = ray.intersectionSegment(p0, p1, intersectionThreshold);
      if (length < 0) {
        continue;
      }
      if (fastCheck || !intersectInfo || length < intersectInfo.distance) {
        intersectInfo = new IntersectionInfo(null, null, length);
        intersectInfo.faceId = index / 2;
        if (fastCheck) {
          break;
        }
      }
    }
    return intersectInfo;
  }
  /**
   * @internal
   */
  _intersectUnIndexedLines(ray, positions, indices, intersectionThreshold, fastCheck) {
    let intersectInfo = null;
    for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 2) {
      const p0 = positions[index];
      const p1 = positions[index + 1];
      const length = ray.intersectionSegment(p0, p1, intersectionThreshold);
      if (length < 0) {
        continue;
      }
      if (fastCheck || !intersectInfo || length < intersectInfo.distance) {
        intersectInfo = new IntersectionInfo(null, null, length);
        intersectInfo.faceId = index / 2;
        if (fastCheck) {
          break;
        }
      }
    }
    return intersectInfo;
  }
  /**
   * @internal
   */
  _intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate) {
    let intersectInfo = null;
    let faceId = -1;
    for (let index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {
      faceId++;
      const indexA = indices[index];
      const indexB = indices[index + 1];
      const indexC = indices[index + 2];
      if (checkStopper && indexC === 4294967295) {
        index += 2;
        continue;
      }
      const p0 = positions[indexA];
      const p1 = positions[indexB];
      const p2 = positions[indexC];
      if (!p0 || !p1 || !p2) {
        continue;
      }
      if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, indexA, indexB, indexC)) {
        continue;
      }
      const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);
      if (currentIntersectInfo) {
        if (currentIntersectInfo.distance < 0) {
          continue;
        }
        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {
          intersectInfo = currentIntersectInfo;
          intersectInfo.faceId = faceId;
          if (fastCheck) {
            break;
          }
        }
      }
    }
    return intersectInfo;
  }
  /**
   * @internal
   */
  _intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate) {
    let intersectInfo = null;
    for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {
      const p0 = positions[index];
      const p1 = positions[index + 1];
      const p2 = positions[index + 2];
      if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, -1, -1, -1)) {
        continue;
      }
      const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);
      if (currentIntersectInfo) {
        if (currentIntersectInfo.distance < 0) {
          continue;
        }
        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {
          intersectInfo = currentIntersectInfo;
          intersectInfo.faceId = index / 3;
          if (fastCheck) {
            break;
          }
        }
      }
    }
    return intersectInfo;
  }
  /** @internal */
  _rebuild() {
    if (this._linesIndexBuffer) {
      this._linesIndexBuffer = null;
    }
  }
  // Clone
  /**
   * Creates a new submesh from the passed mesh
   * @param newMesh defines the new hosting mesh
   * @param newRenderingMesh defines an optional rendering mesh
   * @returns the new submesh
   */
  clone(newMesh, newRenderingMesh) {
    const result = new _SubMesh(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, newMesh, newRenderingMesh, false);
    if (!this.IsGlobal) {
      const boundingInfo = this.getBoundingInfo();
      if (!boundingInfo) {
        return result;
      }
      result._boundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);
    }
    return result;
  }
  // Dispose
  /**
   * Release associated resources
   * @param immediate If true, the effect will be disposed immediately (false by default)
   */
  dispose(immediate = false) {
    if (this._linesIndexBuffer) {
      this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer);
      this._linesIndexBuffer = null;
    }
    const index = this._mesh.subMeshes.indexOf(this);
    this._mesh.subMeshes.splice(index, 1);
    this.resetDrawCache(void 0, immediate);
  }
  /**
   * Gets the class name
   * @returns the string "SubMesh".
   */
  getClassName() {
    return "SubMesh";
  }
  // Statics
  /**
   * Creates a new submesh from indices data
   * @param materialIndex the index of the main mesh material
   * @param startIndex the index where to start the copy in the mesh indices array
   * @param indexCount the number of indices to copy then from the startIndex
   * @param mesh the main mesh to create the submesh from
   * @param renderingMesh the optional rendering mesh
   * @param createBoundingBox defines if bounding box should be created for this submesh
   * @returns a new submesh
   */
  static CreateFromIndices(materialIndex, startIndex, indexCount, mesh, renderingMesh, createBoundingBox = true) {
    let minVertexIndex = Number.MAX_VALUE;
    let maxVertexIndex = -Number.MAX_VALUE;
    const whatWillRender = renderingMesh || mesh;
    const indices = whatWillRender.getIndices();
    for (let index = startIndex; index < startIndex + indexCount; index++) {
      const vertexIndex = indices[index];
      if (vertexIndex < minVertexIndex) {
        minVertexIndex = vertexIndex;
      }
      if (vertexIndex > maxVertexIndex) {
        maxVertexIndex = vertexIndex;
      }
    }
    return new _SubMesh(materialIndex, minVertexIndex, maxVertexIndex - minVertexIndex + 1, startIndex, indexCount, mesh, renderingMesh, createBoundingBox);
  }
};

// node_modules/@babylonjs/core/Meshes/mesh.vertexData.js
var VertexDataMaterialInfo = class {
};
var VertexData = class _VertexData {
  /**
   * Creates a new VertexData
   */
  constructor() {
    this.uniqueId = 0;
    this.metadata = {};
    this._applyTo = makeSyncFunction(this._applyToCoroutine.bind(this));
    this.uniqueId = _VertexData._UniqueIDGenerator;
    _VertexData._UniqueIDGenerator++;
  }
  /**
   * Uses the passed data array to set the set the values for the specified kind of data
   * @param data a linear array of floating numbers
   * @param kind the type of data that is being set, eg positions, colors etc
   */
  set(data, kind) {
    if (!data.length) {
      Logger.Warn(`Setting vertex data kind '${kind}' with an empty array`);
    }
    switch (kind) {
      case VertexBuffer.PositionKind:
        this.positions = data;
        break;
      case VertexBuffer.NormalKind:
        this.normals = data;
        break;
      case VertexBuffer.TangentKind:
        this.tangents = data;
        break;
      case VertexBuffer.UVKind:
        this.uvs = data;
        break;
      case VertexBuffer.UV2Kind:
        this.uvs2 = data;
        break;
      case VertexBuffer.UV3Kind:
        this.uvs3 = data;
        break;
      case VertexBuffer.UV4Kind:
        this.uvs4 = data;
        break;
      case VertexBuffer.UV5Kind:
        this.uvs5 = data;
        break;
      case VertexBuffer.UV6Kind:
        this.uvs6 = data;
        break;
      case VertexBuffer.ColorKind:
        this.colors = data;
        break;
      case VertexBuffer.MatricesIndicesKind:
        this.matricesIndices = data;
        break;
      case VertexBuffer.MatricesWeightsKind:
        this.matricesWeights = data;
        break;
      case VertexBuffer.MatricesIndicesExtraKind:
        this.matricesIndicesExtra = data;
        break;
      case VertexBuffer.MatricesWeightsExtraKind:
        this.matricesWeightsExtra = data;
        break;
    }
  }
  /**
   * Associates the vertexData to the passed Mesh.
   * Sets it as updatable or not (default `false`)
   * @param mesh the mesh the vertexData is applied to
   * @param updatable when used and having the value true allows new data to update the vertexData
   * @returns the VertexData
   */
  applyToMesh(mesh, updatable) {
    this._applyTo(mesh, updatable, false);
    return this;
  }
  /**
   * Associates the vertexData to the passed Geometry.
   * Sets it as updatable or not (default `false`)
   * @param geometry the geometry the vertexData is applied to
   * @param updatable when used and having the value true allows new data to update the vertexData
   * @returns VertexData
   */
  applyToGeometry(geometry, updatable) {
    this._applyTo(geometry, updatable, false);
    return this;
  }
  /**
   * Updates the associated mesh
   * @param mesh the mesh to be updated
   * @returns VertexData
   */
  updateMesh(mesh) {
    this._update(mesh);
    return this;
  }
  /**
   * Updates the associated geometry
   * @param geometry the geometry to be updated
   * @returns VertexData.
   */
  updateGeometry(geometry) {
    this._update(geometry);
    return this;
  }
  /**
   * @internal
   */
  *_applyToCoroutine(meshOrGeometry, updatable = false, isAsync) {
    if (this.positions) {
      meshOrGeometry.setVerticesData(VertexBuffer.PositionKind, this.positions, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.normals) {
      meshOrGeometry.setVerticesData(VertexBuffer.NormalKind, this.normals, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.tangents) {
      meshOrGeometry.setVerticesData(VertexBuffer.TangentKind, this.tangents, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.uvs) {
      meshOrGeometry.setVerticesData(VertexBuffer.UVKind, this.uvs, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.uvs2) {
      meshOrGeometry.setVerticesData(VertexBuffer.UV2Kind, this.uvs2, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.uvs3) {
      meshOrGeometry.setVerticesData(VertexBuffer.UV3Kind, this.uvs3, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.uvs4) {
      meshOrGeometry.setVerticesData(VertexBuffer.UV4Kind, this.uvs4, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.uvs5) {
      meshOrGeometry.setVerticesData(VertexBuffer.UV5Kind, this.uvs5, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.uvs6) {
      meshOrGeometry.setVerticesData(VertexBuffer.UV6Kind, this.uvs6, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.colors) {
      const stride = this.positions && this.colors.length === this.positions.length ? 3 : 4;
      meshOrGeometry.setVerticesData(VertexBuffer.ColorKind, this.colors, updatable, stride);
      if (this.hasVertexAlpha && meshOrGeometry.hasVertexAlpha !== void 0) {
        meshOrGeometry.hasVertexAlpha = true;
      }
      if (isAsync) {
        yield;
      }
    }
    if (this.matricesIndices) {
      meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.matricesWeights) {
      meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.matricesIndicesExtra) {
      meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.matricesWeightsExtra) {
      meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.indices) {
      meshOrGeometry.setIndices(this.indices, null, updatable);
      if (isAsync) {
        yield;
      }
    } else {
      meshOrGeometry.setIndices([], null);
    }
    if (meshOrGeometry.subMeshes && this.materialInfos && this.materialInfos.length > 1) {
      const mesh = meshOrGeometry;
      mesh.subMeshes = [];
      for (const matInfo of this.materialInfos) {
        new SubMesh(matInfo.materialIndex, matInfo.verticesStart, matInfo.verticesCount, matInfo.indexStart, matInfo.indexCount, mesh);
      }
    }
    return this;
  }
  _update(meshOrGeometry, updateExtends, makeItUnique) {
    if (this.positions) {
      meshOrGeometry.updateVerticesData(VertexBuffer.PositionKind, this.positions, updateExtends, makeItUnique);
    }
    if (this.normals) {
      meshOrGeometry.updateVerticesData(VertexBuffer.NormalKind, this.normals, updateExtends, makeItUnique);
    }
    if (this.tangents) {
      meshOrGeometry.updateVerticesData(VertexBuffer.TangentKind, this.tangents, updateExtends, makeItUnique);
    }
    if (this.uvs) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UVKind, this.uvs, updateExtends, makeItUnique);
    }
    if (this.uvs2) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV2Kind, this.uvs2, updateExtends, makeItUnique);
    }
    if (this.uvs3) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV3Kind, this.uvs3, updateExtends, makeItUnique);
    }
    if (this.uvs4) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV4Kind, this.uvs4, updateExtends, makeItUnique);
    }
    if (this.uvs5) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV5Kind, this.uvs5, updateExtends, makeItUnique);
    }
    if (this.uvs6) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV6Kind, this.uvs6, updateExtends, makeItUnique);
    }
    if (this.colors) {
      meshOrGeometry.updateVerticesData(VertexBuffer.ColorKind, this.colors, updateExtends, makeItUnique);
    }
    if (this.matricesIndices) {
      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updateExtends, makeItUnique);
    }
    if (this.matricesWeights) {
      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updateExtends, makeItUnique);
    }
    if (this.matricesIndicesExtra) {
      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updateExtends, makeItUnique);
    }
    if (this.matricesWeightsExtra) {
      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updateExtends, makeItUnique);
    }
    if (this.indices) {
      meshOrGeometry.setIndices(this.indices, null);
    }
    return this;
  }
  static _TransformVector3Coordinates(coordinates, transformation, offset = 0, length = coordinates.length) {
    const coordinate = TmpVectors.Vector3[0];
    const transformedCoordinate = TmpVectors.Vector3[1];
    for (let index = offset; index < offset + length; index += 3) {
      Vector3.FromArrayToRef(coordinates, index, coordinate);
      Vector3.TransformCoordinatesToRef(coordinate, transformation, transformedCoordinate);
      coordinates[index] = transformedCoordinate.x;
      coordinates[index + 1] = transformedCoordinate.y;
      coordinates[index + 2] = transformedCoordinate.z;
    }
  }
  static _TransformVector3Normals(normals, transformation, offset = 0, length = normals.length) {
    const normal = TmpVectors.Vector3[0];
    const transformedNormal = TmpVectors.Vector3[1];
    for (let index = offset; index < offset + length; index += 3) {
      Vector3.FromArrayToRef(normals, index, normal);
      Vector3.TransformNormalToRef(normal, transformation, transformedNormal);
      normals[index] = transformedNormal.x;
      normals[index + 1] = transformedNormal.y;
      normals[index + 2] = transformedNormal.z;
    }
  }
  static _TransformVector4Normals(normals, transformation, offset = 0, length = normals.length) {
    const normal = TmpVectors.Vector4[0];
    const transformedNormal = TmpVectors.Vector4[1];
    for (let index = offset; index < offset + length; index += 4) {
      Vector4.FromArrayToRef(normals, index, normal);
      Vector4.TransformNormalToRef(normal, transformation, transformedNormal);
      normals[index] = transformedNormal.x;
      normals[index + 1] = transformedNormal.y;
      normals[index + 2] = transformedNormal.z;
      normals[index + 3] = transformedNormal.w;
    }
  }
  static _FlipFaces(indices, offset = 0, length = indices.length) {
    for (let index = offset; index < offset + length; index += 3) {
      const tmp = indices[index + 1];
      indices[index + 1] = indices[index + 2];
      indices[index + 2] = tmp;
    }
  }
  /**
   * Transforms each position and each normal of the vertexData according to the passed Matrix
   * @param matrix the transforming matrix
   * @returns the VertexData
   */
  transform(matrix) {
    const flip = matrix.determinant() < 0;
    if (this.positions) {
      _VertexData._TransformVector3Coordinates(this.positions, matrix);
    }
    if (this.normals) {
      _VertexData._TransformVector3Normals(this.normals, matrix);
    }
    if (this.tangents) {
      _VertexData._TransformVector4Normals(this.tangents, matrix);
    }
    if (flip && this.indices) {
      _VertexData._FlipFaces(this.indices);
    }
    return this;
  }
  /**
   * Generates an array of vertex data where each vertex data only has one material info
   * @returns An array of VertexData
   */
  splitBasedOnMaterialID() {
    if (!this.materialInfos || this.materialInfos.length < 2) {
      return [this];
    }
    const result = [];
    for (const materialInfo of this.materialInfos) {
      const vertexData = new _VertexData();
      if (this.positions) {
        vertexData.positions = this.positions.slice(materialInfo.verticesStart * 3, (materialInfo.verticesCount + materialInfo.verticesStart) * 3);
      }
      if (this.normals) {
        vertexData.normals = this.normals.slice(materialInfo.verticesStart * 3, (materialInfo.verticesCount + materialInfo.verticesStart) * 3);
      }
      if (this.tangents) {
        vertexData.tangents = this.tangents.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);
      }
      if (this.colors) {
        vertexData.colors = this.colors.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);
      }
      if (this.uvs) {
        vertexData.uvs = this.uvs.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);
      }
      if (this.uvs2) {
        vertexData.uvs2 = this.uvs2.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);
      }
      if (this.uvs3) {
        vertexData.uvs3 = this.uvs3.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);
      }
      if (this.uvs4) {
        vertexData.uvs4 = this.uvs4.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);
      }
      if (this.uvs5) {
        vertexData.uvs5 = this.uvs5.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);
      }
      if (this.uvs6) {
        vertexData.uvs6 = this.uvs6.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);
      }
      if (this.matricesIndices) {
        vertexData.matricesIndices = this.matricesIndices.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);
      }
      if (this.matricesIndicesExtra) {
        vertexData.matricesIndicesExtra = this.matricesIndicesExtra.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);
      }
      if (this.matricesWeights) {
        vertexData.matricesWeights = this.matricesWeights.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);
      }
      if (this.matricesWeightsExtra) {
        vertexData.matricesWeightsExtra = this.matricesWeightsExtra.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);
      }
      if (this.indices) {
        vertexData.indices = [];
        for (let index = materialInfo.indexStart; index < materialInfo.indexStart + materialInfo.indexCount; index++) {
          vertexData.indices.push(this.indices[index] - materialInfo.verticesStart);
        }
      }
      const newMaterialInfo = new VertexDataMaterialInfo();
      newMaterialInfo.indexStart = 0;
      newMaterialInfo.indexCount = vertexData.indices ? vertexData.indices.length : 0;
      newMaterialInfo.materialIndex = materialInfo.materialIndex;
      newMaterialInfo.verticesStart = 0;
      newMaterialInfo.verticesCount = (vertexData.positions ? vertexData.positions.length : 0) / 3;
      vertexData.materialInfos = [newMaterialInfo];
      result.push(vertexData);
    }
    return result;
  }
  /**
   * Merges the passed VertexData into the current one
   * @param others the VertexData to be merged into the current one
   * @param use32BitsIndices defines a boolean indicating if indices must be store in a 32 bits array
   * @param forceCloneIndices defines a boolean indicating if indices are forced to be cloned
   * @param mergeMaterialIds defines a boolean indicating if we need to merge the material infos
   * @param enableCompletion defines a boolean indicating if the vertex data should be completed to be compatible
   * @returns the modified VertexData
   */
  merge(others, use32BitsIndices = false, forceCloneIndices = false, mergeMaterialIds = false, enableCompletion = false) {
    const vertexDatas = Array.isArray(others) ? others.map((other) => {
      return { vertexData: other };
    }) : [{ vertexData: others }];
    return runCoroutineSync(this._mergeCoroutine(void 0, vertexDatas, use32BitsIndices, false, forceCloneIndices, mergeMaterialIds, enableCompletion));
  }
  /**
   * @internal
   */
  *_mergeCoroutine(transform, vertexDatas, use32BitsIndices = false, isAsync, forceCloneIndices, mergeMaterialIds = false, enableCompletion = false) {
    this._validate();
    let others = vertexDatas.map((vertexData) => vertexData.vertexData);
    let root = this;
    if (enableCompletion) {
      for (const other of others) {
        if (!other) {
          continue;
        }
        other._validate();
        if (!this.normals && other.normals) {
          this.normals = new Float32Array(this.positions.length);
        }
        if (!this.tangents && other.tangents) {
          this.tangents = new Float32Array(this.positions.length / 3 * 4);
        }
        if (!this.uvs && other.uvs) {
          this.uvs = new Float32Array(this.positions.length / 3 * 2);
        }
        if (!this.uvs2 && other.uvs2) {
          this.uvs2 = new Float32Array(this.positions.length / 3 * 2);
        }
        if (!this.uvs3 && other.uvs3) {
          this.uvs3 = new Float32Array(this.positions.length / 3 * 2);
        }
        if (!this.uvs4 && other.uvs4) {
          this.uvs4 = new Float32Array(this.positions.length / 3 * 2);
        }
        if (!this.uvs5 && other.uvs5) {
          this.uvs5 = new Float32Array(this.positions.length / 3 * 2);
        }
        if (!this.uvs6 && other.uvs6) {
          this.uvs6 = new Float32Array(this.positions.length / 3 * 2);
        }
        if (!this.colors && other.colors) {
          this.colors = new Float32Array(this.positions.length / 3 * 4);
          this.colors.fill(1);
        }
        if (!this.matricesIndices && other.matricesIndices) {
          this.matricesIndices = new Float32Array(this.positions.length / 3 * 4);
        }
        if (!this.matricesWeights && other.matricesWeights) {
          this.matricesWeights = new Float32Array(this.positions.length / 3 * 4);
        }
        if (!this.matricesIndicesExtra && other.matricesIndicesExtra) {
          this.matricesIndicesExtra = new Float32Array(this.positions.length / 3 * 4);
        }
        if (!this.matricesWeightsExtra && other.matricesWeightsExtra) {
          this.matricesWeightsExtra = new Float32Array(this.positions.length / 3 * 4);
        }
      }
    }
    for (const other of others) {
      if (!other) {
        continue;
      }
      if (!enableCompletion) {
        other._validate();
        if (!this.normals !== !other.normals || !this.tangents !== !other.tangents || !this.uvs !== !other.uvs || !this.uvs2 !== !other.uvs2 || !this.uvs3 !== !other.uvs3 || !this.uvs4 !== !other.uvs4 || !this.uvs5 !== !other.uvs5 || !this.uvs6 !== !other.uvs6 || !this.colors !== !other.colors || !this.matricesIndices !== !other.matricesIndices || !this.matricesWeights !== !other.matricesWeights || !this.matricesIndicesExtra !== !other.matricesIndicesExtra || !this.matricesWeightsExtra !== !other.matricesWeightsExtra) {
          throw new Error("Cannot merge vertex data that do not have the same set of attributes");
        }
      } else {
        if (this.normals && !other.normals) {
          other.normals = new Float32Array(other.positions.length);
        }
        if (this.tangents && !other.tangents) {
          other.tangents = new Float32Array(other.positions.length / 3 * 4);
        }
        if (this.uvs && !other.uvs) {
          other.uvs = new Float32Array(other.positions.length / 3 * 2);
        }
        if (this.uvs2 && !other.uvs2) {
          other.uvs2 = new Float32Array(other.positions.length / 3 * 2);
        }
        if (this.uvs3 && !other.uvs3) {
          other.uvs3 = new Float32Array(other.positions.length / 3 * 2);
        }
        if (this.uvs4 && !other.uvs4) {
          other.uvs4 = new Float32Array(other.positions.length / 3 * 2);
        }
        if (this.uvs5 && !other.uvs5) {
          other.uvs5 = new Float32Array(other.positions.length / 3 * 2);
        }
        if (this.uvs6 && !other.uvs6) {
          other.uvs6 = new Float32Array(other.positions.length / 3 * 2);
        }
        if (this.colors && !other.colors) {
          other.colors = new Float32Array(other.positions.length / 3 * 4);
          other.colors.fill(1);
        }
        if (this.matricesIndices && !other.matricesIndices) {
          other.matricesIndices = new Float32Array(other.positions.length / 3 * 4);
        }
        if (this.matricesWeights && !other.matricesWeights) {
          other.matricesWeights = new Float32Array(other.positions.length / 3 * 4);
        }
        if (this.matricesIndicesExtra && !other.matricesIndicesExtra) {
          other.matricesIndicesExtra = new Float32Array(other.positions.length / 3 * 4);
        }
        if (this.matricesWeightsExtra && !other.matricesWeightsExtra) {
          other.matricesWeightsExtra = new Float32Array(other.positions.length / 3 * 4);
        }
      }
    }
    if (mergeMaterialIds) {
      let materialIndex = 0;
      let indexOffset = 0;
      let vertexOffset = 0;
      const materialInfos = [];
      let currentMaterialInfo = null;
      const vertexDataList = [];
      for (const split of this.splitBasedOnMaterialID()) {
        vertexDataList.push({ vertexData: split, transform });
      }
      for (const data of vertexDatas) {
        if (!data.vertexData) {
          continue;
        }
        for (const split of data.vertexData.splitBasedOnMaterialID()) {
          vertexDataList.push({ vertexData: split, transform: data.transform });
        }
      }
      vertexDataList.sort((a, b) => {
        const matInfoA = a.vertexData.materialInfos ? a.vertexData.materialInfos[0].materialIndex : 0;
        const matInfoB = b.vertexData.materialInfos ? b.vertexData.materialInfos[0].materialIndex : 0;
        if (matInfoA > matInfoB) {
          return 1;
        }
        if (matInfoA === matInfoB) {
          return 0;
        }
        return -1;
      });
      for (const vertexDataSource of vertexDataList) {
        const vertexData = vertexDataSource.vertexData;
        if (vertexData.materialInfos) {
          materialIndex = vertexData.materialInfos[0].materialIndex;
        } else {
          materialIndex = 0;
        }
        if (currentMaterialInfo && currentMaterialInfo.materialIndex === materialIndex) {
          currentMaterialInfo.indexCount += vertexData.indices.length;
          currentMaterialInfo.verticesCount += vertexData.positions.length / 3;
        } else {
          const materialInfo = new VertexDataMaterialInfo();
          materialInfo.materialIndex = materialIndex;
          materialInfo.indexStart = indexOffset;
          materialInfo.indexCount = vertexData.indices.length;
          materialInfo.verticesStart = vertexOffset;
          materialInfo.verticesCount = vertexData.positions.length / 3;
          materialInfos.push(materialInfo);
          currentMaterialInfo = materialInfo;
        }
        indexOffset += vertexData.indices.length;
        vertexOffset += vertexData.positions.length / 3;
      }
      const first = vertexDataList.splice(0, 1)[0];
      root = first.vertexData;
      transform = first.transform;
      others = vertexDataList.map((v) => v.vertexData);
      vertexDatas = vertexDataList;
      this.materialInfos = materialInfos;
    }
    const totalIndices = others.reduce((indexSum, vertexData) => indexSum + (vertexData.indices?.length ?? 0), root.indices?.length ?? 0);
    const sliceIndices = forceCloneIndices || others.some((vertexData) => vertexData.indices === root.indices);
    let indices = sliceIndices ? root.indices?.slice() : root.indices;
    if (totalIndices > 0) {
      let indicesOffset = indices?.length ?? 0;
      if (!indices) {
        indices = new Array(totalIndices);
      }
      if (indices.length !== totalIndices) {
        if (Array.isArray(indices)) {
          indices.length = totalIndices;
        } else {
          const temp = use32BitsIndices || indices instanceof Uint32Array ? new Uint32Array(totalIndices) : new Uint16Array(totalIndices);
          temp.set(indices);
          indices = temp;
        }
        if (transform && transform.determinant() < 0) {
          _VertexData._FlipFaces(indices, 0, indicesOffset);
        }
      }
      let positionsOffset = root.positions ? root.positions.length / 3 : 0;
      for (const { vertexData: other, transform: transform2 } of vertexDatas) {
        if (other.indices) {
          for (let index = 0; index < other.indices.length; index++) {
            indices[indicesOffset + index] = other.indices[index] + positionsOffset;
          }
          if (transform2 && transform2.determinant() < 0) {
            _VertexData._FlipFaces(indices, indicesOffset, other.indices.length);
          }
          positionsOffset += other.positions.length / 3;
          indicesOffset += other.indices.length;
          if (isAsync) {
            yield;
          }
        }
      }
    }
    this.indices = indices;
    this.positions = _VertexData._MergeElement(VertexBuffer.PositionKind, root.positions, transform, vertexDatas.map((other) => [other.vertexData.positions, other.transform]));
    if (isAsync) {
      yield;
    }
    if (root.normals) {
      this.normals = _VertexData._MergeElement(VertexBuffer.NormalKind, root.normals, transform, vertexDatas.map((other) => [other.vertexData.normals, other.transform]));
      if (isAsync) {
        yield;
      }
    }
    if (root.tangents) {
      this.tangents = _VertexData._MergeElement(VertexBuffer.TangentKind, root.tangents, transform, vertexDatas.map((other) => [other.vertexData.tangents, other.transform]));
      if (isAsync) {
        yield;
      }
    }
    if (root.uvs) {
      this.uvs = _VertexData._MergeElement(VertexBuffer.UVKind, root.uvs, transform, vertexDatas.map((other) => [other.vertexData.uvs, other.transform]));
      if (isAsync) {
        yield;
      }
    }
    if (root.uvs2) {
      this.uvs2 = _VertexData._MergeElement(VertexBuffer.UV2Kind, root.uvs2, transform, vertexDatas.map((other) => [other.vertexData.uvs2, other.transform]));
      if (isAsync) {
        yield;
      }
    }
    if (root.uvs3) {
      this.uvs3 = _VertexData._MergeElement(VertexBuffer.UV3Kind, root.uvs3, transform, vertexDatas.map((other) => [other.vertexData.uvs3, other.transform]));
      if (isAsync) {
        yield;
      }
    }
    if (root.uvs4) {
      this.uvs4 = _VertexData._MergeElement(VertexBuffer.UV4Kind, root.uvs4, transform, vertexDatas.map((other) => [other.vertexData.uvs4, other.transform]));
      if (isAsync) {
        yield;
      }
    }
    if (root.uvs5) {
      this.uvs5 = _VertexData._MergeElement(VertexBuffer.UV5Kind, root.uvs5, transform, vertexDatas.map((other) => [other.vertexData.uvs5, other.transform]));
      if (isAsync) {
        yield;
      }
    }
    if (root.uvs6) {
      this.uvs6 = _VertexData._MergeElement(VertexBuffer.UV6Kind, root.uvs6, transform, vertexDatas.map((other) => [other.vertexData.uvs6, other.transform]));
      if (isAsync) {
        yield;
      }
    }
    if (root.colors) {
      this.colors = _VertexData._MergeElement(VertexBuffer.ColorKind, root.colors, transform, vertexDatas.map((other) => [other.vertexData.colors, other.transform]));
      if (root.hasVertexAlpha !== void 0 || vertexDatas.some((other) => other.vertexData.hasVertexAlpha !== void 0)) {
        this.hasVertexAlpha = root.hasVertexAlpha || vertexDatas.some((other) => other.vertexData.hasVertexAlpha);
      }
      if (isAsync) {
        yield;
      }
    }
    if (root.matricesIndices) {
      this.matricesIndices = _VertexData._MergeElement(VertexBuffer.MatricesIndicesKind, root.matricesIndices, transform, vertexDatas.map((other) => [other.vertexData.matricesIndices, other.transform]));
      if (isAsync) {
        yield;
      }
    }
    if (root.matricesWeights) {
      this.matricesWeights = _VertexData._MergeElement(VertexBuffer.MatricesWeightsKind, root.matricesWeights, transform, vertexDatas.map((other) => [other.vertexData.matricesWeights, other.transform]));
      if (isAsync) {
        yield;
      }
    }
    if (root.matricesIndicesExtra) {
      this.matricesIndicesExtra = _VertexData._MergeElement(VertexBuffer.MatricesIndicesExtraKind, root.matricesIndicesExtra, transform, vertexDatas.map((other) => [other.vertexData.matricesIndicesExtra, other.transform]));
      if (isAsync) {
        yield;
      }
    }
    if (root.matricesWeightsExtra) {
      this.matricesWeightsExtra = _VertexData._MergeElement(VertexBuffer.MatricesWeightsExtraKind, root.matricesWeightsExtra, transform, vertexDatas.map((other) => [other.vertexData.matricesWeightsExtra, other.transform]));
    }
    return this;
  }
  static _MergeElement(kind, source, transform, others) {
    const nonNullOthers = others.filter((other) => other[0] !== null && other[0] !== void 0);
    if (!source && nonNullOthers.length == 0) {
      return source;
    }
    if (!source) {
      return this._MergeElement(kind, nonNullOthers[0][0], nonNullOthers[0][1], nonNullOthers.slice(1));
    }
    const len = nonNullOthers.reduce((sumLen, elements) => sumLen + elements[0].length, source.length);
    const transformRange = kind === VertexBuffer.PositionKind ? _VertexData._TransformVector3Coordinates : kind === VertexBuffer.NormalKind ? _VertexData._TransformVector3Normals : kind === VertexBuffer.TangentKind ? _VertexData._TransformVector4Normals : () => {
    };
    if (source instanceof Float32Array) {
      const ret32 = new Float32Array(len);
      ret32.set(source);
      transform && transformRange(ret32, transform, 0, source.length);
      let offset = source.length;
      for (const [vertexData, transform2] of nonNullOthers) {
        ret32.set(vertexData, offset);
        transform2 && transformRange(ret32, transform2, offset, vertexData.length);
        offset += vertexData.length;
      }
      return ret32;
    } else {
      const ret = new Array(len);
      for (let i = 0; i < source.length; i++) {
        ret[i] = source[i];
      }
      transform && transformRange(ret, transform, 0, source.length);
      let offset = source.length;
      for (const [vertexData, transform2] of nonNullOthers) {
        for (let i = 0; i < vertexData.length; i++) {
          ret[offset + i] = vertexData[i];
        }
        transform2 && transformRange(ret, transform2, offset, vertexData.length);
        offset += vertexData.length;
      }
      return ret;
    }
  }
  _validate() {
    if (!this.positions) {
      throw new RuntimeError("Positions are required", ErrorCodes.MeshInvalidPositionsError);
    }
    const getElementCount = (kind, values) => {
      const stride = VertexBuffer.DeduceStride(kind);
      if (values.length % stride !== 0) {
        throw new Error("The " + kind + "s array count must be a multiple of " + stride);
      }
      return values.length / stride;
    };
    const positionsElementCount = getElementCount(VertexBuffer.PositionKind, this.positions);
    const validateElementCount = (kind, values) => {
      const elementCount = getElementCount(kind, values);
      if (elementCount !== positionsElementCount) {
        throw new Error("The " + kind + "s element count (" + elementCount + ") does not match the positions count (" + positionsElementCount + ")");
      }
    };
    if (this.normals) {
      validateElementCount(VertexBuffer.NormalKind, this.normals);
    }
    if (this.tangents) {
      validateElementCount(VertexBuffer.TangentKind, this.tangents);
    }
    if (this.uvs) {
      validateElementCount(VertexBuffer.UVKind, this.uvs);
    }
    if (this.uvs2) {
      validateElementCount(VertexBuffer.UV2Kind, this.uvs2);
    }
    if (this.uvs3) {
      validateElementCount(VertexBuffer.UV3Kind, this.uvs3);
    }
    if (this.uvs4) {
      validateElementCount(VertexBuffer.UV4Kind, this.uvs4);
    }
    if (this.uvs5) {
      validateElementCount(VertexBuffer.UV5Kind, this.uvs5);
    }
    if (this.uvs6) {
      validateElementCount(VertexBuffer.UV6Kind, this.uvs6);
    }
    if (this.colors) {
      validateElementCount(VertexBuffer.ColorKind, this.colors);
    }
    if (this.matricesIndices) {
      validateElementCount(VertexBuffer.MatricesIndicesKind, this.matricesIndices);
    }
    if (this.matricesWeights) {
      validateElementCount(VertexBuffer.MatricesWeightsKind, this.matricesWeights);
    }
    if (this.matricesIndicesExtra) {
      validateElementCount(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra);
    }
    if (this.matricesWeightsExtra) {
      validateElementCount(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra);
    }
  }
  /**
   * Clone the current vertex data
   * @returns a copy of the current data
   */
  clone() {
    const serializationObject = this.serialize();
    return _VertexData.Parse(serializationObject);
  }
  /**
   * Serializes the VertexData
   * @returns a serialized object
   */
  serialize() {
    const serializationObject = {};
    if (this.positions) {
      serializationObject.positions = Array.from(this.positions);
    }
    if (this.normals) {
      serializationObject.normals = Array.from(this.normals);
    }
    if (this.tangents) {
      serializationObject.tangents = Array.from(this.tangents);
    }
    if (this.uvs) {
      serializationObject.uvs = Array.from(this.uvs);
    }
    if (this.uvs2) {
      serializationObject.uvs2 = Array.from(this.uvs2);
    }
    if (this.uvs3) {
      serializationObject.uvs3 = Array.from(this.uvs3);
    }
    if (this.uvs4) {
      serializationObject.uvs4 = Array.from(this.uvs4);
    }
    if (this.uvs5) {
      serializationObject.uvs5 = Array.from(this.uvs5);
    }
    if (this.uvs6) {
      serializationObject.uvs6 = Array.from(this.uvs6);
    }
    if (this.colors) {
      serializationObject.colors = Array.from(this.colors);
      serializationObject.hasVertexAlpha = this.hasVertexAlpha;
    }
    if (this.matricesIndices) {
      serializationObject.matricesIndices = Array.from(this.matricesIndices);
      serializationObject.matricesIndices._isExpanded = true;
    }
    if (this.matricesWeights) {
      serializationObject.matricesWeights = Array.from(this.matricesWeights);
    }
    if (this.matricesIndicesExtra) {
      serializationObject.matricesIndicesExtra = Array.from(this.matricesIndicesExtra);
      serializationObject.matricesIndicesExtra._isExpanded = true;
    }
    if (this.matricesWeightsExtra) {
      serializationObject.matricesWeightsExtra = Array.from(this.matricesWeightsExtra);
    }
    serializationObject.indices = this.indices ? Array.from(this.indices) : [];
    if (this.materialInfos) {
      serializationObject.materialInfos = [];
      for (const materialInfo of this.materialInfos) {
        const materialInfoSerializationObject = {
          indexStart: materialInfo.indexStart,
          indexCount: materialInfo.indexCount,
          materialIndex: materialInfo.materialIndex,
          verticesStart: materialInfo.verticesStart,
          verticesCount: materialInfo.verticesCount
        };
        serializationObject.materialInfos.push(materialInfoSerializationObject);
      }
    }
    return serializationObject;
  }
  // Statics
  /**
   * Extracts the vertexData from a mesh
   * @param mesh the mesh from which to extract the VertexData
   * @param copyWhenShared defines if the VertexData must be cloned when shared between multiple meshes, optional, default false
   * @param forceCopy indicating that the VertexData must be cloned, optional, default false
   * @returns the object VertexData associated to the passed mesh
   */
  static ExtractFromMesh(mesh, copyWhenShared, forceCopy) {
    return _VertexData._ExtractFrom(mesh, copyWhenShared, forceCopy);
  }
  /**
   * Extracts the vertexData from the geometry
   * @param geometry the geometry from which to extract the VertexData
   * @param copyWhenShared defines if the VertexData must be cloned when the geometry is shared between multiple meshes, optional, default false
   * @param forceCopy indicating that the VertexData must be cloned, optional, default false
   * @returns the object VertexData associated to the passed mesh
   */
  static ExtractFromGeometry(geometry, copyWhenShared, forceCopy) {
    return _VertexData._ExtractFrom(geometry, copyWhenShared, forceCopy);
  }
  static _ExtractFrom(meshOrGeometry, copyWhenShared, forceCopy) {
    const result = new _VertexData();
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.PositionKind)) {
      result.positions = meshOrGeometry.getVerticesData(VertexBuffer.PositionKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      result.normals = meshOrGeometry.getVerticesData(VertexBuffer.NormalKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.TangentKind)) {
      result.tangents = meshOrGeometry.getVerticesData(VertexBuffer.TangentKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UVKind)) {
      result.uvs = meshOrGeometry.getVerticesData(VertexBuffer.UVKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
      result.uvs2 = meshOrGeometry.getVerticesData(VertexBuffer.UV2Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV3Kind)) {
      result.uvs3 = meshOrGeometry.getVerticesData(VertexBuffer.UV3Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV4Kind)) {
      result.uvs4 = meshOrGeometry.getVerticesData(VertexBuffer.UV4Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV5Kind)) {
      result.uvs5 = meshOrGeometry.getVerticesData(VertexBuffer.UV5Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV6Kind)) {
      result.uvs6 = meshOrGeometry.getVerticesData(VertexBuffer.UV6Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.ColorKind)) {
      const geometry = meshOrGeometry.geometry || meshOrGeometry;
      const vertexBuffer = geometry.getVertexBuffer(VertexBuffer.ColorKind);
      const colors = geometry.getVerticesData(VertexBuffer.ColorKind, copyWhenShared, forceCopy);
      if (vertexBuffer.getSize() === 3) {
        const newColors = new Float32Array(colors.length * 4 / 3);
        for (let i = 0, j = 0; i < colors.length; i += 3, j += 4) {
          newColors[j] = colors[i];
          newColors[j + 1] = colors[i + 1];
          newColors[j + 2] = colors[i + 2];
          newColors[j + 3] = 1;
        }
        result.colors = newColors;
      } else if (vertexBuffer.getSize() === 4) {
        result.colors = colors;
      } else {
        throw new Error(`Unexpected number of color components: ${vertexBuffer.getSize()}`);
      }
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {
      result.matricesIndices = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
      result.matricesWeights = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesExtraKind)) {
      result.matricesIndicesExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesExtraKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {
      result.matricesWeightsExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsExtraKind, copyWhenShared, forceCopy);
    }
    result.indices = meshOrGeometry.getIndices(copyWhenShared, forceCopy);
    return result;
  }
  /**
   * Creates the VertexData for a Ribbon
   * @param options an object used to set the following optional parameters for the ribbon, required but can be empty
   * * pathArray array of paths, each of which an array of successive Vector3
   * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false
   * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false
   * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length
   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
   * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false
   * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional
   * * colors a linear array, of length 4 * number of vertices, of custom color values, optional
   * @returns the VertexData of the ribbon
   * @deprecated use CreateRibbonVertexData instead
   */
  static CreateRibbon(options) {
    throw _WarnImport("ribbonBuilder");
  }
  /**
   * Creates the VertexData for a box
   * @param options an object used to set the following optional parameters for the box, required but can be empty
   * * size sets the width, height and depth of the box to the value of size, optional default 1
   * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size
   * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size
   * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size
   * * faceUV an array of 6 Vector4 elements used to set different images to each box side
   * * faceColors an array of 6 Color3 elements used to set different colors to each box side
   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
   * @returns the VertexData of the box
   * @deprecated Please use CreateBoxVertexData from the BoxBuilder file instead
   */
  static CreateBox(options) {
    throw _WarnImport("boxBuilder");
  }
  /**
   * Creates the VertexData for a tiled box
   * @param options an object used to set the following optional parameters for the box, required but can be empty
   * * faceTiles sets the pattern, tile size and number of tiles for a face
   * * faceUV an array of 6 Vector4 elements used to set different images to each box side
   * * faceColors an array of 6 Color3 elements used to set different colors to each box side
   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
   * @param options.pattern
   * @param options.width
   * @param options.height
   * @param options.depth
   * @param options.tileSize
   * @param options.tileWidth
   * @param options.tileHeight
   * @param options.alignHorizontal
   * @param options.alignVertical
   * @param options.faceUV
   * @param options.faceColors
   * @param options.sideOrientation
   * @returns the VertexData of the box
   * @deprecated Please use CreateTiledBoxVertexData instead
   */
  static CreateTiledBox(options) {
    throw _WarnImport("tiledBoxBuilder");
  }
  /**
   * Creates the VertexData for a tiled plane
   * @param options an object used to set the following optional parameters for the box, required but can be empty
   * * pattern a limited pattern arrangement depending on the number
   * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1
   * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size
   * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size
   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
   * @returns the VertexData of the tiled plane
   * @deprecated use CreateTiledPlaneVertexData instead
   */
  static CreateTiledPlane(options) {
    throw _WarnImport("tiledPlaneBuilder");
  }
  /**
   * Creates the VertexData for an ellipsoid, defaults to a sphere
   * @param options an object used to set the following optional parameters for the box, required but can be empty
   * * segments sets the number of horizontal strips optional, default 32
   * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1
   * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter
   * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter
   * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter
   * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1
   * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1
   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
   * @returns the VertexData of the ellipsoid
   * @deprecated use CreateSphereVertexData instead
   */
  static CreateSphere(options) {
    throw _WarnImport("sphereBuilder");
  }
  /**
   * Creates the VertexData for a cylinder, cone or prism
   * @param options an object used to set the following optional parameters for the box, required but can be empty
   * * height sets the height (y direction) of the cylinder, optional, default 2
   * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter
   * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter
   * * diameter sets the diameter of the top and bottom of the cone, optional default 1
   * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24
   * * subdivisions` the number of rings along the cylinder height, optional, default 1
   * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1
   * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively
   * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively
   * * hasRings when true makes each subdivision independently treated as a face for faceUV and faceColors, optional, default false
   * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake
   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
   * @returns the VertexData of the cylinder, cone or prism
   * @deprecated please use CreateCylinderVertexData instead
   */
  static CreateCylinder(options) {
    throw _WarnImport("cylinderBuilder");
  }
  /**
   * Creates the VertexData for a torus
   * @param options an object used to set the following optional parameters for the box, required but can be empty
   * * diameter the diameter of the torus, optional default 1
   * * thickness the diameter of the tube forming the torus, optional default 0.5
   * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24
   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
   * @returns the VertexData of the torus
   * @deprecated use CreateTorusVertexData instead
   */
  static CreateTorus(options) {
    throw _WarnImport("torusBuilder");
  }
  /**
   * Creates the VertexData of the LineSystem
   * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty
   *  - lines an array of lines, each line being an array of successive Vector3
   *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point
   * @returns the VertexData of the LineSystem
   * @deprecated use CreateLineSystemVertexData instead
   */
  static CreateLineSystem(options) {
    throw _WarnImport("linesBuilder");
  }
  /**
   * Create the VertexData for a DashedLines
   * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty
   *  - points an array successive Vector3
   *  - dashSize the size of the dashes relative to the dash number, optional, default 3
   *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1
   *  - dashNb the intended total number of dashes, optional, default 200
   * @returns the VertexData for the DashedLines
   * @deprecated use CreateDashedLinesVertexData instead
   */
  static CreateDashedLines(options) {
    throw _WarnImport("linesBuilder");
  }
  /**
   * Creates the VertexData for a Ground
   * @param options an object used to set the following optional parameters for the Ground, required but can be empty
   *  - width the width (x direction) of the ground, optional, default 1
   *  - height the height (z direction) of the ground, optional, default 1
   *  - subdivisions the number of subdivisions per side, optional, default 1
   * @returns the VertexData of the Ground
   * @deprecated Please use CreateGroundVertexData instead
   */
  static CreateGround(options) {
    throw _WarnImport("groundBuilder");
  }
  /**
   * Creates the VertexData for a TiledGround by subdividing the ground into tiles
   * @param options an object used to set the following optional parameters for the Ground, required but can be empty
   * * xmin the ground minimum X coordinate, optional, default -1
   * * zmin the ground minimum Z coordinate, optional, default -1
   * * xmax the ground maximum X coordinate, optional, default 1
   * * zmax the ground maximum Z coordinate, optional, default 1
   * * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}
   * * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}
   * @returns the VertexData of the TiledGround
   * @deprecated use CreateTiledGroundVertexData instead
   */
  static CreateTiledGround(options) {
    throw _WarnImport("groundBuilder");
  }
  /**
   * Creates the VertexData of the Ground designed from a heightmap
   * @param options an object used to set the following parameters for the Ground, required and provided by CreateGroundFromHeightMap
   * * width the width (x direction) of the ground
   * * height the height (z direction) of the ground
   * * subdivisions the number of subdivisions per side
   * * minHeight the minimum altitude on the ground, optional, default 0
   * * maxHeight the maximum altitude on the ground, optional default 1
   * * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)
   * * buffer the array holding the image color data
   * * bufferWidth the width of image
   * * bufferHeight the height of image
   * * alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)
   * @returns the VertexData of the Ground designed from a heightmap
   * @deprecated use CreateGroundFromHeightMapVertexData instead
   */
  static CreateGroundFromHeightMap(options) {
    throw _WarnImport("groundBuilder");
  }
  /**
   * Creates the VertexData for a Plane
   * @param options an object used to set the following optional parameters for the plane, required but can be empty
   * * size sets the width and height of the plane to the value of size, optional default 1
   * * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size
   * * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size
   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
   * @returns the VertexData of the box
   * @deprecated use CreatePlaneVertexData instead
   */
  static CreatePlane(options) {
    throw _WarnImport("planeBuilder");
  }
  /**
   * Creates the VertexData of the Disc or regular Polygon
   * @param options an object used to set the following optional parameters for the disc, required but can be empty
   * * radius the radius of the disc, optional default 0.5
   * * tessellation the number of polygon sides, optional, default 64
   * * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1
   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
   * @returns the VertexData of the box
   * @deprecated use CreateDiscVertexData instead
   */
  static CreateDisc(options) {
    throw _WarnImport("discBuilder");
  }
  /**
   * Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()
   * All parameters are provided by CreatePolygon as needed
   * @param polygon a mesh built from polygonTriangulation.build()
   * @param sideOrientation takes the values Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
   * @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively
   * @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively
   * @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
   * @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
   * @param wrap a boolean, default false, when true and fUVs used texture is wrapped around all sides, when false texture is applied side
   * @returns the VertexData of the Polygon
   * @deprecated use CreatePolygonVertexData instead
   */
  static CreatePolygon(polygon, sideOrientation, fUV, fColors, frontUVs, backUVs, wrap) {
    throw _WarnImport("polygonBuilder");
  }
  /**
   * Creates the VertexData of the IcoSphere
   * @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty
   * * radius the radius of the IcoSphere, optional default 1
   * * radiusX allows stretching in the x direction, optional, default radius
   * * radiusY allows stretching in the y direction, optional, default radius
   * * radiusZ allows stretching in the z direction, optional, default radius
   * * flat when true creates a flat shaded mesh, optional, default true
   * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4
   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
   * @returns the VertexData of the IcoSphere
   * @deprecated use CreateIcoSphereVertexData instead
   */
  static CreateIcoSphere(options) {
    throw _WarnImport("icoSphereBuilder");
  }
  // inspired from // http://stemkoski.github.io/Three.js/Polyhedra.html
  /**
   * Creates the VertexData for a Polyhedron
   * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty
   * * type provided types are:
   *  * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)
   *  * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)
   * * size the size of the IcoSphere, optional default 1
   * * sizeX allows stretching in the x direction, optional, default size
   * * sizeY allows stretching in the y direction, optional, default size
   * * sizeZ allows stretching in the z direction, optional, default size
   * * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor
   * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively
   * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively
   * * flat when true creates a flat shaded mesh, optional, default true
   * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4
   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
   * @returns the VertexData of the Polyhedron
   * @deprecated use CreatePolyhedronVertexData instead
   */
  static CreatePolyhedron(options) {
    throw _WarnImport("polyhedronBuilder");
  }
  /**
   * Creates the VertexData for a Capsule, inspired from https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js
   * @param options an object used to set the following optional parameters for the capsule, required but can be empty
   * @returns the VertexData of the Capsule
   * @deprecated Please use CreateCapsuleVertexData from the capsuleBuilder file instead
   */
  static CreateCapsule(options = {
    orientation: Vector3.Up(),
    subdivisions: 2,
    tessellation: 16,
    height: 1,
    radius: 0.25,
    capSubdivisions: 6
  }) {
    throw _WarnImport("capsuleBuilder");
  }
  // based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
  /**
   * Creates the VertexData for a TorusKnot
   * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty
   * * radius the radius of the torus knot, optional, default 2
   * * tube the thickness of the tube, optional, default 0.5
   * * radialSegments the number of sides on each tube segments, optional, default 32
   * * tubularSegments the number of tubes to decompose the knot into, optional, default 32
   * * p the number of windings around the z axis, optional,  default 2
   * * q the number of windings around the x axis, optional,  default 3
   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
   * @returns the VertexData of the Torus Knot
   * @deprecated use CreateTorusKnotVertexData instead
   */
  static CreateTorusKnot(options) {
    throw _WarnImport("torusKnotBuilder");
  }
  // Tools
  /**
   * Compute normals for given positions and indices
   * @param positions an array of vertex positions, [...., x, y, z, ......]
   * @param indices an array of indices in groups of three for each triangular facet, [...., i, j, k, ......]
   * @param normals an array of vertex normals, [...., x, y, z, ......]
   * @param options an object used to set the following optional parameters for the TorusKnot, optional
   * * facetNormals : optional array of facet normals (vector3)
   * * facetPositions : optional array of facet positions (vector3)
   * * facetPartitioning : optional partitioning array. facetPositions is required for facetPartitioning computation
   * * ratio : optional partitioning ratio / bounding box, required for facetPartitioning computation
   * * bInfo : optional bounding info, required for facetPartitioning computation
   * * bbSize : optional bounding box size data, required for facetPartitioning computation
   * * subDiv : optional partitioning data about subdivisions on  each axis (int), required for facetPartitioning computation
   * * useRightHandedSystem: optional boolean to for right handed system computation
   * * depthSort : optional boolean to enable the facet depth sort computation
   * * distanceTo : optional Vector3 to compute the facet depth from this location
   * * depthSortedFacets : optional array of depthSortedFacets to store the facet distances from the reference location
   */
  static ComputeNormals(positions, indices, normals, options) {
    let index = 0;
    let p1p2x = 0;
    let p1p2y = 0;
    let p1p2z = 0;
    let p3p2x = 0;
    let p3p2y = 0;
    let p3p2z = 0;
    let faceNormalx = 0;
    let faceNormaly = 0;
    let faceNormalz = 0;
    let length = 0;
    let v1x = 0;
    let v1y = 0;
    let v1z = 0;
    let v2x = 0;
    let v2y = 0;
    let v2z = 0;
    let v3x = 0;
    let v3y = 0;
    let v3z = 0;
    let computeFacetNormals = false;
    let computeFacetPositions = false;
    let computeFacetPartitioning = false;
    let computeDepthSort = false;
    let faceNormalSign = 1;
    let ratio = 0;
    let distanceTo = null;
    if (options) {
      computeFacetNormals = options.facetNormals ? true : false;
      computeFacetPositions = options.facetPositions ? true : false;
      computeFacetPartitioning = options.facetPartitioning ? true : false;
      faceNormalSign = options.useRightHandedSystem === true ? -1 : 1;
      ratio = options.ratio || 0;
      computeDepthSort = options.depthSort ? true : false;
      distanceTo = options.distanceTo;
      if (computeDepthSort) {
        if (distanceTo === void 0) {
          distanceTo = Vector3.Zero();
        }
      }
    }
    let xSubRatio = 0;
    let ySubRatio = 0;
    let zSubRatio = 0;
    let subSq = 0;
    if (computeFacetPartitioning && options && options.bbSize) {
      xSubRatio = options.subDiv.X * ratio / options.bbSize.x;
      ySubRatio = options.subDiv.Y * ratio / options.bbSize.y;
      zSubRatio = options.subDiv.Z * ratio / options.bbSize.z;
      subSq = options.subDiv.max * options.subDiv.max;
      options.facetPartitioning.length = 0;
    }
    for (index = 0; index < positions.length; index++) {
      normals[index] = 0;
    }
    const nbFaces = indices.length / 3 | 0;
    for (index = 0; index < nbFaces; index++) {
      v1x = indices[index * 3] * 3;
      v1y = v1x + 1;
      v1z = v1x + 2;
      v2x = indices[index * 3 + 1] * 3;
      v2y = v2x + 1;
      v2z = v2x + 2;
      v3x = indices[index * 3 + 2] * 3;
      v3y = v3x + 1;
      v3z = v3x + 2;
      p1p2x = positions[v1x] - positions[v2x];
      p1p2y = positions[v1y] - positions[v2y];
      p1p2z = positions[v1z] - positions[v2z];
      p3p2x = positions[v3x] - positions[v2x];
      p3p2y = positions[v3y] - positions[v2y];
      p3p2z = positions[v3z] - positions[v2z];
      faceNormalx = faceNormalSign * (p1p2y * p3p2z - p1p2z * p3p2y);
      faceNormaly = faceNormalSign * (p1p2z * p3p2x - p1p2x * p3p2z);
      faceNormalz = faceNormalSign * (p1p2x * p3p2y - p1p2y * p3p2x);
      length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);
      length = length === 0 ? 1 : length;
      faceNormalx /= length;
      faceNormaly /= length;
      faceNormalz /= length;
      if (computeFacetNormals && options) {
        options.facetNormals[index].x = faceNormalx;
        options.facetNormals[index].y = faceNormaly;
        options.facetNormals[index].z = faceNormalz;
      }
      if (computeFacetPositions && options) {
        options.facetPositions[index].x = (positions[v1x] + positions[v2x] + positions[v3x]) / 3;
        options.facetPositions[index].y = (positions[v1y] + positions[v2y] + positions[v3y]) / 3;
        options.facetPositions[index].z = (positions[v1z] + positions[v2z] + positions[v3z]) / 3;
      }
      if (computeFacetPartitioning && options) {
        const ox = Math.floor((options.facetPositions[index].x - options.bInfo.minimum.x * ratio) * xSubRatio);
        const oy = Math.floor((options.facetPositions[index].y - options.bInfo.minimum.y * ratio) * ySubRatio);
        const oz = Math.floor((options.facetPositions[index].z - options.bInfo.minimum.z * ratio) * zSubRatio);
        const b1x = Math.floor((positions[v1x] - options.bInfo.minimum.x * ratio) * xSubRatio);
        const b1y = Math.floor((positions[v1y] - options.bInfo.minimum.y * ratio) * ySubRatio);
        const b1z = Math.floor((positions[v1z] - options.bInfo.minimum.z * ratio) * zSubRatio);
        const b2x = Math.floor((positions[v2x] - options.bInfo.minimum.x * ratio) * xSubRatio);
        const b2y = Math.floor((positions[v2y] - options.bInfo.minimum.y * ratio) * ySubRatio);
        const b2z = Math.floor((positions[v2z] - options.bInfo.minimum.z * ratio) * zSubRatio);
        const b3x = Math.floor((positions[v3x] - options.bInfo.minimum.x * ratio) * xSubRatio);
        const b3y = Math.floor((positions[v3y] - options.bInfo.minimum.y * ratio) * ySubRatio);
        const b3z = Math.floor((positions[v3z] - options.bInfo.minimum.z * ratio) * zSubRatio);
        const block_idx_v1 = b1x + options.subDiv.max * b1y + subSq * b1z;
        const block_idx_v2 = b2x + options.subDiv.max * b2y + subSq * b2z;
        const block_idx_v3 = b3x + options.subDiv.max * b3y + subSq * b3z;
        const block_idx_o = ox + options.subDiv.max * oy + subSq * oz;
        options.facetPartitioning[block_idx_o] = options.facetPartitioning[block_idx_o] ? options.facetPartitioning[block_idx_o] : new Array();
        options.facetPartitioning[block_idx_v1] = options.facetPartitioning[block_idx_v1] ? options.facetPartitioning[block_idx_v1] : new Array();
        options.facetPartitioning[block_idx_v2] = options.facetPartitioning[block_idx_v2] ? options.facetPartitioning[block_idx_v2] : new Array();
        options.facetPartitioning[block_idx_v3] = options.facetPartitioning[block_idx_v3] ? options.facetPartitioning[block_idx_v3] : new Array();
        options.facetPartitioning[block_idx_v1].push(index);
        if (block_idx_v2 != block_idx_v1) {
          options.facetPartitioning[block_idx_v2].push(index);
        }
        if (!(block_idx_v3 == block_idx_v2 || block_idx_v3 == block_idx_v1)) {
          options.facetPartitioning[block_idx_v3].push(index);
        }
        if (!(block_idx_o == block_idx_v1 || block_idx_o == block_idx_v2 || block_idx_o == block_idx_v3)) {
          options.facetPartitioning[block_idx_o].push(index);
        }
      }
      if (computeDepthSort && options && options.facetPositions) {
        const dsf = options.depthSortedFacets[index];
        dsf.ind = index * 3;
        dsf.sqDistance = Vector3.DistanceSquared(options.facetPositions[index], distanceTo);
      }
      normals[v1x] += faceNormalx;
      normals[v1y] += faceNormaly;
      normals[v1z] += faceNormalz;
      normals[v2x] += faceNormalx;
      normals[v2y] += faceNormaly;
      normals[v2z] += faceNormalz;
      normals[v3x] += faceNormalx;
      normals[v3y] += faceNormaly;
      normals[v3z] += faceNormalz;
    }
    for (index = 0; index < normals.length / 3; index++) {
      faceNormalx = normals[index * 3];
      faceNormaly = normals[index * 3 + 1];
      faceNormalz = normals[index * 3 + 2];
      length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);
      length = length === 0 ? 1 : length;
      faceNormalx /= length;
      faceNormaly /= length;
      faceNormalz /= length;
      normals[index * 3] = faceNormalx;
      normals[index * 3 + 1] = faceNormaly;
      normals[index * 3 + 2] = faceNormalz;
    }
  }
  /**
   * @internal
   */
  static _ComputeSides(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs) {
    const li = indices.length;
    const ln = normals.length;
    let i;
    let n;
    sideOrientation = sideOrientation || _VertexData.DEFAULTSIDE;
    switch (sideOrientation) {
      case _VertexData.FRONTSIDE:
        break;
      case _VertexData.BACKSIDE:
        for (i = 0; i < li; i += 3) {
          const tmp = indices[i];
          indices[i] = indices[i + 2];
          indices[i + 2] = tmp;
        }
        for (n = 0; n < ln; n++) {
          normals[n] = -normals[n];
        }
        break;
      case _VertexData.DOUBLESIDE: {
        const lp = positions.length;
        const l = lp / 3;
        for (let p = 0; p < lp; p++) {
          positions[lp + p] = positions[p];
        }
        for (i = 0; i < li; i += 3) {
          indices[i + li] = indices[i + 2] + l;
          indices[i + 1 + li] = indices[i + 1] + l;
          indices[i + 2 + li] = indices[i] + l;
        }
        for (n = 0; n < ln; n++) {
          normals[ln + n] = -normals[n];
        }
        const lu = uvs.length;
        let u = 0;
        for (u = 0; u < lu; u++) {
          uvs[u + lu] = uvs[u];
        }
        frontUVs = frontUVs ? frontUVs : new Vector4(0, 0, 1, 1);
        backUVs = backUVs ? backUVs : new Vector4(0, 0, 1, 1);
        u = 0;
        for (i = 0; i < lu / 2; i++) {
          uvs[u] = frontUVs.x + (frontUVs.z - frontUVs.x) * uvs[u];
          uvs[u + 1] = frontUVs.y + (frontUVs.w - frontUVs.y) * uvs[u + 1];
          uvs[u + lu] = backUVs.x + (backUVs.z - backUVs.x) * uvs[u + lu];
          uvs[u + lu + 1] = backUVs.y + (backUVs.w - backUVs.y) * uvs[u + lu + 1];
          u += 2;
        }
        break;
      }
    }
  }
  /**
   * Creates a VertexData from serialized data
   * @param parsedVertexData the parsed data from an imported file
   * @returns a VertexData
   */
  static Parse(parsedVertexData) {
    const vertexData = new _VertexData();
    const positions = parsedVertexData.positions;
    if (positions) {
      vertexData.set(positions, VertexBuffer.PositionKind);
    }
    const normals = parsedVertexData.normals;
    if (normals) {
      vertexData.set(normals, VertexBuffer.NormalKind);
    }
    const tangents = parsedVertexData.tangents;
    if (tangents) {
      vertexData.set(tangents, VertexBuffer.TangentKind);
    }
    const uvs = parsedVertexData.uvs;
    if (uvs) {
      vertexData.set(uvs, VertexBuffer.UVKind);
    }
    const uvs2 = parsedVertexData.uvs2;
    if (uvs2) {
      vertexData.set(uvs2, VertexBuffer.UV2Kind);
    }
    const uvs3 = parsedVertexData.uvs3;
    if (uvs3) {
      vertexData.set(uvs3, VertexBuffer.UV3Kind);
    }
    const uvs4 = parsedVertexData.uvs4;
    if (uvs4) {
      vertexData.set(uvs4, VertexBuffer.UV4Kind);
    }
    const uvs5 = parsedVertexData.uvs5;
    if (uvs5) {
      vertexData.set(uvs5, VertexBuffer.UV5Kind);
    }
    const uvs6 = parsedVertexData.uvs6;
    if (uvs6) {
      vertexData.set(uvs6, VertexBuffer.UV6Kind);
    }
    const colors = parsedVertexData.colors;
    if (colors) {
      vertexData.set(Color4.CheckColors4(colors, positions.length / 3), VertexBuffer.ColorKind);
      if (parsedVertexData.hasVertexAlpha !== void 0) {
        vertexData.hasVertexAlpha = parsedVertexData.hasVertexAlpha;
      }
    }
    const matricesIndices = parsedVertexData.matricesIndices;
    if (matricesIndices) {
      vertexData.set(matricesIndices, VertexBuffer.MatricesIndicesKind);
    }
    const matricesWeights = parsedVertexData.matricesWeights;
    if (matricesWeights) {
      vertexData.set(matricesWeights, VertexBuffer.MatricesWeightsKind);
    }
    const indices = parsedVertexData.indices;
    if (indices) {
      vertexData.indices = indices;
    }
    const materialInfos = parsedVertexData.materialInfos;
    if (materialInfos) {
      vertexData.materialInfos = [];
      for (const materialInfoFromJSON of materialInfos) {
        const materialInfo = new VertexDataMaterialInfo();
        materialInfo.indexCount = materialInfoFromJSON.indexCount;
        materialInfo.indexStart = materialInfoFromJSON.indexStart;
        materialInfo.verticesCount = materialInfoFromJSON.verticesCount;
        materialInfo.verticesStart = materialInfoFromJSON.verticesStart;
        materialInfo.materialIndex = materialInfoFromJSON.materialIndex;
        vertexData.materialInfos.push(materialInfo);
      }
    }
    return vertexData;
  }
  /**
   * Applies VertexData created from the imported parameters to the geometry
   * @param parsedVertexData the parsed data from an imported file
   * @param geometry the geometry to apply the VertexData to
   */
  static ImportVertexData(parsedVertexData, geometry) {
    const vertexData = _VertexData.Parse(parsedVertexData);
    geometry.setAllVerticesData(vertexData, parsedVertexData.updatable);
  }
};
VertexData.FRONTSIDE = 0;
VertexData.BACKSIDE = 1;
VertexData.DOUBLESIDE = 2;
VertexData.DEFAULTSIDE = 0;
VertexData._UniqueIDGenerator = 0;
__decorate([
  nativeOverride.filter((...[coordinates]) => !Array.isArray(coordinates))
], VertexData, "_TransformVector3Coordinates", null);
__decorate([
  nativeOverride.filter((...[normals]) => !Array.isArray(normals))
], VertexData, "_TransformVector3Normals", null);
__decorate([
  nativeOverride.filter((...[normals]) => !Array.isArray(normals))
], VertexData, "_TransformVector4Normals", null);
__decorate([
  nativeOverride.filter((...[indices]) => !Array.isArray(indices))
], VertexData, "_FlipFaces", null);

// node_modules/@babylonjs/core/Meshes/transformNode.js
var convertRHSToLHS = Matrix.Compose(Vector3.One(), Quaternion.FromEulerAngles(0, Math.PI, 0), Vector3.Zero());
var TransformNode = class _TransformNode extends Node {
  /**
   * Gets or sets the billboard mode. Default is 0.
   *
   * | Value | Type | Description |
   * | --- | --- | --- |
   * | 0 | BILLBOARDMODE_NONE |  |
   * | 1 | BILLBOARDMODE_X |  |
   * | 2 | BILLBOARDMODE_Y |  |
   * | 4 | BILLBOARDMODE_Z |  |
   * | 7 | BILLBOARDMODE_ALL |  |
   *
   */
  get billboardMode() {
    return this._billboardMode;
  }
  set billboardMode(value) {
    if (this._billboardMode === value) {
      return;
    }
    this._billboardMode = value;
    this._cache.useBillboardPosition = (this._billboardMode & _TransformNode.BILLBOARDMODE_USE_POSITION) !== 0;
    this._computeUseBillboardPath();
  }
  /**
   * Gets or sets a boolean indicating that parent rotation should be preserved when using billboards.
   * This could be useful for glTF objects where parent rotation helps converting from right handed to left handed
   */
  get preserveParentRotationForBillboard() {
    return this._preserveParentRotationForBillboard;
  }
  set preserveParentRotationForBillboard(value) {
    if (value === this._preserveParentRotationForBillboard) {
      return;
    }
    this._preserveParentRotationForBillboard = value;
    this._computeUseBillboardPath();
  }
  _computeUseBillboardPath() {
    this._cache.useBillboardPath = this._billboardMode !== _TransformNode.BILLBOARDMODE_NONE && !this.preserveParentRotationForBillboard;
  }
  /**
   * Gets or sets the distance of the object to max, often used by skybox
   */
  get infiniteDistance() {
    return this._infiniteDistance;
  }
  set infiniteDistance(value) {
    if (this._infiniteDistance === value) {
      return;
    }
    this._infiniteDistance = value;
  }
  constructor(name3, scene = null, isPure = true) {
    super(name3, scene, false);
    this._forward = new Vector3(0, 0, 1);
    this._up = new Vector3(0, 1, 0);
    this._right = new Vector3(1, 0, 0);
    this._position = Vector3.Zero();
    this._rotation = Vector3.Zero();
    this._rotationQuaternion = null;
    this._scaling = Vector3.One();
    this._transformToBoneReferal = null;
    this._isAbsoluteSynced = false;
    this._billboardMode = _TransformNode.BILLBOARDMODE_NONE;
    this._preserveParentRotationForBillboard = false;
    this.scalingDeterminant = 1;
    this._infiniteDistance = false;
    this.ignoreNonUniformScaling = false;
    this.reIntegrateRotationIntoRotationQuaternion = false;
    this._poseMatrix = null;
    this._localMatrix = Matrix.Zero();
    this._usePivotMatrix = false;
    this._absolutePosition = Vector3.Zero();
    this._absoluteScaling = Vector3.Zero();
    this._absoluteRotationQuaternion = Quaternion.Identity();
    this._pivotMatrix = Matrix.Identity();
    this._postMultiplyPivotMatrix = false;
    this._isWorldMatrixFrozen = false;
    this._indexInSceneTransformNodesArray = -1;
    this.onAfterWorldMatrixUpdateObservable = new Observable();
    this._nonUniformScaling = false;
    if (isPure) {
      this.getScene().addTransformNode(this);
    }
  }
  /**
   * Gets a string identifying the name of the class
   * @returns "TransformNode" string
   */
  getClassName() {
    return "TransformNode";
  }
  /**
   * Gets or set the node position (default is (0.0, 0.0, 0.0))
   */
  get position() {
    return this._position;
  }
  set position(newPosition) {
    this._position = newPosition;
    this._markAsDirtyInternal();
  }
  /**
   * return true if a pivot has been set
   * @returns true if a pivot matrix is used
   */
  isUsingPivotMatrix() {
    return this._usePivotMatrix;
  }
  /**
   * @returns true if pivot matrix must be cancelled in the world matrix. When this parameter is set to true (default), the inverse of the pivot matrix is also applied at the end to cancel the transformation effect.
   */
  isUsingPostMultiplyPivotMatrix() {
    return this._postMultiplyPivotMatrix;
  }
  /**
   * Gets or sets the rotation property : a Vector3 defining the rotation value in radians around each local axis X, Y, Z  (default is (0.0, 0.0, 0.0)).
   * If rotation quaternion is set, this Vector3 will be ignored and copy from the quaternion
   */
  get rotation() {
    return this._rotation;
  }
  set rotation(newRotation) {
    this._rotation = newRotation;
    this._rotationQuaternion = null;
    this._markAsDirtyInternal();
  }
  /**
   * Gets or sets the scaling property : a Vector3 defining the node scaling along each local axis X, Y, Z (default is (1.0, 1.0, 1.0)).
   */
  get scaling() {
    return this._scaling;
  }
  set scaling(newScaling) {
    this._scaling = newScaling;
    this._markAsDirtyInternal();
  }
  /**
   * Gets or sets the rotation Quaternion property : this a Quaternion object defining the node rotation by using a unit quaternion (undefined by default, but can be null).
   * If set, only the rotationQuaternion is then used to compute the node rotation (ie. node.rotation will be ignored)
   */
  get rotationQuaternion() {
    return this._rotationQuaternion;
  }
  set rotationQuaternion(quaternion) {
    this._rotationQuaternion = quaternion;
    if (quaternion) {
      this._rotation.setAll(0);
    }
    this._markAsDirtyInternal();
  }
  _markAsDirtyInternal() {
    if (this._isDirty) {
      return;
    }
    this._isDirty = true;
    if (this.customMarkAsDirty) {
      this.customMarkAsDirty();
    }
  }
  /**
   * The forward direction of that transform in world space.
   */
  get forward() {
    Vector3.TransformNormalFromFloatsToRef(0, 0, this.getScene().useRightHandedSystem ? -1 : 1, this.getWorldMatrix(), this._forward);
    return this._forward.normalize();
  }
  /**
   * The up direction of that transform in world space.
   */
  get up() {
    Vector3.TransformNormalFromFloatsToRef(0, 1, 0, this.getWorldMatrix(), this._up);
    return this._up.normalize();
  }
  /**
   * The right direction of that transform in world space.
   */
  get right() {
    Vector3.TransformNormalFromFloatsToRef(this.getScene().useRightHandedSystem ? -1 : 1, 0, 0, this.getWorldMatrix(), this._right);
    return this._right.normalize();
  }
  /**
   * Copies the parameter passed Matrix into the mesh Pose matrix.
   * @param matrix the matrix to copy the pose from
   * @returns this TransformNode.
   */
  updatePoseMatrix(matrix) {
    if (!this._poseMatrix) {
      this._poseMatrix = matrix.clone();
      return this;
    }
    this._poseMatrix.copyFrom(matrix);
    return this;
  }
  /**
   * Returns the mesh Pose matrix.
   * @returns the pose matrix
   */
  getPoseMatrix() {
    if (!this._poseMatrix) {
      this._poseMatrix = Matrix.Identity();
    }
    return this._poseMatrix;
  }
  /** @internal */
  _isSynchronized() {
    const cache = this._cache;
    if (this._billboardMode !== cache.billboardMode || this._billboardMode !== _TransformNode.BILLBOARDMODE_NONE) {
      return false;
    }
    if (cache.pivotMatrixUpdated) {
      return false;
    }
    if (this._infiniteDistance) {
      return false;
    }
    if (this._position._isDirty) {
      return false;
    }
    if (this._scaling._isDirty) {
      return false;
    }
    if (this._rotationQuaternion && this._rotationQuaternion._isDirty || this._rotation._isDirty) {
      return false;
    }
    return true;
  }
  /** @internal */
  _initCache() {
    super._initCache();
    const cache = this._cache;
    cache.localMatrixUpdated = false;
    cache.billboardMode = -1;
    cache.infiniteDistance = false;
    cache.useBillboardPosition = false;
    cache.useBillboardPath = false;
  }
  /**
   * Returns the current mesh absolute position.
   * Returns a Vector3.
   */
  get absolutePosition() {
    return this.getAbsolutePosition();
  }
  /**
   * Returns the current mesh absolute scaling.
   * Returns a Vector3.
   */
  get absoluteScaling() {
    this._syncAbsoluteScalingAndRotation();
    return this._absoluteScaling;
  }
  /**
   * Returns the current mesh absolute rotation.
   * Returns a Quaternion.
   */
  get absoluteRotationQuaternion() {
    this._syncAbsoluteScalingAndRotation();
    return this._absoluteRotationQuaternion;
  }
  /**
   * Sets a new matrix to apply before all other transformation
   * @param matrix defines the transform matrix
   * @returns the current TransformNode
   */
  setPreTransformMatrix(matrix) {
    return this.setPivotMatrix(matrix, false);
  }
  /**
   * Sets a new pivot matrix to the current node
   * @param matrix defines the new pivot matrix to use
   * @param postMultiplyPivotMatrix defines if the pivot matrix must be cancelled in the world matrix. When this parameter is set to true (default), the inverse of the pivot matrix is also applied at the end to cancel the transformation effect
   * @returns the current TransformNode
   */
  setPivotMatrix(matrix, postMultiplyPivotMatrix = true) {
    this._pivotMatrix.copyFrom(matrix);
    this._usePivotMatrix = !this._pivotMatrix.isIdentity();
    this._cache.pivotMatrixUpdated = true;
    this._postMultiplyPivotMatrix = postMultiplyPivotMatrix;
    if (this._postMultiplyPivotMatrix) {
      if (!this._pivotMatrixInverse) {
        this._pivotMatrixInverse = Matrix.Invert(this._pivotMatrix);
      } else {
        this._pivotMatrix.invertToRef(this._pivotMatrixInverse);
      }
    }
    return this;
  }
  /**
   * Returns the mesh pivot matrix.
   * Default : Identity.
   * @returns the matrix
   */
  getPivotMatrix() {
    return this._pivotMatrix;
  }
  /**
   * Instantiate (when possible) or clone that node with its hierarchy
   * @param newParent defines the new parent to use for the instance (or clone)
   * @param options defines options to configure how copy is done
   * @param options.doNotInstantiate defines if the model must be instantiated or just cloned
   * @param onNewNodeCreated defines an option callback to call when a clone or an instance is created
   * @returns an instance (or a clone) of the current node with its hierarchy
   */
  instantiateHierarchy(newParent = null, options, onNewNodeCreated) {
    const clone = this.clone("Clone of " + (this.name || this.id), newParent || this.parent, true);
    if (clone) {
      if (onNewNodeCreated) {
        onNewNodeCreated(this, clone);
      }
    }
    for (const child of this.getChildTransformNodes(true)) {
      child.instantiateHierarchy(clone, options, onNewNodeCreated);
    }
    return clone;
  }
  /**
   * Prevents the World matrix to be computed any longer
   * @param newWorldMatrix defines an optional matrix to use as world matrix
   * @param decompose defines whether to decompose the given newWorldMatrix or directly assign
   * @returns the TransformNode.
   */
  freezeWorldMatrix(newWorldMatrix = null, decompose = false) {
    if (newWorldMatrix) {
      if (decompose) {
        this._rotation.setAll(0);
        this._rotationQuaternion = this._rotationQuaternion || Quaternion.Identity();
        newWorldMatrix.decompose(this._scaling, this._rotationQuaternion, this._position);
        this.computeWorldMatrix(true);
      } else {
        this._worldMatrix = newWorldMatrix;
        this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]);
        this._afterComputeWorldMatrix();
      }
    } else {
      this._isWorldMatrixFrozen = false;
      this.computeWorldMatrix(true);
    }
    this._isDirty = false;
    this._isWorldMatrixFrozen = true;
    return this;
  }
  /**
   * Allows back the World matrix computation.
   * @returns the TransformNode.
   */
  unfreezeWorldMatrix() {
    this._isWorldMatrixFrozen = false;
    this.computeWorldMatrix(true);
    return this;
  }
  /**
   * True if the World matrix has been frozen.
   */
  get isWorldMatrixFrozen() {
    return this._isWorldMatrixFrozen;
  }
  /**
   * Returns the mesh absolute position in the World.
   * @returns a Vector3.
   */
  getAbsolutePosition() {
    this.computeWorldMatrix();
    return this._absolutePosition;
  }
  /**
   * Sets the mesh absolute position in the World from a Vector3 or an Array(3).
   * @param absolutePosition the absolute position to set
   * @returns the TransformNode.
   */
  setAbsolutePosition(absolutePosition) {
    if (!absolutePosition) {
      return this;
    }
    let absolutePositionX;
    let absolutePositionY;
    let absolutePositionZ;
    if (absolutePosition.x === void 0) {
      if (arguments.length < 3) {
        return this;
      }
      absolutePositionX = arguments[0];
      absolutePositionY = arguments[1];
      absolutePositionZ = arguments[2];
    } else {
      absolutePositionX = absolutePosition.x;
      absolutePositionY = absolutePosition.y;
      absolutePositionZ = absolutePosition.z;
    }
    if (this.parent) {
      const invertParentWorldMatrix = TmpVectors.Matrix[0];
      this.parent.getWorldMatrix().invertToRef(invertParentWorldMatrix);
      Vector3.TransformCoordinatesFromFloatsToRef(absolutePositionX, absolutePositionY, absolutePositionZ, invertParentWorldMatrix, this.position);
    } else {
      this.position.x = absolutePositionX;
      this.position.y = absolutePositionY;
      this.position.z = absolutePositionZ;
    }
    this._absolutePosition.copyFrom(absolutePosition);
    return this;
  }
  /**
   * Sets the mesh position in its local space.
   * @param vector3 the position to set in localspace
   * @returns the TransformNode.
   */
  setPositionWithLocalVector(vector3) {
    this.computeWorldMatrix();
    this.position = Vector3.TransformNormal(vector3, this._localMatrix);
    return this;
  }
  /**
   * Returns the mesh position in the local space from the current World matrix values.
   * @returns a new Vector3.
   */
  getPositionExpressedInLocalSpace() {
    this.computeWorldMatrix();
    const invLocalWorldMatrix = TmpVectors.Matrix[0];
    this._localMatrix.invertToRef(invLocalWorldMatrix);
    return Vector3.TransformNormal(this.position, invLocalWorldMatrix);
  }
  /**
   * Translates the mesh along the passed Vector3 in its local space.
   * @param vector3 the distance to translate in localspace
   * @returns the TransformNode.
   */
  locallyTranslate(vector3) {
    this.computeWorldMatrix(true);
    this.position = Vector3.TransformCoordinates(vector3, this._localMatrix);
    return this;
  }
  /**
   * Orients a mesh towards a target point. Mesh must be drawn facing user.
   * @param targetPoint the position (must be in same space as current mesh) to look at
   * @param yawCor optional yaw (y-axis) correction in radians
   * @param pitchCor optional pitch (x-axis) correction in radians
   * @param rollCor optional roll (z-axis) correction in radians
   * @param space the chosen space of the target
   * @returns the TransformNode.
   */
  lookAt(targetPoint, yawCor = 0, pitchCor = 0, rollCor = 0, space = 0) {
    const dv = _TransformNode._LookAtVectorCache;
    const pos = space === 0 ? this.position : this.getAbsolutePosition();
    targetPoint.subtractToRef(pos, dv);
    this.setDirection(dv, yawCor, pitchCor, rollCor);
    if (space === 1 && this.parent) {
      if (this.rotationQuaternion) {
        const rotationMatrix = TmpVectors.Matrix[0];
        this.rotationQuaternion.toRotationMatrix(rotationMatrix);
        const parentRotationMatrix = TmpVectors.Matrix[1];
        this.parent.getWorldMatrix().getRotationMatrixToRef(parentRotationMatrix);
        parentRotationMatrix.invert();
        rotationMatrix.multiplyToRef(parentRotationMatrix, rotationMatrix);
        this.rotationQuaternion.fromRotationMatrix(rotationMatrix);
      } else {
        const quaternionRotation = TmpVectors.Quaternion[0];
        Quaternion.FromEulerVectorToRef(this.rotation, quaternionRotation);
        const rotationMatrix = TmpVectors.Matrix[0];
        quaternionRotation.toRotationMatrix(rotationMatrix);
        const parentRotationMatrix = TmpVectors.Matrix[1];
        this.parent.getWorldMatrix().getRotationMatrixToRef(parentRotationMatrix);
        parentRotationMatrix.invert();
        rotationMatrix.multiplyToRef(parentRotationMatrix, rotationMatrix);
        quaternionRotation.fromRotationMatrix(rotationMatrix);
        quaternionRotation.toEulerAnglesToRef(this.rotation);
      }
    }
    return this;
  }
  /**
   * Returns a new Vector3 that is the localAxis, expressed in the mesh local space, rotated like the mesh.
   * This Vector3 is expressed in the World space.
   * @param localAxis axis to rotate
   * @returns a new Vector3 that is the localAxis, expressed in the mesh local space, rotated like the mesh.
   */
  getDirection(localAxis) {
    const result = Vector3.Zero();
    this.getDirectionToRef(localAxis, result);
    return result;
  }
  /**
   * Sets the Vector3 "result" as the rotated Vector3 "localAxis" in the same rotation than the mesh.
   * localAxis is expressed in the mesh local space.
   * result is computed in the World space from the mesh World matrix.
   * @param localAxis axis to rotate
   * @param result the resulting transformnode
   * @returns this TransformNode.
   */
  getDirectionToRef(localAxis, result) {
    Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);
    return this;
  }
  /**
   * Sets this transform node rotation to the given local axis.
   * @param localAxis the axis in local space
   * @param yawCor optional yaw (y-axis) correction in radians
   * @param pitchCor optional pitch (x-axis) correction in radians
   * @param rollCor optional roll (z-axis) correction in radians
   * @returns this TransformNode
   */
  setDirection(localAxis, yawCor = 0, pitchCor = 0, rollCor = 0) {
    const yaw = -Math.atan2(localAxis.z, localAxis.x) + Math.PI / 2;
    const len = Math.sqrt(localAxis.x * localAxis.x + localAxis.z * localAxis.z);
    const pitch = -Math.atan2(localAxis.y, len);
    if (this.rotationQuaternion) {
      Quaternion.RotationYawPitchRollToRef(yaw + yawCor, pitch + pitchCor, rollCor, this.rotationQuaternion);
    } else {
      this.rotation.x = pitch + pitchCor;
      this.rotation.y = yaw + yawCor;
      this.rotation.z = rollCor;
    }
    return this;
  }
  /**
   * Sets a new pivot point to the current node
   * @param point defines the new pivot point to use
   * @param space defines if the point is in world or local space (local by default)
   * @returns the current TransformNode
   */
  setPivotPoint(point, space = 0) {
    if (this.getScene().getRenderId() == 0) {
      this.computeWorldMatrix(true);
    }
    const wm = this.getWorldMatrix();
    if (space == 1) {
      const tmat = TmpVectors.Matrix[0];
      wm.invertToRef(tmat);
      point = Vector3.TransformCoordinates(point, tmat);
    }
    return this.setPivotMatrix(Matrix.Translation(-point.x, -point.y, -point.z), true);
  }
  /**
   * Returns a new Vector3 set with the mesh pivot point coordinates in the local space.
   * @returns the pivot point
   */
  getPivotPoint() {
    const point = Vector3.Zero();
    this.getPivotPointToRef(point);
    return point;
  }
  /**
   * Sets the passed Vector3 "result" with the coordinates of the mesh pivot point in the local space.
   * @param result the vector3 to store the result
   * @returns this TransformNode.
   */
  getPivotPointToRef(result) {
    result.x = -this._pivotMatrix.m[12];
    result.y = -this._pivotMatrix.m[13];
    result.z = -this._pivotMatrix.m[14];
    return this;
  }
  /**
   * Returns a new Vector3 set with the mesh pivot point World coordinates.
   * @returns a new Vector3 set with the mesh pivot point World coordinates.
   */
  getAbsolutePivotPoint() {
    const point = Vector3.Zero();
    this.getAbsolutePivotPointToRef(point);
    return point;
  }
  /**
   * Sets the Vector3 "result" coordinates with the mesh pivot point World coordinates.
   * @param result vector3 to store the result
   * @returns this TransformNode.
   */
  getAbsolutePivotPointToRef(result) {
    this.getPivotPointToRef(result);
    Vector3.TransformCoordinatesToRef(result, this.getWorldMatrix(), result);
    return this;
  }
  /**
   * Flag the transform node as dirty (Forcing it to update everything)
   * @param property if set to "rotation" the objects rotationQuaternion will be set to null
   * @returns this  node
   */
  markAsDirty(property) {
    if (this._isDirty) {
      return this;
    }
    if (this._children) {
      for (const child of this._children) {
        child.markAsDirty(property);
      }
    }
    return super.markAsDirty(property);
  }
  /**
   * Defines the passed node as the parent of the current node.
   * The node will remain exactly where it is and its position / rotation will be updated accordingly.
   * If you don't want to preserve the current rotation / position, assign the parent through parent accessor.
   * Note that if the mesh has a pivot matrix / point defined it will be applied after the parent was updated.
   * In that case the node will not remain in the same space as it is, as the pivot will be applied.
   * To avoid this, you can set updatePivot to true and the pivot will be updated to identity
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/parent_pivot/parent
   * @param node the node ot set as the parent
   * @param preserveScalingSign if true, keep scaling sign of child. Otherwise, scaling sign might change.
   * @param updatePivot if true, update the pivot matrix to keep the node in the same space as before
   * @returns this TransformNode.
   */
  setParent(node, preserveScalingSign = false, updatePivot = false) {
    if (!node && !this.parent) {
      return this;
    }
    const quatRotation = TmpVectors.Quaternion[0];
    const position = TmpVectors.Vector3[0];
    const scale = TmpVectors.Vector3[1];
    const invParentMatrix = TmpVectors.Matrix[1];
    Matrix.IdentityToRef(invParentMatrix);
    const composedMatrix = TmpVectors.Matrix[0];
    this.computeWorldMatrix(true);
    let currentRotation = this.rotationQuaternion;
    if (!currentRotation) {
      currentRotation = _TransformNode._TmpRotation;
      Quaternion.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, currentRotation);
    }
    Matrix.ComposeToRef(this.scaling, currentRotation, this.position, composedMatrix);
    if (this.parent) {
      composedMatrix.multiplyToRef(this.parent.computeWorldMatrix(true), composedMatrix);
    }
    if (node) {
      node.computeWorldMatrix(true).invertToRef(invParentMatrix);
      composedMatrix.multiplyToRef(invParentMatrix, composedMatrix);
    }
    composedMatrix.decompose(scale, quatRotation, position, preserveScalingSign ? this : void 0);
    if (this.rotationQuaternion) {
      this.rotationQuaternion.copyFrom(quatRotation);
    } else {
      quatRotation.toEulerAnglesToRef(this.rotation);
    }
    this.scaling.copyFrom(scale);
    this.position.copyFrom(position);
    this.parent = node;
    if (updatePivot) {
      this.setPivotMatrix(Matrix.Identity());
    }
    return this;
  }
  /**
   * Adds the passed mesh as a child to the current mesh.
   * The node will remain exactly where it is and its position / rotation will be updated accordingly.
   * This method is equivalent to calling setParent().
   * @param mesh defines the child mesh
   * @param preserveScalingSign if true, keep scaling sign of child. Otherwise, scaling sign might change.
   * @returns the current mesh
   */
  addChild(mesh, preserveScalingSign = false) {
    mesh.setParent(this, preserveScalingSign);
    return this;
  }
  /**
   * Removes the passed mesh from the current mesh children list
   * @param mesh defines the child mesh
   * @param preserveScalingSign if true, keep scaling sign of child. Otherwise, scaling sign might change.
   * @returns the current mesh
   */
  removeChild(mesh, preserveScalingSign = false) {
    if (mesh.parent !== this)
      return this;
    mesh.setParent(null, preserveScalingSign);
    return this;
  }
  /**
   * True if the scaling property of this object is non uniform eg. (1,2,1)
   */
  get nonUniformScaling() {
    return this._nonUniformScaling;
  }
  /**
   * @internal
   */
  _updateNonUniformScalingState(value) {
    if (this._nonUniformScaling === value) {
      return false;
    }
    this._nonUniformScaling = value;
    return true;
  }
  /**
   * Attach the current TransformNode to another TransformNode associated with a bone
   * @param bone Bone affecting the TransformNode
   * @param affectedTransformNode TransformNode associated with the bone
   * @returns this object
   */
  attachToBone(bone, affectedTransformNode) {
    this._currentParentWhenAttachingToBone = this.parent;
    this._transformToBoneReferal = affectedTransformNode;
    this.parent = bone;
    bone.getSkeleton().prepare(true);
    if (bone.getFinalMatrix().determinant() < 0) {
      this.scalingDeterminant *= -1;
    }
    return this;
  }
  /**
   * Detach the transform node if its associated with a bone
   * @param resetToPreviousParent Indicates if the parent that was in effect when attachToBone was called should be set back or if we should set parent to null instead (defaults to the latter)
   * @returns this object
   */
  detachFromBone(resetToPreviousParent = false) {
    if (!this.parent) {
      if (resetToPreviousParent) {
        this.parent = this._currentParentWhenAttachingToBone;
      }
      return this;
    }
    if (this.parent.getWorldMatrix().determinant() < 0) {
      this.scalingDeterminant *= -1;
    }
    this._transformToBoneReferal = null;
    if (resetToPreviousParent) {
      this.parent = this._currentParentWhenAttachingToBone;
    } else {
      this.parent = null;
    }
    return this;
  }
  /**
   * Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in the given space.
   * space (default LOCAL) can be either Space.LOCAL, either Space.WORLD.
   * Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.
   * The passed axis is also normalized.
   * @param axis the axis to rotate around
   * @param amount the amount to rotate in radians
   * @param space Space to rotate in (Default: local)
   * @returns the TransformNode.
   */
  rotate(axis, amount, space) {
    axis.normalize();
    if (!this.rotationQuaternion) {
      this.rotationQuaternion = this.rotation.toQuaternion();
      this.rotation.setAll(0);
    }
    let rotationQuaternion;
    if (!space || space === 0) {
      rotationQuaternion = Quaternion.RotationAxisToRef(axis, amount, _TransformNode._RotationAxisCache);
      this.rotationQuaternion.multiplyToRef(rotationQuaternion, this.rotationQuaternion);
    } else {
      if (this.parent) {
        const parentWorldMatrix = this.parent.getWorldMatrix();
        const invertParentWorldMatrix = TmpVectors.Matrix[0];
        parentWorldMatrix.invertToRef(invertParentWorldMatrix);
        axis = Vector3.TransformNormal(axis, invertParentWorldMatrix);
        if (parentWorldMatrix.determinant() < 0) {
          amount *= -1;
        }
      }
      rotationQuaternion = Quaternion.RotationAxisToRef(axis, amount, _TransformNode._RotationAxisCache);
      rotationQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);
    }
    return this;
  }
  /**
   * Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in world space.
   * Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.
   * The passed axis is also normalized. .
   * Method is based on http://www.euclideanspace.com/maths/geometry/affine/aroundPoint/index.htm
   * @param point the point to rotate around
   * @param axis the axis to rotate around
   * @param amount the amount to rotate in radians
   * @returns the TransformNode
   */
  rotateAround(point, axis, amount) {
    axis.normalize();
    if (!this.rotationQuaternion) {
      this.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);
      this.rotation.setAll(0);
    }
    const tmpVector = TmpVectors.Vector3[0];
    const finalScale = TmpVectors.Vector3[1];
    const finalTranslation = TmpVectors.Vector3[2];
    const finalRotation = TmpVectors.Quaternion[0];
    const translationMatrix = TmpVectors.Matrix[0];
    const translationMatrixInv = TmpVectors.Matrix[1];
    const rotationMatrix = TmpVectors.Matrix[2];
    const finalMatrix = TmpVectors.Matrix[3];
    point.subtractToRef(this.position, tmpVector);
    Matrix.TranslationToRef(tmpVector.x, tmpVector.y, tmpVector.z, translationMatrix);
    Matrix.TranslationToRef(-tmpVector.x, -tmpVector.y, -tmpVector.z, translationMatrixInv);
    Matrix.RotationAxisToRef(axis, amount, rotationMatrix);
    translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix);
    finalMatrix.multiplyToRef(translationMatrix, finalMatrix);
    finalMatrix.decompose(finalScale, finalRotation, finalTranslation);
    this.position.addInPlace(finalTranslation);
    finalRotation.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);
    return this;
  }
  /**
   * Translates the mesh along the axis vector for the passed distance in the given space.
   * space (default LOCAL) can be either Space.LOCAL, either Space.WORLD.
   * @param axis the axis to translate in
   * @param distance the distance to translate
   * @param space Space to rotate in (Default: local)
   * @returns the TransformNode.
   */
  translate(axis, distance, space) {
    const displacementVector = axis.scale(distance);
    if (!space || space === 0) {
      const tempV3 = this.getPositionExpressedInLocalSpace().add(displacementVector);
      this.setPositionWithLocalVector(tempV3);
    } else {
      this.setAbsolutePosition(this.getAbsolutePosition().add(displacementVector));
    }
    return this;
  }
  /**
   * Adds a rotation step to the mesh current rotation.
   * x, y, z are Euler angles expressed in radians.
   * This methods updates the current mesh rotation, either mesh.rotation, either mesh.rotationQuaternion if it's set.
   * This means this rotation is made in the mesh local space only.
   * It's useful to set a custom rotation order different from the BJS standard one YXZ.
   * Example : this rotates the mesh first around its local X axis, then around its local Z axis, finally around its local Y axis.
   * ```javascript
   * mesh.addRotation(x1, 0, 0).addRotation(0, 0, z2).addRotation(0, 0, y3);
   * ```
   * Note that `addRotation()` accumulates the passed rotation values to the current ones and computes the .rotation or .rotationQuaternion updated values.
   * Under the hood, only quaternions are used. So it's a little faster is you use .rotationQuaternion because it doesn't need to translate them back to Euler angles.
   * @param x Rotation to add
   * @param y Rotation to add
   * @param z Rotation to add
   * @returns the TransformNode.
   */
  addRotation(x, y, z) {
    let rotationQuaternion;
    if (this.rotationQuaternion) {
      rotationQuaternion = this.rotationQuaternion;
    } else {
      rotationQuaternion = TmpVectors.Quaternion[1];
      Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, rotationQuaternion);
    }
    const accumulation = TmpVectors.Quaternion[0];
    Quaternion.RotationYawPitchRollToRef(y, x, z, accumulation);
    rotationQuaternion.multiplyInPlace(accumulation);
    if (!this.rotationQuaternion) {
      rotationQuaternion.toEulerAnglesToRef(this.rotation);
    }
    return this;
  }
  /**
   * @internal
   */
  _getEffectiveParent() {
    return this.parent;
  }
  /**
   * Returns whether the transform node world matrix computation needs the camera information to be computed.
   * This is the case when the node is a billboard or has an infinite distance for instance.
   * @returns true if the world matrix computation needs the camera information to be computed
   */
  isWorldMatrixCameraDependent() {
    return this._infiniteDistance && !this.parent || this._billboardMode !== _TransformNode.BILLBOARDMODE_NONE && !this.preserveParentRotationForBillboard;
  }
  /**
   * Computes the world matrix of the node
   * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch
   * @param camera defines the camera used if different from the scene active camera (This is used with modes like Billboard or infinite distance)
   * @returns the world matrix
   */
  computeWorldMatrix(force = false, camera = null) {
    if (this._isWorldMatrixFrozen && !this._isDirty) {
      return this._worldMatrix;
    }
    const currentRenderId = this.getScene().getRenderId();
    if (!this._isDirty && !force && (this._currentRenderId === currentRenderId || this.isSynchronized())) {
      this._currentRenderId = currentRenderId;
      return this._worldMatrix;
    }
    camera = camera || this.getScene().activeCamera;
    this._updateCache();
    const cache = this._cache;
    cache.pivotMatrixUpdated = false;
    cache.billboardMode = this.billboardMode;
    cache.infiniteDistance = this.infiniteDistance;
    cache.parent = this._parentNode;
    this._currentRenderId = currentRenderId;
    this._childUpdateId += 1;
    this._isDirty = false;
    this._position._isDirty = false;
    this._rotation._isDirty = false;
    this._scaling._isDirty = false;
    const parent = this._getEffectiveParent();
    const scaling = _TransformNode._TmpScaling;
    let translation = this._position;
    if (this._infiniteDistance) {
      if (!this.parent && camera) {
        const cameraWorldMatrix = camera.getWorldMatrix();
        const cameraGlobalPosition = new Vector3(cameraWorldMatrix.m[12], cameraWorldMatrix.m[13], cameraWorldMatrix.m[14]);
        translation = _TransformNode._TmpTranslation;
        translation.copyFromFloats(this._position.x + cameraGlobalPosition.x, this._position.y + cameraGlobalPosition.y, this._position.z + cameraGlobalPosition.z);
      }
    }
    scaling.copyFromFloats(this._scaling.x * this.scalingDeterminant, this._scaling.y * this.scalingDeterminant, this._scaling.z * this.scalingDeterminant);
    let rotation;
    if (this._rotationQuaternion) {
      this._rotationQuaternion._isDirty = false;
      rotation = this._rotationQuaternion;
      if (this.reIntegrateRotationIntoRotationQuaternion) {
        const len = this.rotation.lengthSquared();
        if (len) {
          this._rotationQuaternion.multiplyInPlace(Quaternion.RotationYawPitchRoll(this._rotation.y, this._rotation.x, this._rotation.z));
          this._rotation.copyFromFloats(0, 0, 0);
        }
      }
    } else {
      rotation = _TransformNode._TmpRotation;
      Quaternion.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, rotation);
    }
    if (this._usePivotMatrix) {
      const scaleMatrix = TmpVectors.Matrix[1];
      Matrix.ScalingToRef(scaling.x, scaling.y, scaling.z, scaleMatrix);
      const rotationMatrix = TmpVectors.Matrix[0];
      rotation.toRotationMatrix(rotationMatrix);
      this._pivotMatrix.multiplyToRef(scaleMatrix, TmpVectors.Matrix[4]);
      TmpVectors.Matrix[4].multiplyToRef(rotationMatrix, this._localMatrix);
      if (this._postMultiplyPivotMatrix) {
        this._localMatrix.multiplyToRef(this._pivotMatrixInverse, this._localMatrix);
      }
      this._localMatrix.addTranslationFromFloats(translation.x, translation.y, translation.z);
    } else {
      Matrix.ComposeToRef(scaling, rotation, translation, this._localMatrix);
    }
    if (parent && parent.getWorldMatrix) {
      if (force) {
        parent.computeWorldMatrix(force);
      }
      if (cache.useBillboardPath) {
        if (this._transformToBoneReferal) {
          const bone = this.parent;
          bone.getSkeleton().prepare();
          bone.getFinalMatrix().multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), TmpVectors.Matrix[7]);
        } else {
          TmpVectors.Matrix[7].copyFrom(parent.getWorldMatrix());
        }
        const translation2 = TmpVectors.Vector3[5];
        const scale = TmpVectors.Vector3[6];
        const orientation = TmpVectors.Quaternion[0];
        TmpVectors.Matrix[7].decompose(scale, orientation, translation2);
        Matrix.ScalingToRef(scale.x, scale.y, scale.z, TmpVectors.Matrix[7]);
        TmpVectors.Matrix[7].setTranslation(translation2);
        if (_TransformNode.BillboardUseParentOrientation) {
          this._position.applyRotationQuaternionToRef(orientation, translation2);
          this._localMatrix.setTranslation(translation2);
        }
        this._localMatrix.multiplyToRef(TmpVectors.Matrix[7], this._worldMatrix);
      } else {
        if (this._transformToBoneReferal) {
          const bone = this.parent;
          bone.getSkeleton().prepare();
          this._localMatrix.multiplyToRef(bone.getFinalMatrix(), TmpVectors.Matrix[6]);
          TmpVectors.Matrix[6].multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), this._worldMatrix);
        } else {
          this._localMatrix.multiplyToRef(parent.getWorldMatrix(), this._worldMatrix);
        }
      }
      this._markSyncedWithParent();
    } else {
      this._worldMatrix.copyFrom(this._localMatrix);
    }
    if (cache.useBillboardPath && camera && this.billboardMode && !cache.useBillboardPosition) {
      const storedTranslation = TmpVectors.Vector3[0];
      this._worldMatrix.getTranslationToRef(storedTranslation);
      TmpVectors.Matrix[1].copyFrom(camera.getViewMatrix());
      if (this._scene.useRightHandedSystem) {
        TmpVectors.Matrix[1].multiplyToRef(convertRHSToLHS, TmpVectors.Matrix[1]);
      }
      TmpVectors.Matrix[1].setTranslationFromFloats(0, 0, 0);
      TmpVectors.Matrix[1].invertToRef(TmpVectors.Matrix[0]);
      if ((this.billboardMode & _TransformNode.BILLBOARDMODE_ALL) !== _TransformNode.BILLBOARDMODE_ALL) {
        TmpVectors.Matrix[0].decompose(void 0, TmpVectors.Quaternion[0], void 0);
        const eulerAngles = TmpVectors.Vector3[1];
        TmpVectors.Quaternion[0].toEulerAnglesToRef(eulerAngles);
        if ((this.billboardMode & _TransformNode.BILLBOARDMODE_X) !== _TransformNode.BILLBOARDMODE_X) {
          eulerAngles.x = 0;
        }
        if ((this.billboardMode & _TransformNode.BILLBOARDMODE_Y) !== _TransformNode.BILLBOARDMODE_Y) {
          eulerAngles.y = 0;
        }
        if ((this.billboardMode & _TransformNode.BILLBOARDMODE_Z) !== _TransformNode.BILLBOARDMODE_Z) {
          eulerAngles.z = 0;
        }
        Matrix.RotationYawPitchRollToRef(eulerAngles.y, eulerAngles.x, eulerAngles.z, TmpVectors.Matrix[0]);
      }
      this._worldMatrix.setTranslationFromFloats(0, 0, 0);
      this._worldMatrix.multiplyToRef(TmpVectors.Matrix[0], this._worldMatrix);
      this._worldMatrix.setTranslation(TmpVectors.Vector3[0]);
    } else if (cache.useBillboardPath && camera && cache.useBillboardPosition) {
      const storedTranslation = TmpVectors.Vector3[0];
      this._worldMatrix.getTranslationToRef(storedTranslation);
      const cameraPosition = camera.globalPosition;
      this._worldMatrix.invertToRef(TmpVectors.Matrix[1]);
      const camInObjSpace = TmpVectors.Vector3[1];
      Vector3.TransformCoordinatesToRef(cameraPosition, TmpVectors.Matrix[1], camInObjSpace);
      camInObjSpace.normalize();
      const yaw = -Math.atan2(camInObjSpace.z, camInObjSpace.x) + Math.PI / 2;
      const len = Math.sqrt(camInObjSpace.x * camInObjSpace.x + camInObjSpace.z * camInObjSpace.z);
      const pitch = -Math.atan2(camInObjSpace.y, len);
      Quaternion.RotationYawPitchRollToRef(yaw, pitch, 0, TmpVectors.Quaternion[0]);
      if ((this.billboardMode & _TransformNode.BILLBOARDMODE_ALL) !== _TransformNode.BILLBOARDMODE_ALL) {
        const eulerAngles = TmpVectors.Vector3[1];
        TmpVectors.Quaternion[0].toEulerAnglesToRef(eulerAngles);
        if ((this.billboardMode & _TransformNode.BILLBOARDMODE_X) !== _TransformNode.BILLBOARDMODE_X) {
          eulerAngles.x = 0;
        }
        if ((this.billboardMode & _TransformNode.BILLBOARDMODE_Y) !== _TransformNode.BILLBOARDMODE_Y) {
          eulerAngles.y = 0;
        }
        if ((this.billboardMode & _TransformNode.BILLBOARDMODE_Z) !== _TransformNode.BILLBOARDMODE_Z) {
          eulerAngles.z = 0;
        }
        Matrix.RotationYawPitchRollToRef(eulerAngles.y, eulerAngles.x, eulerAngles.z, TmpVectors.Matrix[0]);
      } else {
        Matrix.FromQuaternionToRef(TmpVectors.Quaternion[0], TmpVectors.Matrix[0]);
      }
      this._worldMatrix.setTranslationFromFloats(0, 0, 0);
      this._worldMatrix.multiplyToRef(TmpVectors.Matrix[0], this._worldMatrix);
      this._worldMatrix.setTranslation(TmpVectors.Vector3[0]);
    }
    if (!this.ignoreNonUniformScaling) {
      if (this._scaling.isNonUniformWithinEpsilon(1e-6)) {
        this._updateNonUniformScalingState(true);
      } else if (parent && parent._nonUniformScaling) {
        this._updateNonUniformScalingState(parent._nonUniformScaling);
      } else {
        this._updateNonUniformScalingState(false);
      }
    } else {
      this._updateNonUniformScalingState(false);
    }
    this._afterComputeWorldMatrix();
    this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]);
    this._isAbsoluteSynced = false;
    this.onAfterWorldMatrixUpdateObservable.notifyObservers(this);
    if (!this._poseMatrix) {
      this._poseMatrix = Matrix.Invert(this._worldMatrix);
    }
    this._worldMatrixDeterminantIsDirty = true;
    return this._worldMatrix;
  }
  /**
   * Resets this nodeTransform's local matrix to Matrix.Identity().
   * @param independentOfChildren indicates if all child nodeTransform's world-space transform should be preserved.
   */
  resetLocalMatrix(independentOfChildren = true) {
    this.computeWorldMatrix();
    if (independentOfChildren) {
      const children = this.getChildren();
      for (let i = 0; i < children.length; ++i) {
        const child = children[i];
        if (child) {
          child.computeWorldMatrix();
          const bakedMatrix = TmpVectors.Matrix[0];
          child._localMatrix.multiplyToRef(this._localMatrix, bakedMatrix);
          const tmpRotationQuaternion = TmpVectors.Quaternion[0];
          bakedMatrix.decompose(child.scaling, tmpRotationQuaternion, child.position);
          if (child.rotationQuaternion) {
            child.rotationQuaternion.copyFrom(tmpRotationQuaternion);
          } else {
            tmpRotationQuaternion.toEulerAnglesToRef(child.rotation);
          }
        }
      }
    }
    this.scaling.copyFromFloats(1, 1, 1);
    this.position.copyFromFloats(0, 0, 0);
    this.rotation.copyFromFloats(0, 0, 0);
    if (this.rotationQuaternion) {
      this.rotationQuaternion = Quaternion.Identity();
    }
    this._worldMatrix = Matrix.Identity();
  }
  _afterComputeWorldMatrix() {
  }
  /**
   * If you'd like to be called back after the mesh position, rotation or scaling has been updated.
   * @param func callback function to add
   *
   * @returns the TransformNode.
   */
  registerAfterWorldMatrixUpdate(func) {
    this.onAfterWorldMatrixUpdateObservable.add(func);
    return this;
  }
  /**
   * Removes a registered callback function.
   * @param func callback function to remove
   * @returns the TransformNode.
   */
  unregisterAfterWorldMatrixUpdate(func) {
    this.onAfterWorldMatrixUpdateObservable.removeCallback(func);
    return this;
  }
  /**
   * Gets the position of the current mesh in camera space
   * @param camera defines the camera to use
   * @returns a position
   */
  getPositionInCameraSpace(camera = null) {
    if (!camera) {
      camera = this.getScene().activeCamera;
    }
    return Vector3.TransformCoordinates(this.getAbsolutePosition(), camera.getViewMatrix());
  }
  /**
   * Returns the distance from the mesh to the active camera
   * @param camera defines the camera to use
   * @returns the distance
   */
  getDistanceToCamera(camera = null) {
    if (!camera) {
      camera = this.getScene().activeCamera;
    }
    return this.getAbsolutePosition().subtract(camera.globalPosition).length();
  }
  /**
   * Clone the current transform node
   * @param name Name of the new clone
   * @param newParent New parent for the clone
   * @param doNotCloneChildren Do not clone children hierarchy
   * @returns the new transform node
   */
  clone(name3, newParent, doNotCloneChildren) {
    const result = SerializationHelper.Clone(() => new _TransformNode(name3, this.getScene()), this);
    result.name = name3;
    result.id = name3;
    if (newParent) {
      result.parent = newParent;
    }
    if (!doNotCloneChildren) {
      const directDescendants = this.getDescendants(true);
      for (let index = 0; index < directDescendants.length; index++) {
        const child = directDescendants[index];
        if (child.clone) {
          child.clone(name3 + "." + child.name, result);
        }
      }
    }
    return result;
  }
  /**
   * Serializes the objects information.
   * @param currentSerializationObject defines the object to serialize in
   * @returns the serialized object
   */
  serialize(currentSerializationObject) {
    const serializationObject = SerializationHelper.Serialize(this, currentSerializationObject);
    serializationObject.type = this.getClassName();
    serializationObject.uniqueId = this.uniqueId;
    if (this.parent) {
      this.parent._serializeAsParent(serializationObject);
    }
    serializationObject.localMatrix = this.getPivotMatrix().asArray();
    serializationObject.isEnabled = this.isEnabled();
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    serializationObject.ranges = this.serializeAnimationRanges();
    return serializationObject;
  }
  // Statics
  /**
   * Returns a new TransformNode object parsed from the source provided.
   * @param parsedTransformNode is the source.
   * @param scene the scene the object belongs to
   * @param rootUrl is a string, it's the root URL to prefix the `delayLoadingFile` property with
   * @returns a new TransformNode object parsed from the source provided.
   */
  static Parse(parsedTransformNode, scene, rootUrl) {
    const transformNode = SerializationHelper.Parse(() => new _TransformNode(parsedTransformNode.name, scene), parsedTransformNode, scene, rootUrl);
    if (parsedTransformNode.localMatrix) {
      transformNode.setPreTransformMatrix(Matrix.FromArray(parsedTransformNode.localMatrix));
    } else if (parsedTransformNode.pivotMatrix) {
      transformNode.setPivotMatrix(Matrix.FromArray(parsedTransformNode.pivotMatrix));
    }
    transformNode.setEnabled(parsedTransformNode.isEnabled);
    transformNode._waitingParsedUniqueId = parsedTransformNode.uniqueId;
    if (parsedTransformNode.parentId !== void 0) {
      transformNode._waitingParentId = parsedTransformNode.parentId;
    }
    if (parsedTransformNode.parentInstanceIndex !== void 0) {
      transformNode._waitingParentInstanceIndex = parsedTransformNode.parentInstanceIndex;
    }
    if (parsedTransformNode.animations) {
      for (let animationIndex = 0; animationIndex < parsedTransformNode.animations.length; animationIndex++) {
        const parsedAnimation = parsedTransformNode.animations[animationIndex];
        const internalClass = GetClass("BABYLON.Animation");
        if (internalClass) {
          transformNode.animations.push(internalClass.Parse(parsedAnimation));
        }
      }
      Node.ParseAnimationRanges(transformNode, parsedTransformNode, scene);
    }
    if (parsedTransformNode.autoAnimate) {
      scene.beginAnimation(transformNode, parsedTransformNode.autoAnimateFrom, parsedTransformNode.autoAnimateTo, parsedTransformNode.autoAnimateLoop, parsedTransformNode.autoAnimateSpeed || 1);
    }
    return transformNode;
  }
  /**
   * Get all child-transformNodes of this node
   * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered
   * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored
   * @returns an array of TransformNode
   */
  getChildTransformNodes(directDescendantsOnly, predicate) {
    const results = [];
    this._getDescendants(results, directDescendantsOnly, (node) => {
      return (!predicate || predicate(node)) && node instanceof _TransformNode;
    });
    return results;
  }
  /**
   * Releases resources associated with this transform node.
   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
   */
  dispose(doNotRecurse, disposeMaterialAndTextures = false) {
    this.getScene().stopAnimation(this);
    this.getScene().removeTransformNode(this);
    if (this._parentContainer) {
      const index = this._parentContainer.transformNodes.indexOf(this);
      if (index > -1) {
        this._parentContainer.transformNodes.splice(index, 1);
      }
      this._parentContainer = null;
    }
    this.onAfterWorldMatrixUpdateObservable.clear();
    if (doNotRecurse) {
      const transformNodes = this.getChildTransformNodes(true);
      for (const transformNode of transformNodes) {
        transformNode.parent = null;
        transformNode.computeWorldMatrix(true);
      }
    }
    super.dispose(doNotRecurse, disposeMaterialAndTextures);
  }
  /**
   * Uniformly scales the mesh to fit inside of a unit cube (1 X 1 X 1 units)
   * @param includeDescendants Use the hierarchy's bounding box instead of the mesh's bounding box. Default is false
   * @param ignoreRotation ignore rotation when computing the scale (ie. object will be axis aligned). Default is false
   * @param predicate predicate that is passed in to getHierarchyBoundingVectors when selecting which object should be included when scaling
   * @returns the current mesh
   */
  normalizeToUnitCube(includeDescendants = true, ignoreRotation = false, predicate) {
    let storedRotation = null;
    let storedRotationQuaternion = null;
    if (ignoreRotation) {
      if (this.rotationQuaternion) {
        storedRotationQuaternion = this.rotationQuaternion.clone();
        this.rotationQuaternion.copyFromFloats(0, 0, 0, 1);
      } else if (this.rotation) {
        storedRotation = this.rotation.clone();
        this.rotation.copyFromFloats(0, 0, 0);
      }
    }
    const boundingVectors = this.getHierarchyBoundingVectors(includeDescendants, predicate);
    const sizeVec = boundingVectors.max.subtract(boundingVectors.min);
    const maxDimension = Math.max(sizeVec.x, sizeVec.y, sizeVec.z);
    if (maxDimension === 0) {
      return this;
    }
    const scale = 1 / maxDimension;
    this.scaling.scaleInPlace(scale);
    if (ignoreRotation) {
      if (this.rotationQuaternion && storedRotationQuaternion) {
        this.rotationQuaternion.copyFrom(storedRotationQuaternion);
      } else if (this.rotation && storedRotation) {
        this.rotation.copyFrom(storedRotation);
      }
    }
    return this;
  }
  _syncAbsoluteScalingAndRotation() {
    if (!this._isAbsoluteSynced) {
      this._worldMatrix.decompose(this._absoluteScaling, this._absoluteRotationQuaternion);
      this._isAbsoluteSynced = true;
    }
  }
};
TransformNode.BILLBOARDMODE_NONE = 0;
TransformNode.BILLBOARDMODE_X = 1;
TransformNode.BILLBOARDMODE_Y = 2;
TransformNode.BILLBOARDMODE_Z = 4;
TransformNode.BILLBOARDMODE_ALL = 7;
TransformNode.BILLBOARDMODE_USE_POSITION = 128;
TransformNode.BillboardUseParentOrientation = false;
TransformNode._TmpRotation = Quaternion.Zero();
TransformNode._TmpScaling = Vector3.Zero();
TransformNode._TmpTranslation = Vector3.Zero();
TransformNode._LookAtVectorCache = new Vector3(0, 0, 0);
TransformNode._RotationAxisCache = new Quaternion();
__decorate([
  serializeAsVector3("position")
], TransformNode.prototype, "_position", void 0);
__decorate([
  serializeAsVector3("rotation")
], TransformNode.prototype, "_rotation", void 0);
__decorate([
  serializeAsQuaternion("rotationQuaternion")
], TransformNode.prototype, "_rotationQuaternion", void 0);
__decorate([
  serializeAsVector3("scaling")
], TransformNode.prototype, "_scaling", void 0);
__decorate([
  serialize("billboardMode")
], TransformNode.prototype, "_billboardMode", void 0);
__decorate([
  serialize()
], TransformNode.prototype, "scalingDeterminant", void 0);
__decorate([
  serialize("infiniteDistance")
], TransformNode.prototype, "_infiniteDistance", void 0);
__decorate([
  serialize()
], TransformNode.prototype, "ignoreNonUniformScaling", void 0);
__decorate([
  serialize()
], TransformNode.prototype, "reIntegrateRotationIntoRotationQuaternion", void 0);

// node_modules/@babylonjs/core/Collisions/meshCollisionData.js
var _MeshCollisionData = class {
  constructor() {
    this._checkCollisions = false;
    this._collisionMask = -1;
    this._collisionGroup = -1;
    this._surroundingMeshes = null;
    this._collider = null;
    this._oldPositionForCollisions = new Vector3(0, 0, 0);
    this._diffPositionForCollisions = new Vector3(0, 0, 0);
    this._collisionResponse = true;
  }
};

// node_modules/@babylonjs/core/Meshes/abstractMesh.js
function applyMorph(data, kind, morphTargetManager) {
  let getTargetData = null;
  switch (kind) {
    case VertexBuffer.PositionKind:
      getTargetData = (target) => target.getPositions();
      break;
    case VertexBuffer.NormalKind:
      getTargetData = (target) => target.getNormals();
      break;
    case VertexBuffer.TangentKind:
      getTargetData = (target) => target.getTangents();
      break;
    case VertexBuffer.UVKind:
      getTargetData = (target) => target.getUVs();
      break;
    case VertexBuffer.UV2Kind:
      getTargetData = (target) => target.getUV2s();
      break;
    case VertexBuffer.ColorKind:
      getTargetData = (target) => target.getColors();
      break;
    default:
      return;
  }
  for (let index = 0; index < data.length; index++) {
    let value = data[index];
    for (let targetCount = 0; targetCount < morphTargetManager.numTargets; targetCount++) {
      const target = morphTargetManager.getTarget(targetCount);
      const influence = target.influence;
      if (influence !== 0) {
        const targetData = getTargetData(target);
        if (targetData) {
          value += (targetData[index] - data[index]) * influence;
        }
      }
    }
    data[index] = value;
  }
}
function applySkeleton(data, kind, skeletonMatrices, matricesIndicesData, matricesWeightsData, matricesIndicesExtraData, matricesWeightsExtraData) {
  const tempVector = TmpVectors.Vector3[0];
  const finalMatrix = TmpVectors.Matrix[0];
  const tempMatrix = TmpVectors.Matrix[1];
  const transformFromFloatsToRef = kind === VertexBuffer.NormalKind ? Vector3.TransformNormalFromFloatsToRef : Vector3.TransformCoordinatesFromFloatsToRef;
  for (let index = 0, matWeightIdx = 0; index < data.length; index += 3, matWeightIdx += 4) {
    finalMatrix.reset();
    let inf;
    let weight;
    for (inf = 0; inf < 4; inf++) {
      weight = matricesWeightsData[matWeightIdx + inf];
      if (weight > 0) {
        Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);
        finalMatrix.addToSelf(tempMatrix);
      }
    }
    if (matricesIndicesExtraData && matricesWeightsExtraData) {
      for (inf = 0; inf < 4; inf++) {
        weight = matricesWeightsExtraData[matWeightIdx + inf];
        if (weight > 0) {
          Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);
          finalMatrix.addToSelf(tempMatrix);
        }
      }
    }
    transformFromFloatsToRef(data[index], data[index + 1], data[index + 2], finalMatrix, tempVector);
    tempVector.toArray(data, index);
  }
}
var _FacetDataStorage = class {
  constructor() {
    this.facetNb = 0;
    this.partitioningSubdivisions = 10;
    this.partitioningBBoxRatio = 1.01;
    this.facetDataEnabled = false;
    this.facetParameters = {};
    this.bbSize = Vector3.Zero();
    this.subDiv = {
      // actual number of subdivisions per axis for ComputeNormals()
      max: 1,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      X: 1,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      Y: 1,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      Z: 1
    };
    this.facetDepthSort = false;
    this.facetDepthSortEnabled = false;
  }
};
var _InternalAbstractMeshDataInfo = class {
  constructor() {
    this._hasVertexAlpha = false;
    this._useVertexColors = true;
    this._numBoneInfluencers = 4;
    this._applyFog = true;
    this._receiveShadows = false;
    this._facetData = new _FacetDataStorage();
    this._visibility = 1;
    this._skeleton = null;
    this._layerMask = 268435455;
    this._computeBonesUsingShaders = true;
    this._isActive = false;
    this._onlyForInstances = false;
    this._isActiveIntermediate = false;
    this._onlyForInstancesIntermediate = false;
    this._actAsRegularMesh = false;
    this._currentLOD = /* @__PURE__ */ new Map();
    this._collisionRetryCount = 3;
    this._morphTargetManager = null;
    this._renderingGroupId = 0;
    this._bakedVertexAnimationManager = null;
    this._material = null;
    this._positions = null;
    this._pointerOverDisableMeshTesting = false;
    this._meshCollisionData = new _MeshCollisionData();
    this._enableDistantPicking = false;
    this._rawBoundingInfo = null;
    this._sideOrientationHint = false;
    this._inheritVisibility = false;
  }
};
var AbstractMesh = class _AbstractMesh extends TransformNode {
  /**
   * No billboard
   */
  static get BILLBOARDMODE_NONE() {
    return TransformNode.BILLBOARDMODE_NONE;
  }
  /** Billboard on X axis */
  static get BILLBOARDMODE_X() {
    return TransformNode.BILLBOARDMODE_X;
  }
  /** Billboard on Y axis */
  static get BILLBOARDMODE_Y() {
    return TransformNode.BILLBOARDMODE_Y;
  }
  /** Billboard on Z axis */
  static get BILLBOARDMODE_Z() {
    return TransformNode.BILLBOARDMODE_Z;
  }
  /** Billboard on all axes */
  static get BILLBOARDMODE_ALL() {
    return TransformNode.BILLBOARDMODE_ALL;
  }
  /** Billboard on using position instead of orientation */
  static get BILLBOARDMODE_USE_POSITION() {
    return TransformNode.BILLBOARDMODE_USE_POSITION;
  }
  /**
   * Gets the number of facets in the mesh
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#what-is-a-mesh-facet
   */
  get facetNb() {
    return this._internalAbstractMeshDataInfo._facetData.facetNb;
  }
  /**
   * Gets or set the number (integer) of subdivisions per axis in the partitioning space
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#tweaking-the-partitioning
   */
  get partitioningSubdivisions() {
    return this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions;
  }
  set partitioningSubdivisions(nb) {
    this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions = nb;
  }
  /**
   * The ratio (float) to apply to the bounding box size to set to the partitioning space.
   * Ex : 1.01 (default) the partitioning space is 1% bigger than the bounding box
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#tweaking-the-partitioning
   */
  get partitioningBBoxRatio() {
    return this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio;
  }
  set partitioningBBoxRatio(ratio) {
    this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio = ratio;
  }
  /**
   * Gets or sets a boolean indicating that the facets must be depth sorted on next call to `updateFacetData()`.
   * Works only for updatable meshes.
   * Doesn't work with multi-materials
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#facet-depth-sort
   */
  get mustDepthSortFacets() {
    return this._internalAbstractMeshDataInfo._facetData.facetDepthSort;
  }
  set mustDepthSortFacets(sort) {
    this._internalAbstractMeshDataInfo._facetData.facetDepthSort = sort;
  }
  /**
   * The location (Vector3) where the facet depth sort must be computed from.
   * By default, the active camera position.
   * Used only when facet depth sort is enabled
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#facet-depth-sort
   */
  get facetDepthSortFrom() {
    return this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom;
  }
  set facetDepthSortFrom(location) {
    this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom = location;
  }
  /** number of collision detection tries. Change this value if not all collisions are detected and handled properly */
  get collisionRetryCount() {
    return this._internalAbstractMeshDataInfo._collisionRetryCount;
  }
  set collisionRetryCount(retryCount) {
    this._internalAbstractMeshDataInfo._collisionRetryCount = retryCount;
  }
  /**
   * gets a boolean indicating if facetData is enabled
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#what-is-a-mesh-facet
   */
  get isFacetDataEnabled() {
    return this._internalAbstractMeshDataInfo._facetData.facetDataEnabled;
  }
  /**
   * Gets or sets the morph target manager
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/morphTargets
   */
  get morphTargetManager() {
    return this._internalAbstractMeshDataInfo._morphTargetManager;
  }
  set morphTargetManager(value) {
    if (this._internalAbstractMeshDataInfo._morphTargetManager === value) {
      return;
    }
    this._internalAbstractMeshDataInfo._morphTargetManager = value;
    this._syncGeometryWithMorphTargetManager();
  }
  /**
   * Gets or sets the baked vertex animation manager
   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/baked_texture_animations
   */
  get bakedVertexAnimationManager() {
    return this._internalAbstractMeshDataInfo._bakedVertexAnimationManager;
  }
  set bakedVertexAnimationManager(value) {
    if (this._internalAbstractMeshDataInfo._bakedVertexAnimationManager === value) {
      return;
    }
    this._internalAbstractMeshDataInfo._bakedVertexAnimationManager = value;
    this._markSubMeshesAsAttributesDirty();
  }
  /** @internal */
  _syncGeometryWithMorphTargetManager() {
  }
  /**
   * @internal
   */
  _updateNonUniformScalingState(value) {
    if (!super._updateNonUniformScalingState(value)) {
      return false;
    }
    this._markSubMeshesAsMiscDirty();
    return true;
  }
  /** @internal */
  get rawBoundingInfo() {
    return this._internalAbstractMeshDataInfo._rawBoundingInfo;
  }
  set rawBoundingInfo(boundingInfo) {
    this._internalAbstractMeshDataInfo._rawBoundingInfo = boundingInfo;
  }
  /** Set a function to call when this mesh collides with another one */
  set onCollide(callback) {
    if (this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver) {
      this.onCollideObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver);
    }
    this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver = this.onCollideObservable.add(callback);
  }
  /** Set a function to call when the collision's position changes */
  set onCollisionPositionChange(callback) {
    if (this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver) {
      this.onCollisionPositionChangeObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver);
    }
    this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver = this.onCollisionPositionChangeObservable.add(callback);
  }
  /**
   * Gets or sets mesh visibility between 0 and 1 (default is 1)
   */
  get visibility() {
    return this._internalAbstractMeshDataInfo._visibility;
  }
  /**
   * Gets or sets mesh visibility between 0 and 1 (default is 1)
   */
  set visibility(value) {
    if (this._internalAbstractMeshDataInfo._visibility === value) {
      return;
    }
    const oldValue = this._internalAbstractMeshDataInfo._visibility;
    this._internalAbstractMeshDataInfo._visibility = value;
    if (oldValue === 1 && value !== 1 || oldValue !== 1 && value === 1) {
      this._markSubMeshesAsDirty((defines) => {
        defines.markAsMiscDirty();
        defines.markAsPrePassDirty();
      });
    }
  }
  /**
   * If set to true, a mesh will only be visible only if its parent(s) are also visible (default is false)
   */
  get inheritVisibility() {
    return this._internalAbstractMeshDataInfo._inheritVisibility;
  }
  set inheritVisibility(value) {
    this._internalAbstractMeshDataInfo._inheritVisibility = value;
  }
  /**
   * Gets or sets a boolean indicating if the mesh is visible (renderable). Default is true
   */
  get isVisible() {
    if (!this._isVisible || !this.inheritVisibility || !this._parentNode) {
      return this._isVisible;
    }
    if (this._isVisible) {
      let parent = this._parentNode;
      while (parent) {
        const parentVisible = parent.isVisible;
        if (typeof parentVisible !== "undefined") {
          return parentVisible;
        }
        parent = parent.parent;
      }
    }
    return this._isVisible;
  }
  set isVisible(value) {
    this._isVisible = value;
  }
  /**
   * Gets or sets the property which disables the test that is checking that the mesh under the pointer is the same than the previous time we tested for it (default: false).
   * Set this property to true if you want thin instances picking to be reported accurately when moving over the mesh.
   * Note that setting this property to true will incur some performance penalties when dealing with pointer events for this mesh so use it sparingly.
   */
  get pointerOverDisableMeshTesting() {
    return this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting;
  }
  set pointerOverDisableMeshTesting(disable) {
    this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting = disable;
  }
  /**
   * Specifies the rendering group id for this mesh (0 by default)
   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering#rendering-groups
   */
  get renderingGroupId() {
    return this._internalAbstractMeshDataInfo._renderingGroupId;
  }
  set renderingGroupId(value) {
    this._internalAbstractMeshDataInfo._renderingGroupId = value;
  }
  /** Gets or sets current material */
  get material() {
    return this._internalAbstractMeshDataInfo._material;
  }
  set material(value) {
    this._setMaterial(value);
  }
  /** @internal */
  _setMaterial(value) {
    if (this._internalAbstractMeshDataInfo._material === value) {
      return;
    }
    if (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap) {
      this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = void 0;
    }
    this._internalAbstractMeshDataInfo._material = value;
    if (value && value.meshMap) {
      value.meshMap[this.uniqueId] = this;
    }
    if (this.onMaterialChangedObservable.hasObservers()) {
      this.onMaterialChangedObservable.notifyObservers(this);
    }
    if (!this.subMeshes) {
      return;
    }
    this.resetDrawCache(void 0, value == null);
    this._unBindEffect();
  }
  /**
   * Gets the material used to render the mesh in a specific render pass
   * @param renderPassId render pass id
   * @returns material used for the render pass. If no specific material is used for this render pass, undefined is returned (meaning mesh.material is used for this pass)
   */
  getMaterialForRenderPass(renderPassId) {
    return this._internalAbstractMeshDataInfo._materialForRenderPass?.[renderPassId];
  }
  /**
   * Sets the material to be used to render the mesh in a specific render pass
   * @param renderPassId render pass id
   * @param material material to use for this render pass. If undefined is passed, no specific material will be used for this render pass but the regular material will be used instead (mesh.material)
   */
  setMaterialForRenderPass(renderPassId, material) {
    this.resetDrawCache(renderPassId);
    if (!this._internalAbstractMeshDataInfo._materialForRenderPass) {
      this._internalAbstractMeshDataInfo._materialForRenderPass = [];
    }
    const currentMaterial = this._internalAbstractMeshDataInfo._materialForRenderPass[renderPassId];
    if (currentMaterial?.meshMap?.[this.uniqueId]) {
      currentMaterial.meshMap[this.uniqueId] = void 0;
    }
    this._internalAbstractMeshDataInfo._materialForRenderPass[renderPassId] = material;
    if (material && material.meshMap) {
      material.meshMap[this.uniqueId] = this;
    }
  }
  /**
   * Gets or sets a boolean indicating that this mesh can receive realtime shadows
   * @see https://doc.babylonjs.com/features/featuresDeepDive/lights/shadows
   */
  get receiveShadows() {
    return this._internalAbstractMeshDataInfo._receiveShadows;
  }
  set receiveShadows(value) {
    if (this._internalAbstractMeshDataInfo._receiveShadows === value) {
      return;
    }
    this._internalAbstractMeshDataInfo._receiveShadows = value;
    this._markSubMeshesAsLightDirty();
  }
  /**
   * Gets or sets a boolean indicating that this mesh needs to use vertex alpha data to render.
   * This property is misnamed and should be `useVertexAlpha`. Note that the mesh will be rendered
   * with alpha blending when this flag is set even if vertex alpha data is missing from the geometry.
   */
  get hasVertexAlpha() {
    return this._internalAbstractMeshDataInfo._hasVertexAlpha;
  }
  set hasVertexAlpha(value) {
    if (this._internalAbstractMeshDataInfo._hasVertexAlpha === value) {
      return;
    }
    this._internalAbstractMeshDataInfo._hasVertexAlpha = value;
    this._markSubMeshesAsAttributesDirty();
    this._markSubMeshesAsMiscDirty();
  }
  /** Gets or sets a boolean indicating that this mesh needs to use vertex color data to render (if this kind of vertex data is available in the geometry) */
  get useVertexColors() {
    return this._internalAbstractMeshDataInfo._useVertexColors;
  }
  set useVertexColors(value) {
    if (this._internalAbstractMeshDataInfo._useVertexColors === value) {
      return;
    }
    this._internalAbstractMeshDataInfo._useVertexColors = value;
    this._markSubMeshesAsAttributesDirty();
  }
  /**
   * Gets or sets a boolean indicating that bone animations must be computed by the GPU (true by default)
   */
  get computeBonesUsingShaders() {
    return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;
  }
  set computeBonesUsingShaders(value) {
    if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {
      return;
    }
    this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;
    this._markSubMeshesAsAttributesDirty();
  }
  /** Gets or sets the number of allowed bone influences per vertex (4 by default) */
  get numBoneInfluencers() {
    return this._internalAbstractMeshDataInfo._numBoneInfluencers;
  }
  set numBoneInfluencers(value) {
    if (this._internalAbstractMeshDataInfo._numBoneInfluencers === value) {
      return;
    }
    this._internalAbstractMeshDataInfo._numBoneInfluencers = value;
    this._markSubMeshesAsAttributesDirty();
  }
  /** Gets or sets a boolean indicating that this mesh will allow fog to be rendered on it (true by default) */
  get applyFog() {
    return this._internalAbstractMeshDataInfo._applyFog;
  }
  set applyFog(value) {
    if (this._internalAbstractMeshDataInfo._applyFog === value) {
      return;
    }
    this._internalAbstractMeshDataInfo._applyFog = value;
    this._markSubMeshesAsMiscDirty();
  }
  /** When enabled, decompose picking matrices for better precision with large values for mesh position and scling */
  get enableDistantPicking() {
    return this._internalAbstractMeshDataInfo._enableDistantPicking;
  }
  set enableDistantPicking(value) {
    this._internalAbstractMeshDataInfo._enableDistantPicking = value;
  }
  /**
   * Gets or sets the current layer mask (default is 0x0FFFFFFF)
   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/layerMasksAndMultiCam
   */
  get layerMask() {
    return this._internalAbstractMeshDataInfo._layerMask;
  }
  set layerMask(value) {
    if (value === this._internalAbstractMeshDataInfo._layerMask) {
      return;
    }
    this._internalAbstractMeshDataInfo._layerMask = value;
    this._resyncLightSources();
  }
  /**
   * Gets or sets a collision mask used to mask collisions (default is -1).
   * A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0
   */
  get collisionMask() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask;
  }
  set collisionMask(mask) {
    this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask = !isNaN(mask) ? mask : -1;
  }
  /**
   * Gets or sets a collision response flag (default is true).
   * when collisionResponse is false, events are still triggered but colliding entity has no response
   * This helps creating trigger volume when user wants collision feedback events but not position/velocity
   * to respond to the collision.
   */
  get collisionResponse() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse;
  }
  set collisionResponse(response) {
    this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse = response;
  }
  /**
   * Gets or sets the current collision group mask (-1 by default).
   * A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0
   */
  get collisionGroup() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup;
  }
  set collisionGroup(mask) {
    this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup = !isNaN(mask) ? mask : -1;
  }
  /**
   * Gets or sets current surrounding meshes (null by default).
   *
   * By default collision detection is tested against every mesh in the scene.
   * It is possible to set surroundingMeshes to a defined list of meshes and then only these specified
   * meshes will be tested for the collision.
   *
   * Note: if set to an empty array no collision will happen when this mesh is moved.
   */
  get surroundingMeshes() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes;
  }
  set surroundingMeshes(meshes) {
    this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes = meshes;
  }
  /** Gets the list of lights affecting that mesh */
  get lightSources() {
    return this._lightSources;
  }
  /**
   * Gets or sets a skeleton to apply skinning transformations
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons
   */
  set skeleton(value) {
    const skeleton = this._internalAbstractMeshDataInfo._skeleton;
    if (skeleton && skeleton.needInitialSkinMatrix) {
      skeleton._unregisterMeshWithPoseMatrix(this);
    }
    if (value && value.needInitialSkinMatrix) {
      value._registerMeshWithPoseMatrix(this);
    }
    this._internalAbstractMeshDataInfo._skeleton = value;
    if (!this._internalAbstractMeshDataInfo._skeleton) {
      this._bonesTransformMatrices = null;
    }
    this._markSubMeshesAsAttributesDirty();
  }
  get skeleton() {
    return this._internalAbstractMeshDataInfo._skeleton;
  }
  // Constructor
  /**
   * Creates a new AbstractMesh
   * @param name defines the name of the mesh
   * @param scene defines the hosting scene
   */
  constructor(name3, scene = null) {
    super(name3, scene, false);
    this._internalAbstractMeshDataInfo = new _InternalAbstractMeshDataInfo();
    this._waitingMaterialId = null;
    this._waitingMorphTargetManagerId = null;
    this.cullingStrategy = _AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;
    this.onCollideObservable = new Observable();
    this.onCollisionPositionChangeObservable = new Observable();
    this.onMaterialChangedObservable = new Observable();
    this.definedFacingForward = true;
    this._occlusionQuery = null;
    this._renderingGroup = null;
    this.alphaIndex = Number.MAX_VALUE;
    this._isVisible = true;
    this.isPickable = true;
    this.isNearPickable = false;
    this.isNearGrabbable = false;
    this.showSubMeshesBoundingBox = false;
    this.isBlocker = false;
    this.enablePointerMoveEvents = false;
    this.outlineColor = Color3.Red();
    this.outlineWidth = 0.02;
    this.overlayColor = Color3.Red();
    this.overlayAlpha = 0.5;
    this.useOctreeForRenderingSelection = true;
    this.useOctreeForPicking = true;
    this.useOctreeForCollisions = true;
    this.alwaysSelectAsActiveMesh = false;
    this.doNotSyncBoundingInfo = false;
    this.actionManager = null;
    this.ellipsoid = new Vector3(0.5, 1, 0.5);
    this.ellipsoidOffset = new Vector3(0, 0, 0);
    this.edgesWidth = 1;
    this.edgesColor = new Color4(1, 0, 0, 1);
    this._edgesRenderer = null;
    this._masterMesh = null;
    this._boundingInfo = null;
    this._boundingInfoIsDirty = true;
    this._renderId = 0;
    this._intersectionsInProgress = new Array();
    this._unIndexed = false;
    this._lightSources = new Array();
    this._waitingData = {
      lods: null,
      actions: null,
      freezeWorldMatrix: null
    };
    this._bonesTransformMatrices = null;
    this._transformMatrixTexture = null;
    this.onRebuildObservable = new Observable();
    this._onCollisionPositionChange = (collisionId, newPosition, collidedMesh = null) => {
      newPosition.subtractToRef(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions);
      if (this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions.length() > AbstractEngine.CollisionsEpsilon) {
        this.position.addInPlace(this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions);
      }
      if (collidedMesh) {
        this.onCollideObservable.notifyObservers(collidedMesh);
      }
      this.onCollisionPositionChangeObservable.notifyObservers(this.position);
    };
    scene = this.getScene();
    scene.addMesh(this);
    this._resyncLightSources();
    this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), void 0, void 0, name3, !this.getScene().getEngine().isWebGPU);
    this._buildUniformLayout();
    switch (scene.performancePriority) {
      case 2:
        this.doNotSyncBoundingInfo = true;
      // eslint-disable-next-line no-fallthrough
      case 1:
        this.alwaysSelectAsActiveMesh = true;
        this.isPickable = false;
        break;
    }
  }
  _buildUniformLayout() {
    this._uniformBuffer.addUniform("world", 16);
    this._uniformBuffer.addUniform("visibility", 1);
    this._uniformBuffer.create();
  }
  /**
   * Transfer the mesh values to its UBO.
   * @param world The world matrix associated with the mesh
   */
  transferToEffect(world) {
    const ubo = this._uniformBuffer;
    ubo.updateMatrix("world", world);
    ubo.updateFloat("visibility", this._internalAbstractMeshDataInfo._visibility);
    ubo.update();
  }
  /**
   * Gets the mesh uniform buffer.
   * @returns the uniform buffer of the mesh.
   */
  getMeshUniformBuffer() {
    return this._uniformBuffer;
  }
  /**
   * Returns the string "AbstractMesh"
   * @returns "AbstractMesh"
   */
  getClassName() {
    return "AbstractMesh";
  }
  /**
   * Gets a string representation of the current mesh
   * @param fullDetails defines a boolean indicating if full details must be included
   * @returns a string representation of the current mesh
   */
  toString(fullDetails) {
    let ret = "Name: " + this.name + ", isInstance: " + (this.getClassName() !== "InstancedMesh" ? "YES" : "NO");
    ret += ", # of submeshes: " + (this.subMeshes ? this.subMeshes.length : 0);
    const skeleton = this._internalAbstractMeshDataInfo._skeleton;
    if (skeleton) {
      ret += ", skeleton: " + skeleton.name;
    }
    if (fullDetails) {
      ret += ", billboard mode: " + ["NONE", "X", "Y", null, "Z", null, null, "ALL"][this.billboardMode];
      ret += ", freeze wrld mat: " + (this._isWorldMatrixFrozen || this._waitingData.freezeWorldMatrix ? "YES" : "NO");
    }
    return ret;
  }
  /**
   * @internal
   */
  _getEffectiveParent() {
    if (this._masterMesh && this.billboardMode !== TransformNode.BILLBOARDMODE_NONE) {
      return this._masterMesh;
    }
    return super._getEffectiveParent();
  }
  /**
   * @internal
   */
  _getActionManagerForTrigger(trigger, initialCall = true) {
    if (this.actionManager && (initialCall || this.actionManager.isRecursive)) {
      if (trigger) {
        if (this.actionManager.hasSpecificTrigger(trigger)) {
          return this.actionManager;
        }
      } else {
        return this.actionManager;
      }
    }
    if (!this.parent) {
      return null;
    }
    return this.parent._getActionManagerForTrigger(trigger, false);
  }
  /**
   * @internal
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _rebuild(dispose = false) {
    this.onRebuildObservable.notifyObservers(this);
    if (this._occlusionQuery !== null) {
      this._occlusionQuery = null;
    }
    if (!this.subMeshes) {
      return;
    }
    for (const subMesh of this.subMeshes) {
      subMesh._rebuild();
    }
    this.resetDrawCache();
  }
  /** @internal */
  _resyncLightSources() {
    this._lightSources.length = 0;
    for (const light of this.getScene().lights) {
      if (!light.isEnabled()) {
        continue;
      }
      if (light.canAffectMesh(this)) {
        this._lightSources.push(light);
      }
    }
    this._markSubMeshesAsLightDirty();
  }
  /**
   * @internal
   */
  _resyncLightSource(light) {
    const isIn = light.isEnabled() && light.canAffectMesh(this);
    const index = this._lightSources.indexOf(light);
    let removed = false;
    if (index === -1) {
      if (!isIn) {
        return;
      }
      this._lightSources.push(light);
    } else {
      if (isIn) {
        return;
      }
      removed = true;
      this._lightSources.splice(index, 1);
    }
    this._markSubMeshesAsLightDirty(removed);
  }
  /** @internal */
  _unBindEffect() {
    for (const subMesh of this.subMeshes) {
      subMesh.setEffect(null);
    }
  }
  /**
   * @internal
   */
  _removeLightSource(light, dispose) {
    const index = this._lightSources.indexOf(light);
    if (index === -1) {
      return;
    }
    this._lightSources.splice(index, 1);
    this._markSubMeshesAsLightDirty(dispose);
  }
  _markSubMeshesAsDirty(func) {
    if (!this.subMeshes) {
      return;
    }
    for (const subMesh of this.subMeshes) {
      for (let i = 0; i < subMesh._drawWrappers.length; ++i) {
        const drawWrapper = subMesh._drawWrappers[i];
        if (!drawWrapper || !drawWrapper.defines || !drawWrapper.defines.markAllAsDirty) {
          continue;
        }
        func(drawWrapper.defines);
      }
    }
  }
  /**
   * @internal
   */
  _markSubMeshesAsLightDirty(dispose = false) {
    this._markSubMeshesAsDirty((defines) => defines.markAsLightDirty(dispose));
  }
  /** @internal */
  _markSubMeshesAsAttributesDirty() {
    this._markSubMeshesAsDirty((defines) => defines.markAsAttributesDirty());
  }
  /** @internal */
  _markSubMeshesAsMiscDirty() {
    this._markSubMeshesAsDirty((defines) => defines.markAsMiscDirty());
  }
  /**
   * Flag the AbstractMesh as dirty (Forcing it to update everything)
   * @param property if set to "rotation" the objects rotationQuaternion will be set to null
   * @returns this AbstractMesh
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  markAsDirty(property) {
    this._currentRenderId = Number.MAX_VALUE;
    super.markAsDirty(property);
    this._isDirty = true;
    return this;
  }
  /**
   * Resets the draw wrappers cache for all submeshes of this abstract mesh
   * @param passId If provided, releases only the draw wrapper corresponding to this render pass id
   * @param immediate If true, the effect will be released immediately, otherwise it will be released at the next frame
   */
  resetDrawCache(passId, immediate = false) {
    if (!this.subMeshes) {
      return;
    }
    for (const subMesh of this.subMeshes) {
      subMesh.resetDrawCache(passId, immediate);
    }
  }
  // Methods
  /**
   * Returns true if the mesh is blocked. Implemented by child classes
   */
  get isBlocked() {
    return false;
  }
  /**
   * Returns the mesh itself by default. Implemented by child classes
   * @param camera defines the camera to use to pick the right LOD level
   * @returns the currentAbstractMesh
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getLOD(camera) {
    return this;
  }
  /**
   * Returns 0 by default. Implemented by child classes
   * @returns an integer
   */
  getTotalVertices() {
    return 0;
  }
  /**
   * Returns a positive integer : the total number of indices in this mesh geometry.
   * @returns the number of indices or zero if the mesh has no geometry.
   */
  getTotalIndices() {
    return 0;
  }
  /**
   * Returns null by default. Implemented by child classes
   * @returns null
   */
  getIndices() {
    return null;
  }
  /**
   * Returns the array of the requested vertex data kind. Implemented by child classes
   * @param kind defines the vertex data kind to use
   * @returns null
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getVerticesData(kind) {
    return null;
  }
  /**
   * Sets the vertex data of the mesh geometry for the requested `kind`.
   * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.
   * Note that a new underlying VertexBuffer object is created each call.
   * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
   * @param kind defines vertex data kind:
   * * VertexBuffer.PositionKind
   * * VertexBuffer.UVKind
   * * VertexBuffer.UV2Kind
   * * VertexBuffer.UV3Kind
   * * VertexBuffer.UV4Kind
   * * VertexBuffer.UV5Kind
   * * VertexBuffer.UV6Kind
   * * VertexBuffer.ColorKind
   * * VertexBuffer.MatricesIndicesKind
   * * VertexBuffer.MatricesIndicesExtraKind
   * * VertexBuffer.MatricesWeightsKind
   * * VertexBuffer.MatricesWeightsExtraKind
   * @param data defines the data source
   * @param updatable defines if the data must be flagged as updatable (or static)
   * @param stride defines the vertex stride (size of an entire vertex). Can be null and in this case will be deduced from vertex data kind
   * @returns the current mesh
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  setVerticesData(kind, data, updatable, stride) {
    return this;
  }
  /**
   * Updates the existing vertex data of the mesh geometry for the requested `kind`.
   * If the mesh has no geometry, it is simply returned as it is.
   * @param kind defines vertex data kind:
   * * VertexBuffer.PositionKind
   * * VertexBuffer.UVKind
   * * VertexBuffer.UV2Kind
   * * VertexBuffer.UV3Kind
   * * VertexBuffer.UV4Kind
   * * VertexBuffer.UV5Kind
   * * VertexBuffer.UV6Kind
   * * VertexBuffer.ColorKind
   * * VertexBuffer.MatricesIndicesKind
   * * VertexBuffer.MatricesIndicesExtraKind
   * * VertexBuffer.MatricesWeightsKind
   * * VertexBuffer.MatricesWeightsExtraKind
   * @param data defines the data source
   * @param updateExtends If `kind` is `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed
   * @param makeItUnique If true, a new global geometry is created from this data and is set to the mesh
   * @returns the current mesh
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  updateVerticesData(kind, data, updateExtends, makeItUnique) {
    return this;
  }
  /**
   * Sets the mesh indices,
   * If the mesh has no geometry, a new Geometry object is created and set to the mesh.
   * @param indices Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array)
   * @param totalVertices Defines the total number of vertices
   * @returns the current mesh
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  setIndices(indices, totalVertices) {
    return this;
  }
  /**
   * Gets a boolean indicating if specific vertex data is present
   * @param kind defines the vertex data kind to use
   * @returns true is data kind is present
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  isVerticesDataPresent(kind) {
    return false;
  }
  /**
   * Returns the mesh BoundingInfo object or creates a new one and returns if it was undefined.
   * Note that it returns a shallow bounding of the mesh (i.e. it does not include children).
   * However, if the mesh contains thin instances, it will be expanded to include them. If you want the "raw" bounding data instead, then use `getRawBoundingInfo()`.
   * To get the full bounding of all children, call `getHierarchyBoundingVectors` instead.
   * @returns a BoundingInfo
   */
  getBoundingInfo() {
    if (this._masterMesh) {
      return this._masterMesh.getBoundingInfo();
    }
    if (this._boundingInfoIsDirty) {
      this._boundingInfoIsDirty = false;
      this._updateBoundingInfo();
    }
    return this._boundingInfo;
  }
  /**
   * Returns the bounding info unnafected by instance data.
   * @returns the bounding info of the mesh unaffected by instance data.
   */
  getRawBoundingInfo() {
    return this.rawBoundingInfo ?? this.getBoundingInfo();
  }
  /**
   * Overwrite the current bounding info
   * @param boundingInfo defines the new bounding info
   * @returns the current mesh
   */
  setBoundingInfo(boundingInfo) {
    this._boundingInfo = boundingInfo;
    return this;
  }
  /**
   * Returns true if there is already a bounding info
   */
  get hasBoundingInfo() {
    return this._boundingInfo !== null;
  }
  /**
   * Creates a new bounding info for the mesh
   * @param minimum min vector of the bounding box/sphere
   * @param maximum max vector of the bounding box/sphere
   * @param worldMatrix defines the new world matrix
   * @returns the new bounding info
   */
  buildBoundingInfo(minimum, maximum, worldMatrix) {
    this._boundingInfo = new BoundingInfo(minimum, maximum, worldMatrix);
    return this._boundingInfo;
  }
  /**
   * Uniformly scales the mesh to fit inside of a unit cube (1 X 1 X 1 units)
   * @param includeDescendants Use the hierarchy's bounding box instead of the mesh's bounding box. Default is false
   * @param ignoreRotation ignore rotation when computing the scale (ie. object will be axis aligned). Default is false
   * @param predicate predicate that is passed in to getHierarchyBoundingVectors when selecting which object should be included when scaling
   * @returns the current mesh
   */
  normalizeToUnitCube(includeDescendants = true, ignoreRotation = false, predicate) {
    return super.normalizeToUnitCube(includeDescendants, ignoreRotation, predicate);
  }
  /** Gets a boolean indicating if this mesh has skinning data and an attached skeleton */
  get useBones() {
    return this.skeleton && this.getScene().skeletonsEnabled && this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind) && this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind);
  }
  /** @internal */
  _preActivate() {
  }
  /**
   * @internal
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _preActivateForIntermediateRendering(renderId) {
  }
  /**
   * @internal
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _activate(renderId, intermediateRendering) {
    this._renderId = renderId;
    return true;
  }
  /** @internal */
  _postActivate() {
  }
  /** @internal */
  _freeze() {
  }
  /** @internal */
  _unFreeze() {
  }
  /**
   * Gets the current world matrix
   * @returns a Matrix
   */
  getWorldMatrix() {
    if (this._masterMesh && this.billboardMode === TransformNode.BILLBOARDMODE_NONE) {
      return this._masterMesh.getWorldMatrix();
    }
    return super.getWorldMatrix();
  }
  /** @internal */
  _getWorldMatrixDeterminant() {
    if (this._masterMesh) {
      return this._masterMesh._getWorldMatrixDeterminant();
    }
    return super._getWorldMatrixDeterminant();
  }
  /**
   * Gets a boolean indicating if this mesh is an instance or a regular mesh
   */
  get isAnInstance() {
    return false;
  }
  /**
   * Gets a boolean indicating if this mesh has instances
   */
  get hasInstances() {
    return false;
  }
  /**
   * Gets a boolean indicating if this mesh has thin instances
   */
  get hasThinInstances() {
    return false;
  }
  // ================================== Point of View Movement =================================
  /**
   * Perform relative position change from the point of view of behind the front of the mesh.
   * This is performed taking into account the meshes current rotation, so you do not have to care.
   * Supports definition of mesh facing forward or backward {@link definedFacingForwardSearch | See definedFacingForwardSearch }.
   * @param amountRight defines the distance on the right axis
   * @param amountUp defines the distance on the up axis
   * @param amountForward defines the distance on the forward axis
   * @returns the current mesh
   */
  movePOV(amountRight, amountUp, amountForward) {
    this.position.addInPlace(this.calcMovePOV(amountRight, amountUp, amountForward));
    return this;
  }
  /**
   * Calculate relative position change from the point of view of behind the front of the mesh.
   * This is performed taking into account the meshes current rotation, so you do not have to care.
   * Supports definition of mesh facing forward or backward {@link definedFacingForwardSearch | See definedFacingForwardSearch }.
   * @param amountRight defines the distance on the right axis
   * @param amountUp defines the distance on the up axis
   * @param amountForward defines the distance on the forward axis
   * @returns the new displacement vector
   */
  calcMovePOV(amountRight, amountUp, amountForward) {
    const rotMatrix = new Matrix();
    const rotQuaternion = this.rotationQuaternion ? this.rotationQuaternion : Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);
    rotQuaternion.toRotationMatrix(rotMatrix);
    const translationDelta = Vector3.Zero();
    const defForwardMult = this.definedFacingForward ? -1 : 1;
    Vector3.TransformCoordinatesFromFloatsToRef(amountRight * defForwardMult, amountUp, amountForward * defForwardMult, rotMatrix, translationDelta);
    return translationDelta;
  }
  // ================================== Point of View Rotation =================================
  /**
   * Perform relative rotation change from the point of view of behind the front of the mesh.
   * Supports definition of mesh facing forward or backward {@link definedFacingForwardSearch | See definedFacingForwardSearch }.
   * @param flipBack defines the flip
   * @param twirlClockwise defines the twirl
   * @param tiltRight defines the tilt
   * @returns the current mesh
   */
  rotatePOV(flipBack, twirlClockwise, tiltRight) {
    this.rotation.addInPlace(this.calcRotatePOV(flipBack, twirlClockwise, tiltRight));
    return this;
  }
  /**
   * Calculate relative rotation change from the point of view of behind the front of the mesh.
   * Supports definition of mesh facing forward or backward {@link definedFacingForwardSearch | See definedFacingForwardSearch }.
   * @param flipBack defines the flip
   * @param twirlClockwise defines the twirl
   * @param tiltRight defines the tilt
   * @returns the new rotation vector
   */
  calcRotatePOV(flipBack, twirlClockwise, tiltRight) {
    const defForwardMult = this.definedFacingForward ? 1 : -1;
    return new Vector3(flipBack * defForwardMult, twirlClockwise, tiltRight * defForwardMult);
  }
  /**
   * @internal
   */
  _refreshBoundingInfo(data, bias) {
    if (data) {
      const extend = extractMinAndMax(data, 0, this.getTotalVertices(), bias);
      if (this._boundingInfo) {
        this._boundingInfo.reConstruct(extend.minimum, extend.maximum);
      } else {
        this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);
      }
    }
    if (this.subMeshes) {
      for (let index = 0; index < this.subMeshes.length; index++) {
        this.subMeshes[index].refreshBoundingInfo(data);
      }
    }
    this._updateBoundingInfo();
  }
  /**
   * @internal
   */
  _refreshBoundingInfoDirect(extend) {
    if (this._boundingInfo) {
      this._boundingInfo.reConstruct(extend.minimum, extend.maximum);
    } else {
      this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);
    }
    if (this.subMeshes) {
      for (let index = 0; index < this.subMeshes.length; index++) {
        this.subMeshes[index].refreshBoundingInfo(null);
      }
    }
    this._updateBoundingInfo();
  }
  // This function is only here so we can apply the nativeOverride decorator.
  static _ApplySkeleton(data, kind, skeletonMatrices, matricesIndicesData, matricesWeightsData, matricesIndicesExtraData, matricesWeightsExtraData) {
    applySkeleton(data, kind, skeletonMatrices, matricesIndicesData, matricesWeightsData, matricesIndicesExtraData, matricesWeightsExtraData);
  }
  /** @internal */
  _getData(options, data, kind = VertexBuffer.PositionKind) {
    const cache = options.cache;
    const getVertexData = (kind2) => {
      if (cache) {
        const vertexData = cache._vertexData || (cache._vertexData = {});
        if (!vertexData[kind2]) {
          this.copyVerticesData(kind2, vertexData);
        }
        return vertexData[kind2];
      }
      return this.getVerticesData(kind2);
    };
    data || (data = getVertexData(kind));
    if (!data) {
      return null;
    }
    if (cache) {
      if (cache._outputData) {
        cache._outputData.set(data);
      } else {
        cache._outputData = new Float32Array(data);
      }
      data = cache._outputData;
    } else if (options.applyMorph && this.morphTargetManager || options.applySkeleton && this.skeleton) {
      data = data.slice();
    }
    if (options.applyMorph && this.morphTargetManager) {
      applyMorph(data, kind, this.morphTargetManager);
    }
    if (options.applySkeleton && this.skeleton) {
      const matricesIndicesData = getVertexData(VertexBuffer.MatricesIndicesKind);
      const matricesWeightsData = getVertexData(VertexBuffer.MatricesWeightsKind);
      if (matricesWeightsData && matricesIndicesData) {
        const needExtras = this.numBoneInfluencers > 4;
        const matricesIndicesExtraData = needExtras ? getVertexData(VertexBuffer.MatricesIndicesExtraKind) : null;
        const matricesWeightsExtraData = needExtras ? getVertexData(VertexBuffer.MatricesWeightsExtraKind) : null;
        const skeletonMatrices = this.skeleton.getTransformMatrices(this);
        _AbstractMesh._ApplySkeleton(data, kind, skeletonMatrices, matricesIndicesData, matricesWeightsData, matricesIndicesExtraData, matricesWeightsExtraData);
      }
    }
    if (options.updatePositionsArray !== false && kind === VertexBuffer.PositionKind) {
      const positions = this._internalAbstractMeshDataInfo._positions || [];
      const previousLength = positions.length;
      positions.length = data.length / 3;
      if (previousLength < positions.length) {
        for (let positionIndex = previousLength; positionIndex < positions.length; positionIndex++) {
          positions[positionIndex] = new Vector3();
        }
      }
      for (let positionIndex = 0, dataIndex = 0; positionIndex < positions.length; positionIndex++, dataIndex += 3) {
        positions[positionIndex].copyFromFloats(data[dataIndex], data[dataIndex + 1], data[dataIndex + 2]);
      }
      this._internalAbstractMeshDataInfo._positions = positions;
    }
    return data;
  }
  /**
   * Get the normals vertex data and optionally apply skeleton and morphing.
   * @param applySkeleton defines whether to apply the skeleton
   * @param applyMorph  defines whether to apply the morph target
   * @returns the normals data
   */
  getNormalsData(applySkeleton2 = false, applyMorph2 = false) {
    return this._getData({ applySkeleton: applySkeleton2, applyMorph: applyMorph2, updatePositionsArray: false }, null, VertexBuffer.NormalKind);
  }
  /**
   * Get the position vertex data and optionally apply skeleton and morphing.
   * @param applySkeleton defines whether to apply the skeleton
   * @param applyMorph  defines whether to apply the morph target
   * @param data defines the position data to apply the skeleton and morph to
   * @returns the position data
   */
  getPositionData(applySkeleton2 = false, applyMorph2 = false, data = null) {
    return this._getData({ applySkeleton: applySkeleton2, applyMorph: applyMorph2, updatePositionsArray: false }, data, VertexBuffer.PositionKind);
  }
  /** @internal */
  _updateBoundingInfo() {
    if (this._boundingInfo) {
      this._boundingInfo.update(this.worldMatrixFromCache);
    } else {
      this._boundingInfo = new BoundingInfo(Vector3.Zero(), Vector3.Zero(), this.worldMatrixFromCache);
    }
    this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);
    return this;
  }
  /**
   * @internal
   */
  _updateSubMeshesBoundingInfo(matrix) {
    if (!this.subMeshes) {
      return this;
    }
    const count = this.subMeshes.length;
    for (let subIndex = 0; subIndex < count; subIndex++) {
      const subMesh = this.subMeshes[subIndex];
      if (count > 1 || !subMesh.IsGlobal) {
        subMesh.updateBoundingInfo(matrix);
      }
    }
    return this;
  }
  /** @internal */
  _afterComputeWorldMatrix() {
    if (this.doNotSyncBoundingInfo) {
      return;
    }
    this._boundingInfoIsDirty = true;
  }
  /**
   * Returns `true` if the mesh is within the frustum defined by the passed array of planes.
   * A mesh is in the frustum if its bounding box intersects the frustum
   * @param frustumPlanes defines the frustum to test
   * @returns true if the mesh is in the frustum planes
   */
  isInFrustum(frustumPlanes) {
    return this.getBoundingInfo().isInFrustum(frustumPlanes, this.cullingStrategy);
  }
  /**
   * Returns `true` if the mesh is completely in the frustum defined be the passed array of planes.
   * A mesh is completely in the frustum if its bounding box it completely inside the frustum.
   * @param frustumPlanes defines the frustum to test
   * @returns true if the mesh is completely in the frustum planes
   */
  isCompletelyInFrustum(frustumPlanes) {
    return this.getBoundingInfo().isCompletelyInFrustum(frustumPlanes);
  }
  /**
   * True if the mesh intersects another mesh or a SolidParticle object
   * @param mesh defines a target mesh or SolidParticle to test
   * @param precise Unless the parameter `precise` is set to `true` the intersection is computed according to Axis Aligned Bounding Boxes (AABB), else according to OBB (Oriented BBoxes)
   * @param includeDescendants Can be set to true to test if the mesh defined in parameters intersects with the current mesh or any child meshes
   * @returns true if there is an intersection
   */
  intersectsMesh(mesh, precise = false, includeDescendants) {
    const boundingInfo = this.getBoundingInfo();
    const otherBoundingInfo = mesh.getBoundingInfo();
    if (boundingInfo.intersects(otherBoundingInfo, precise)) {
      return true;
    }
    if (includeDescendants) {
      for (const child of this.getChildMeshes()) {
        if (child.intersectsMesh(mesh, precise, true)) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Returns true if the passed point (Vector3) is inside the mesh bounding box
   * @param point defines the point to test
   * @returns true if there is an intersection
   */
  intersectsPoint(point) {
    return this.getBoundingInfo().intersectsPoint(point);
  }
  // Collisions
  /**
   * Gets or sets a boolean indicating that this mesh can be used in the collision engine
   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions
   */
  get checkCollisions() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions;
  }
  set checkCollisions(collisionEnabled) {
    this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions = collisionEnabled;
  }
  /**
   * Gets Collider object used to compute collisions (not physics)
   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions
   */
  get collider() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._collider;
  }
  /**
   * Move the mesh using collision engine
   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions
   * @param displacement defines the requested displacement vector
   * @returns the current mesh
   */
  moveWithCollisions(displacement) {
    const globalPosition = this.getAbsolutePosition();
    globalPosition.addToRef(this.ellipsoidOffset, this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions);
    const coordinator = this.getScene().collisionCoordinator;
    if (!this._internalAbstractMeshDataInfo._meshCollisionData._collider) {
      this._internalAbstractMeshDataInfo._meshCollisionData._collider = coordinator.createCollider();
    }
    this._internalAbstractMeshDataInfo._meshCollisionData._collider._radius = this.ellipsoid;
    coordinator.getNewPosition(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, displacement, this._internalAbstractMeshDataInfo._meshCollisionData._collider, this.collisionRetryCount, this, this._onCollisionPositionChange, this.uniqueId);
    return this;
  }
  // Collisions
  /**
   * @internal
   */
  _collideForSubMesh(subMesh, transformMatrix, collider) {
    this._generatePointsArray();
    if (!this._positions) {
      return this;
    }
    if (!subMesh._lastColliderWorldVertices || !subMesh._lastColliderTransformMatrix.equals(transformMatrix)) {
      subMesh._lastColliderTransformMatrix = transformMatrix.clone();
      subMesh._lastColliderWorldVertices = [];
      subMesh._trianglePlanes = [];
      const start = subMesh.verticesStart;
      const end = subMesh.verticesStart + subMesh.verticesCount;
      for (let i = start; i < end; i++) {
        subMesh._lastColliderWorldVertices.push(Vector3.TransformCoordinates(this._positions[i], transformMatrix));
      }
    }
    collider._collide(subMesh._trianglePlanes, subMesh._lastColliderWorldVertices, this.getIndices(), subMesh.indexStart, subMesh.indexStart + subMesh.indexCount, subMesh.verticesStart, !!subMesh.getMaterial(), this, this._shouldConvertRHS(), subMesh.getMaterial()?.fillMode === 7);
    return this;
  }
  /**
   * @internal
   */
  _processCollisionsForSubMeshes(collider, transformMatrix) {
    const subMeshes = this._scene.getCollidingSubMeshCandidates(this, collider);
    const len = subMeshes.length;
    for (let index = 0; index < len; index++) {
      const subMesh = subMeshes.data[index];
      if (len > 1 && !subMesh._checkCollision(collider)) {
        continue;
      }
      this._collideForSubMesh(subMesh, transformMatrix, collider);
    }
    return this;
  }
  /** @internal */
  _shouldConvertRHS() {
    return false;
  }
  /**
   * @internal
   */
  _checkCollision(collider) {
    if (!this.getBoundingInfo()._checkCollision(collider)) {
      return this;
    }
    const collisionsScalingMatrix = TmpVectors.Matrix[0];
    const collisionsTransformMatrix = TmpVectors.Matrix[1];
    Matrix.ScalingToRef(1 / collider._radius.x, 1 / collider._radius.y, 1 / collider._radius.z, collisionsScalingMatrix);
    this.worldMatrixFromCache.multiplyToRef(collisionsScalingMatrix, collisionsTransformMatrix);
    this._processCollisionsForSubMeshes(collider, collisionsTransformMatrix);
    return this;
  }
  // Picking
  /** @internal */
  _generatePointsArray() {
    return false;
  }
  /**
   * Checks if the passed Ray intersects with the mesh. A mesh triangle can be picked both from its front and back sides,
   * irrespective of orientation.
   * @param ray defines the ray to use. It should be in the mesh's LOCAL coordinate space.
   * @param fastCheck defines if fast mode (but less precise) must be used (false by default)
   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
   * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)
   * @param worldToUse defines the world matrix to use to get the world coordinate of the intersection point
   * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check
   * @returns the picking info
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect
   */
  intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo = false, worldToUse, skipBoundingInfo = false) {
    const pickingInfo = new PickingInfo();
    const className = this.getClassName();
    const intersectionThreshold = className === "InstancedLinesMesh" || className === "LinesMesh" || className === "GreasedLineMesh" ? this.intersectionThreshold : 0;
    const boundingInfo = this.getBoundingInfo();
    if (!this.subMeshes) {
      return pickingInfo;
    }
    if (!skipBoundingInfo && (!ray.intersectsSphere(boundingInfo.boundingSphere, intersectionThreshold) || !ray.intersectsBox(boundingInfo.boundingBox, intersectionThreshold))) {
      return pickingInfo;
    }
    if (onlyBoundingInfo) {
      pickingInfo.hit = skipBoundingInfo ? false : true;
      pickingInfo.pickedMesh = skipBoundingInfo ? null : this;
      pickingInfo.distance = skipBoundingInfo ? 0 : Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);
      pickingInfo.subMeshId = 0;
      return pickingInfo;
    }
    if (!this._generatePointsArray()) {
      return pickingInfo;
    }
    let intersectInfo = null;
    const subMeshes = this._scene.getIntersectingSubMeshCandidates(this, ray);
    const len = subMeshes.length;
    let anySubmeshSupportIntersect = false;
    for (let index = 0; index < len; index++) {
      const subMesh = subMeshes.data[index];
      const material = subMesh.getMaterial();
      if (!material) {
        continue;
      }
      if (material.fillMode == 7 || material.fillMode == 0 || material.fillMode == 1 || material.fillMode == 2 || material.fillMode == 4) {
        anySubmeshSupportIntersect = true;
        break;
      }
    }
    if (!anySubmeshSupportIntersect) {
      pickingInfo.hit = true;
      pickingInfo.pickedMesh = this;
      pickingInfo.distance = Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);
      pickingInfo.subMeshId = -1;
      return pickingInfo;
    }
    for (let index = 0; index < len; index++) {
      const subMesh = subMeshes.data[index];
      if (len > 1 && !skipBoundingInfo && !subMesh.canIntersects(ray)) {
        continue;
      }
      const currentIntersectInfo = subMesh.intersects(ray, this._positions, this.getIndices(), fastCheck, trianglePredicate);
      if (currentIntersectInfo) {
        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {
          intersectInfo = currentIntersectInfo;
          intersectInfo.subMeshId = index;
          if (fastCheck) {
            break;
          }
        }
      }
    }
    if (intersectInfo) {
      const world = worldToUse ?? this.getWorldMatrix();
      const worldOrigin = TmpVectors.Vector3[0];
      const direction = TmpVectors.Vector3[1];
      Vector3.TransformCoordinatesToRef(ray.origin, world, worldOrigin);
      ray.direction.scaleToRef(intersectInfo.distance, direction);
      const worldDirection = Vector3.TransformNormal(direction, world);
      const pickedPoint = worldDirection.addInPlace(worldOrigin);
      pickingInfo.hit = true;
      pickingInfo.distance = Vector3.Distance(worldOrigin, pickedPoint);
      pickingInfo.pickedPoint = pickedPoint;
      pickingInfo.pickedMesh = this;
      pickingInfo.bu = intersectInfo.bu || 0;
      pickingInfo.bv = intersectInfo.bv || 0;
      pickingInfo.subMeshFaceId = intersectInfo.faceId;
      pickingInfo.faceId = intersectInfo.faceId + subMeshes.data[intersectInfo.subMeshId].indexStart / (this.getClassName().indexOf("LinesMesh") !== -1 ? 2 : 3);
      pickingInfo.subMeshId = intersectInfo.subMeshId;
      return pickingInfo;
    }
    return pickingInfo;
  }
  /**
   * Clones the current mesh
   * @param name defines the mesh name
   * @param newParent defines the new mesh parent
   * @param doNotCloneChildren defines a boolean indicating that children must not be cloned (false by default)
   * @returns the new mesh
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  clone(name3, newParent, doNotCloneChildren) {
    return null;
  }
  /**
   * Disposes all the submeshes of the current mesh
   * @param immediate should dispose the effects immediately or not
   * @returns the current mesh
   */
  releaseSubMeshes(immediate = false) {
    if (this.subMeshes) {
      while (this.subMeshes.length) {
        this.subMeshes[0].dispose(immediate);
      }
    } else {
      this.subMeshes = [];
    }
    return this;
  }
  /**
   * Releases resources associated with this abstract mesh.
   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
   */
  dispose(doNotRecurse, disposeMaterialAndTextures = false) {
    let index;
    const scene = this.getScene();
    if (this._scene.useMaterialMeshMap) {
      if (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap) {
        this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = void 0;
      }
    }
    scene.freeActiveMeshes();
    scene.freeRenderingGroups();
    if (scene.renderingManager.maintainStateBetweenFrames) {
      scene.renderingManager.restoreDispachedFlags();
    }
    if (this.actionManager !== void 0 && this.actionManager !== null) {
      if (this.actionManager.disposeWhenUnowned && !this._scene.meshes.some((m) => m !== this && m.actionManager === this.actionManager)) {
        this.actionManager.dispose();
      }
      this.actionManager = null;
    }
    this._internalAbstractMeshDataInfo._skeleton = null;
    if (this._transformMatrixTexture) {
      this._transformMatrixTexture.dispose();
      this._transformMatrixTexture = null;
    }
    for (index = 0; index < this._intersectionsInProgress.length; index++) {
      const other = this._intersectionsInProgress[index];
      const pos = other._intersectionsInProgress.indexOf(this);
      other._intersectionsInProgress.splice(pos, 1);
    }
    this._intersectionsInProgress.length = 0;
    const lights = scene.lights;
    lights.forEach((light) => {
      let meshIndex = light.includedOnlyMeshes.indexOf(this);
      if (meshIndex !== -1) {
        light.includedOnlyMeshes.splice(meshIndex, 1);
      }
      meshIndex = light.excludedMeshes.indexOf(this);
      if (meshIndex !== -1) {
        light.excludedMeshes.splice(meshIndex, 1);
      }
      const generators = light.getShadowGenerators();
      if (generators) {
        const iterator = generators.values();
        for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
          const generator = key.value;
          const shadowMap = generator.getShadowMap();
          if (shadowMap && shadowMap.renderList) {
            meshIndex = shadowMap.renderList.indexOf(this);
            if (meshIndex !== -1) {
              shadowMap.renderList.splice(meshIndex, 1);
            }
          }
        }
      }
    });
    if (this.getClassName() !== "InstancedMesh" || this.getClassName() !== "InstancedLinesMesh") {
      this.releaseSubMeshes(true);
    }
    const engine = scene.getEngine();
    if (this._occlusionQuery !== null) {
      this.isOcclusionQueryInProgress = false;
      engine.deleteQuery(this._occlusionQuery);
      this._occlusionQuery = null;
    }
    engine.wipeCaches();
    scene.removeMesh(this);
    if (this._parentContainer) {
      const index2 = this._parentContainer.meshes.indexOf(this);
      if (index2 > -1) {
        this._parentContainer.meshes.splice(index2, 1);
      }
      this._parentContainer = null;
    }
    if (disposeMaterialAndTextures) {
      if (this.material) {
        if (this.material.getClassName() === "MultiMaterial") {
          this.material.dispose(false, true, true);
        } else {
          this.material.dispose(false, true);
        }
      }
    }
    if (!doNotRecurse) {
      for (index = 0; index < scene.particleSystems.length; index++) {
        if (scene.particleSystems[index].emitter === this) {
          scene.particleSystems[index].dispose();
          index--;
        }
      }
    }
    if (this._internalAbstractMeshDataInfo._facetData.facetDataEnabled) {
      this.disableFacetData();
    }
    this._uniformBuffer.dispose();
    this.onAfterWorldMatrixUpdateObservable.clear();
    this.onCollideObservable.clear();
    this.onCollisionPositionChangeObservable.clear();
    this.onRebuildObservable.clear();
    super.dispose(doNotRecurse, disposeMaterialAndTextures);
  }
  // Facet data
  /** @internal */
  _initFacetData() {
    const data = this._internalAbstractMeshDataInfo._facetData;
    if (!data.facetNormals) {
      data.facetNormals = [];
    }
    if (!data.facetPositions) {
      data.facetPositions = [];
    }
    if (!data.facetPartitioning) {
      data.facetPartitioning = new Array();
    }
    data.facetNb = this.getIndices().length / 3 | 0;
    data.partitioningSubdivisions = data.partitioningSubdivisions ? data.partitioningSubdivisions : 10;
    data.partitioningBBoxRatio = data.partitioningBBoxRatio ? data.partitioningBBoxRatio : 1.01;
    for (let f = 0; f < data.facetNb; f++) {
      data.facetNormals[f] = Vector3.Zero();
      data.facetPositions[f] = Vector3.Zero();
    }
    data.facetDataEnabled = true;
    return this;
  }
  /**
   * Updates the mesh facetData arrays and the internal partitioning when the mesh is morphed or updated.
   * This method can be called within the render loop.
   * You don't need to call this method by yourself in the render loop when you update/morph a mesh with the methods CreateXXX() as they automatically manage this computation
   * @returns the current mesh
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData
   */
  updateFacetData() {
    const data = this._internalAbstractMeshDataInfo._facetData;
    if (!data.facetDataEnabled) {
      this._initFacetData();
    }
    const positions = this.getVerticesData(VertexBuffer.PositionKind);
    const indices = this.getIndices();
    const normals = this.getVerticesData(VertexBuffer.NormalKind);
    const bInfo = this.getBoundingInfo();
    if (data.facetDepthSort && !data.facetDepthSortEnabled) {
      data.facetDepthSortEnabled = true;
      if (indices instanceof Uint16Array) {
        data.depthSortedIndices = new Uint16Array(indices);
      } else if (indices instanceof Uint32Array) {
        data.depthSortedIndices = new Uint32Array(indices);
      } else {
        let needs32bits = false;
        for (let i = 0; i < indices.length; i++) {
          if (indices[i] > 65535) {
            needs32bits = true;
            break;
          }
        }
        if (needs32bits) {
          data.depthSortedIndices = new Uint32Array(indices);
        } else {
          data.depthSortedIndices = new Uint16Array(indices);
        }
      }
      data.facetDepthSortFunction = function(f1, f2) {
        return f2.sqDistance - f1.sqDistance;
      };
      if (!data.facetDepthSortFrom) {
        const camera = this.getScene().activeCamera;
        data.facetDepthSortFrom = camera ? camera.position : Vector3.Zero();
      }
      data.depthSortedFacets = [];
      for (let f = 0; f < data.facetNb; f++) {
        const depthSortedFacet = { ind: f * 3, sqDistance: 0 };
        data.depthSortedFacets.push(depthSortedFacet);
      }
      data.invertedMatrix = Matrix.Identity();
      data.facetDepthSortOrigin = Vector3.Zero();
    }
    data.bbSize.x = bInfo.maximum.x - bInfo.minimum.x > Epsilon ? bInfo.maximum.x - bInfo.minimum.x : Epsilon;
    data.bbSize.y = bInfo.maximum.y - bInfo.minimum.y > Epsilon ? bInfo.maximum.y - bInfo.minimum.y : Epsilon;
    data.bbSize.z = bInfo.maximum.z - bInfo.minimum.z > Epsilon ? bInfo.maximum.z - bInfo.minimum.z : Epsilon;
    let bbSizeMax = data.bbSize.x > data.bbSize.y ? data.bbSize.x : data.bbSize.y;
    bbSizeMax = bbSizeMax > data.bbSize.z ? bbSizeMax : data.bbSize.z;
    data.subDiv.max = data.partitioningSubdivisions;
    data.subDiv.X = Math.floor(data.subDiv.max * data.bbSize.x / bbSizeMax);
    data.subDiv.Y = Math.floor(data.subDiv.max * data.bbSize.y / bbSizeMax);
    data.subDiv.Z = Math.floor(data.subDiv.max * data.bbSize.z / bbSizeMax);
    data.subDiv.X = data.subDiv.X < 1 ? 1 : data.subDiv.X;
    data.subDiv.Y = data.subDiv.Y < 1 ? 1 : data.subDiv.Y;
    data.subDiv.Z = data.subDiv.Z < 1 ? 1 : data.subDiv.Z;
    data.facetParameters.facetNormals = this.getFacetLocalNormals();
    data.facetParameters.facetPositions = this.getFacetLocalPositions();
    data.facetParameters.facetPartitioning = this.getFacetLocalPartitioning();
    data.facetParameters.bInfo = bInfo;
    data.facetParameters.bbSize = data.bbSize;
    data.facetParameters.subDiv = data.subDiv;
    data.facetParameters.ratio = this.partitioningBBoxRatio;
    data.facetParameters.depthSort = data.facetDepthSort;
    if (data.facetDepthSort && data.facetDepthSortEnabled) {
      this.computeWorldMatrix(true);
      this._worldMatrix.invertToRef(data.invertedMatrix);
      Vector3.TransformCoordinatesToRef(data.facetDepthSortFrom, data.invertedMatrix, data.facetDepthSortOrigin);
      data.facetParameters.distanceTo = data.facetDepthSortOrigin;
    }
    data.facetParameters.depthSortedFacets = data.depthSortedFacets;
    if (normals) {
      VertexData.ComputeNormals(positions, indices, normals, data.facetParameters);
    }
    if (data.facetDepthSort && data.facetDepthSortEnabled) {
      data.depthSortedFacets.sort(data.facetDepthSortFunction);
      const l = data.depthSortedIndices.length / 3 | 0;
      for (let f = 0; f < l; f++) {
        const sind = data.depthSortedFacets[f].ind;
        data.depthSortedIndices[f * 3] = indices[sind];
        data.depthSortedIndices[f * 3 + 1] = indices[sind + 1];
        data.depthSortedIndices[f * 3 + 2] = indices[sind + 2];
      }
      this.updateIndices(data.depthSortedIndices, void 0, true);
    }
    return this;
  }
  /**
   * Returns the facetLocalNormals array.
   * The normals are expressed in the mesh local spac
   * @returns an array of Vector3
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData
   */
  getFacetLocalNormals() {
    const facetData = this._internalAbstractMeshDataInfo._facetData;
    if (!facetData.facetNormals) {
      this.updateFacetData();
    }
    return facetData.facetNormals;
  }
  /**
   * Returns the facetLocalPositions array.
   * The facet positions are expressed in the mesh local space
   * @returns an array of Vector3
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData
   */
  getFacetLocalPositions() {
    const facetData = this._internalAbstractMeshDataInfo._facetData;
    if (!facetData.facetPositions) {
      this.updateFacetData();
    }
    return facetData.facetPositions;
  }
  /**
   * Returns the facetLocalPartitioning array
   * @returns an array of array of numbers
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData
   */
  getFacetLocalPartitioning() {
    const facetData = this._internalAbstractMeshDataInfo._facetData;
    if (!facetData.facetPartitioning) {
      this.updateFacetData();
    }
    return facetData.facetPartitioning;
  }
  /**
   * Returns the i-th facet position in the world system.
   * This method allocates a new Vector3 per call
   * @param i defines the facet index
   * @returns a new Vector3
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData
   */
  getFacetPosition(i) {
    const pos = Vector3.Zero();
    this.getFacetPositionToRef(i, pos);
    return pos;
  }
  /**
   * Sets the reference Vector3 with the i-th facet position in the world system
   * @param i defines the facet index
   * @param ref defines the target vector
   * @returns the current mesh
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData
   */
  getFacetPositionToRef(i, ref) {
    const localPos = this.getFacetLocalPositions()[i];
    const world = this.getWorldMatrix();
    Vector3.TransformCoordinatesToRef(localPos, world, ref);
    return this;
  }
  /**
   * Returns the i-th facet normal in the world system.
   * This method allocates a new Vector3 per call
   * @param i defines the facet index
   * @returns a new Vector3
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData
   */
  getFacetNormal(i) {
    const norm = Vector3.Zero();
    this.getFacetNormalToRef(i, norm);
    return norm;
  }
  /**
   * Sets the reference Vector3 with the i-th facet normal in the world system
   * @param i defines the facet index
   * @param ref defines the target vector
   * @returns the current mesh
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData
   */
  getFacetNormalToRef(i, ref) {
    const localNorm = this.getFacetLocalNormals()[i];
    Vector3.TransformNormalToRef(localNorm, this.getWorldMatrix(), ref);
    return this;
  }
  /**
   * Returns the facets (in an array) in the same partitioning block than the one the passed coordinates are located (expressed in the mesh local system)
   * @param x defines x coordinate
   * @param y defines y coordinate
   * @param z defines z coordinate
   * @returns the array of facet indexes
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData
   */
  getFacetsAtLocalCoordinates(x, y, z) {
    const bInfo = this.getBoundingInfo();
    const data = this._internalAbstractMeshDataInfo._facetData;
    const ox = Math.floor((x - bInfo.minimum.x * data.partitioningBBoxRatio) * data.subDiv.X * data.partitioningBBoxRatio / data.bbSize.x);
    const oy = Math.floor((y - bInfo.minimum.y * data.partitioningBBoxRatio) * data.subDiv.Y * data.partitioningBBoxRatio / data.bbSize.y);
    const oz = Math.floor((z - bInfo.minimum.z * data.partitioningBBoxRatio) * data.subDiv.Z * data.partitioningBBoxRatio / data.bbSize.z);
    if (ox < 0 || ox > data.subDiv.max || oy < 0 || oy > data.subDiv.max || oz < 0 || oz > data.subDiv.max) {
      return null;
    }
    return data.facetPartitioning[ox + data.subDiv.max * oy + data.subDiv.max * data.subDiv.max * oz];
  }
  /**
   * Returns the closest mesh facet index at (x,y,z) World coordinates, null if not found
   * @param x defines x coordinate
   * @param y defines y coordinate
   * @param z defines z coordinate
   * @param projected sets as the (x,y,z) world projection on the facet
   * @param checkFace if true (default false), only the facet "facing" to (x,y,z) or only the ones "turning their backs", according to the parameter "facing" are returned
   * @param facing if facing and checkFace are true, only the facet "facing" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet "turning their backs" to (x, y, z) are returned : negative dot (x, y, z) * facet position
   * @returns the face index if found (or null instead)
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData
   */
  getClosestFacetAtCoordinates(x, y, z, projected, checkFace = false, facing = true) {
    const world = this.getWorldMatrix();
    const invMat = TmpVectors.Matrix[5];
    world.invertToRef(invMat);
    const invVect = TmpVectors.Vector3[8];
    Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, invMat, invVect);
    const closest = this.getClosestFacetAtLocalCoordinates(invVect.x, invVect.y, invVect.z, projected, checkFace, facing);
    if (projected) {
      Vector3.TransformCoordinatesFromFloatsToRef(projected.x, projected.y, projected.z, world, projected);
    }
    return closest;
  }
  /**
   * Returns the closest mesh facet index at (x,y,z) local coordinates, null if not found
   * @param x defines x coordinate
   * @param y defines y coordinate
   * @param z defines z coordinate
   * @param projected sets as the (x,y,z) local projection on the facet
   * @param checkFace if true (default false), only the facet "facing" to (x,y,z) or only the ones "turning their backs", according to the parameter "facing" are returned
   * @param facing if facing and checkFace are true, only the facet "facing" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet "turning their backs" to (x, y, z) are returned : negative dot (x, y, z) * facet position
   * @returns the face index if found (or null instead)
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData
   */
  getClosestFacetAtLocalCoordinates(x, y, z, projected, checkFace = false, facing = true) {
    let closest = null;
    let tmpx = 0;
    let tmpy = 0;
    let tmpz = 0;
    let d = 0;
    let t0 = 0;
    let projx = 0;
    let projy = 0;
    let projz = 0;
    const facetPositions = this.getFacetLocalPositions();
    const facetNormals = this.getFacetLocalNormals();
    const facetsInBlock = this.getFacetsAtLocalCoordinates(x, y, z);
    if (!facetsInBlock) {
      return null;
    }
    let shortest = Number.MAX_VALUE;
    let tmpDistance = shortest;
    let fib;
    let norm;
    let p0;
    for (let idx = 0; idx < facetsInBlock.length; idx++) {
      fib = facetsInBlock[idx];
      norm = facetNormals[fib];
      p0 = facetPositions[fib];
      d = (x - p0.x) * norm.x + (y - p0.y) * norm.y + (z - p0.z) * norm.z;
      if (!checkFace || checkFace && facing && d >= 0 || checkFace && !facing && d <= 0) {
        d = norm.x * p0.x + norm.y * p0.y + norm.z * p0.z;
        t0 = -(norm.x * x + norm.y * y + norm.z * z - d) / (norm.x * norm.x + norm.y * norm.y + norm.z * norm.z);
        projx = x + norm.x * t0;
        projy = y + norm.y * t0;
        projz = z + norm.z * t0;
        tmpx = projx - x;
        tmpy = projy - y;
        tmpz = projz - z;
        tmpDistance = tmpx * tmpx + tmpy * tmpy + tmpz * tmpz;
        if (tmpDistance < shortest) {
          shortest = tmpDistance;
          closest = fib;
          if (projected) {
            projected.x = projx;
            projected.y = projy;
            projected.z = projz;
          }
        }
      }
    }
    return closest;
  }
  /**
   * Returns the object "parameter" set with all the expected parameters for facetData computation by ComputeNormals()
   * @returns the parameters
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData
   */
  getFacetDataParameters() {
    return this._internalAbstractMeshDataInfo._facetData.facetParameters;
  }
  /**
   * Disables the feature FacetData and frees the related memory
   * @returns the current mesh
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData
   */
  disableFacetData() {
    const facetData = this._internalAbstractMeshDataInfo._facetData;
    if (facetData.facetDataEnabled) {
      facetData.facetDataEnabled = false;
      facetData.facetPositions = [];
      facetData.facetNormals = [];
      facetData.facetPartitioning = new Array();
      facetData.facetParameters = {};
      facetData.depthSortedIndices = new Uint32Array(0);
    }
    return this;
  }
  /**
   * Updates the AbstractMesh indices array
   * @param indices defines the data source
   * @param offset defines the offset in the index buffer where to store the new data (can be null)
   * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)
   * @returns the current mesh
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  updateIndices(indices, offset, gpuMemoryOnly = false) {
    return this;
  }
  /**
   * Creates new normals data for the mesh
   * @param updatable defines if the normal vertex buffer must be flagged as updatable
   * @returns the current mesh
   */
  createNormals(updatable) {
    const positions = this.getVerticesData(VertexBuffer.PositionKind);
    const indices = this.getIndices();
    let normals;
    if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      normals = this.getVerticesData(VertexBuffer.NormalKind);
    } else {
      normals = [];
    }
    VertexData.ComputeNormals(positions, indices, normals, { useRightHandedSystem: this.getScene().useRightHandedSystem });
    this.setVerticesData(VertexBuffer.NormalKind, normals, updatable);
    return this;
  }
  /**
   * Optimize the indices order so that we keep the faces with similar indices together
   * @returns the current mesh
   */
  async optimizeIndicesAsync() {
    const indices = this.getIndices();
    if (!indices) {
      return this;
    }
    const { OptimizeIndices } = await import("./mesh.vertexData.functions-BD2W4VYI.js");
    OptimizeIndices(indices);
    this.setIndices(indices, this.getTotalVertices());
    return this;
  }
  /**
   * Align the mesh with a normal
   * @param normal defines the normal to use
   * @param upDirection can be used to redefined the up vector to use (will use the (0, 1, 0) by default)
   * @returns the current mesh
   */
  alignWithNormal(normal, upDirection) {
    if (!upDirection) {
      upDirection = Axis.Y;
    }
    const axisX = TmpVectors.Vector3[0];
    const axisZ = TmpVectors.Vector3[1];
    Vector3.CrossToRef(upDirection, normal, axisZ);
    Vector3.CrossToRef(normal, axisZ, axisX);
    if (this.rotationQuaternion) {
      Quaternion.RotationQuaternionFromAxisToRef(axisX, normal, axisZ, this.rotationQuaternion);
    } else {
      Vector3.RotationFromAxisToRef(axisX, normal, axisZ, this.rotation);
    }
    return this;
  }
  /** @internal */
  _checkOcclusionQuery() {
    return false;
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Disables the mesh edge rendering mode
   * @returns the currentAbstractMesh
   */
  disableEdgesRendering() {
    throw _WarnImport("EdgesRenderer");
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Enables the edge rendering mode on the mesh.
   * This mode makes the mesh edges visible
   * @param epsilon defines the maximal distance between two angles to detect a face
   * @param checkVerticesInsteadOfIndices indicates that we should check vertex list directly instead of faces
   * @param options options to the edge renderer
   * @returns the currentAbstractMesh
   * @see https://www.babylonjs-playground.com/#19O9TU#0
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  enableEdgesRendering(epsilon, checkVerticesInsteadOfIndices, options) {
    throw _WarnImport("EdgesRenderer");
  }
  /**
   * This function returns all of the particle systems in the scene that use the mesh as an emitter.
   * @returns an array of particle systems in the scene that use the mesh as an emitter
   */
  getConnectedParticleSystems() {
    return this._scene.particleSystems.filter((particleSystem) => particleSystem.emitter === this);
  }
};
AbstractMesh.OCCLUSION_TYPE_NONE = 0;
AbstractMesh.OCCLUSION_TYPE_OPTIMISTIC = 1;
AbstractMesh.OCCLUSION_TYPE_STRICT = 2;
AbstractMesh.OCCLUSION_ALGORITHM_TYPE_ACCURATE = 0;
AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE = 1;
AbstractMesh.CULLINGSTRATEGY_STANDARD = 0;
AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1;
AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = 2;
AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = 3;
__decorate([
  nativeOverride.filter((...[data, matricesIndicesData, matricesWeightsData, matricesIndicesExtraData, matricesWeightsExtraData]) => !Array.isArray(data) && !Array.isArray(matricesIndicesData) && !Array.isArray(matricesWeightsData) && !Array.isArray(matricesIndicesExtraData) && !Array.isArray(matricesWeightsExtraData))
], AbstractMesh, "_ApplySkeleton", null);
RegisterClass("BABYLON.AbstractMesh", AbstractMesh);

// node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.query.js
var _OcclusionDataStorage = class {
  constructor() {
    this.occlusionInternalRetryCounter = 0;
    this.isOcclusionQueryInProgress = false;
    this.isOccluded = false;
    this.occlusionRetryCount = -1;
    this.occlusionType = AbstractMesh.OCCLUSION_TYPE_NONE;
    this.occlusionQueryAlgorithmType = AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE;
    this.forceRenderingWhenOccluded = false;
  }
};
AbstractEngine.prototype.createQuery = function() {
  return null;
};
AbstractEngine.prototype.deleteQuery = function(query) {
  return this;
};
AbstractEngine.prototype.isQueryResultAvailable = function(query) {
  return false;
};
AbstractEngine.prototype.getQueryResult = function(query) {
  return 0;
};
AbstractEngine.prototype.beginOcclusionQuery = function(algorithmType, query) {
  return false;
};
AbstractEngine.prototype.endOcclusionQuery = function(algorithmType) {
  return this;
};
Object.defineProperty(AbstractMesh.prototype, "isOcclusionQueryInProgress", {
  get: function() {
    return this._occlusionDataStorage.isOcclusionQueryInProgress;
  },
  set: function(value) {
    this._occlusionDataStorage.isOcclusionQueryInProgress = value;
  },
  enumerable: false,
  configurable: true
});
Object.defineProperty(AbstractMesh.prototype, "_occlusionDataStorage", {
  get: function() {
    if (!this.__occlusionDataStorage) {
      this.__occlusionDataStorage = new _OcclusionDataStorage();
    }
    return this.__occlusionDataStorage;
  },
  enumerable: false,
  configurable: true
});
Object.defineProperty(AbstractMesh.prototype, "isOccluded", {
  get: function() {
    return this._occlusionDataStorage.isOccluded;
  },
  set: function(value) {
    this._occlusionDataStorage.isOccluded = value;
  },
  enumerable: true,
  configurable: true
});
Object.defineProperty(AbstractMesh.prototype, "occlusionQueryAlgorithmType", {
  get: function() {
    return this._occlusionDataStorage.occlusionQueryAlgorithmType;
  },
  set: function(value) {
    this._occlusionDataStorage.occlusionQueryAlgorithmType = value;
  },
  enumerable: true,
  configurable: true
});
Object.defineProperty(AbstractMesh.prototype, "occlusionType", {
  get: function() {
    return this._occlusionDataStorage.occlusionType;
  },
  set: function(value) {
    this._occlusionDataStorage.occlusionType = value;
  },
  enumerable: true,
  configurable: true
});
Object.defineProperty(AbstractMesh.prototype, "occlusionRetryCount", {
  get: function() {
    return this._occlusionDataStorage.occlusionRetryCount;
  },
  set: function(value) {
    this._occlusionDataStorage.occlusionRetryCount = value;
  },
  enumerable: true,
  configurable: true
});
Object.defineProperty(AbstractMesh.prototype, "forceRenderingWhenOccluded", {
  get: function() {
    return this._occlusionDataStorage.forceRenderingWhenOccluded;
  },
  set: function(value) {
    this._occlusionDataStorage.forceRenderingWhenOccluded = value;
  },
  enumerable: true,
  configurable: true
});
AbstractMesh.prototype._checkOcclusionQuery = function() {
  const dataStorage = this._occlusionDataStorage;
  if (dataStorage.occlusionType === AbstractMesh.OCCLUSION_TYPE_NONE) {
    dataStorage.isOccluded = false;
    return false;
  }
  const engine = this.getEngine();
  if (!engine.getCaps().supportOcclusionQuery) {
    dataStorage.isOccluded = false;
    return false;
  }
  if (!engine.isQueryResultAvailable) {
    dataStorage.isOccluded = false;
    return false;
  }
  if (this.isOcclusionQueryInProgress && this._occlusionQuery !== null && this._occlusionQuery !== void 0) {
    const isOcclusionQueryAvailable = engine.isQueryResultAvailable(this._occlusionQuery);
    if (isOcclusionQueryAvailable) {
      const occlusionQueryResult = engine.getQueryResult(this._occlusionQuery);
      dataStorage.isOcclusionQueryInProgress = false;
      dataStorage.occlusionInternalRetryCounter = 0;
      dataStorage.isOccluded = occlusionQueryResult > 0 ? false : true;
    } else {
      dataStorage.occlusionInternalRetryCounter++;
      if (dataStorage.occlusionRetryCount !== -1 && dataStorage.occlusionInternalRetryCounter > dataStorage.occlusionRetryCount) {
        dataStorage.isOcclusionQueryInProgress = false;
        dataStorage.occlusionInternalRetryCounter = 0;
        dataStorage.isOccluded = dataStorage.occlusionType === AbstractMesh.OCCLUSION_TYPE_OPTIMISTIC ? false : dataStorage.isOccluded;
      } else {
        return dataStorage.occlusionType === AbstractMesh.OCCLUSION_TYPE_OPTIMISTIC ? false : dataStorage.isOccluded;
      }
    }
  }
  const scene = this.getScene();
  if (scene.getBoundingBoxRenderer) {
    const occlusionBoundingBoxRenderer = scene.getBoundingBoxRenderer();
    if (this._occlusionQuery === null) {
      this._occlusionQuery = engine.createQuery();
    }
    if (this._occlusionQuery && engine.beginOcclusionQuery(dataStorage.occlusionQueryAlgorithmType, this._occlusionQuery)) {
      occlusionBoundingBoxRenderer.renderOcclusionBoundingBox(this);
      engine.endOcclusionQuery(dataStorage.occlusionQueryAlgorithmType);
      this._occlusionDataStorage.isOcclusionQueryInProgress = true;
    }
  }
  return dataStorage.isOccluded;
};

// node_modules/@babylonjs/core/Engines/WebGPU/Extensions/engine.query.js
ThinWebGPUEngine.prototype.getGPUFrameTimeCounter = function() {
  return this._timestampQuery.gpuFrameTimeCounter;
};
ThinWebGPUEngine.prototype.captureGPUFrameTime = function(value) {
  this._timestampQuery.enable = value && !!this._caps.timerQuery;
};
ThinWebGPUEngine.prototype.createQuery = function() {
  return this._occlusionQuery.createQuery();
};
ThinWebGPUEngine.prototype.deleteQuery = function(query) {
  this._occlusionQuery.deleteQuery(query);
  return this;
};
ThinWebGPUEngine.prototype.isQueryResultAvailable = function(query) {
  return this._occlusionQuery.isQueryResultAvailable(query);
};
ThinWebGPUEngine.prototype.getQueryResult = function(query) {
  return this._occlusionQuery.getQueryResult(query);
};
ThinWebGPUEngine.prototype.beginOcclusionQuery = function(algorithmType, query) {
  if (this.compatibilityMode) {
    if (this._occlusionQuery.canBeginQuery(query)) {
      this._currentRenderPass?.beginOcclusionQuery(query);
      return true;
    }
  } else {
    this._bundleList.addItem(new WebGPURenderItemBeginOcclusionQuery(query));
    return true;
  }
  return false;
};
ThinWebGPUEngine.prototype.endOcclusionQuery = function() {
  if (this.compatibilityMode) {
    this._currentRenderPass?.endOcclusionQuery();
  } else {
    this._bundleList.addItem(new WebGPURenderItemEndOcclusionQuery());
  }
  return this;
};

// node_modules/@babylonjs/core/Engines/webgpuEngine.js
var viewDescriptorSwapChainAntialiasing = {
  label: `TextureView_SwapChain_ResolveTarget`,
  dimension: "2d",
  format: void 0,
  // will be updated with the right value
  mipLevelCount: 1,
  arrayLayerCount: 1
};
var viewDescriptorSwapChain = {
  label: `TextureView_SwapChain`,
  dimension: "2d",
  format: void 0,
  // will be updated with the right value
  mipLevelCount: 1,
  arrayLayerCount: 1
};
var tempColor4 = new Color4();
var WebGPUEngine = class _WebGPUEngine extends ThinWebGPUEngine {
  /**
   * Gets or sets the snapshot rendering mode
   */
  get snapshotRenderingMode() {
    return this._snapshotRendering.mode;
  }
  set snapshotRenderingMode(mode) {
    this._snapshotRendering.mode = mode;
  }
  /**
   * Creates a new snapshot at the next frame using the current snapshotRenderingMode
   */
  snapshotRenderingReset() {
    this._snapshotRendering.reset();
  }
  /**
   * Enables or disables the snapshot rendering mode
   * Note that the WebGL engine does not support snapshot rendering so setting the value won't have any effect for this engine
   */
  get snapshotRendering() {
    return this._snapshotRendering.enabled;
  }
  set snapshotRendering(activate) {
    this._snapshotRendering.enabled = activate;
  }
  /**
   * Sets this to true to disable the cache for the samplers. You should do it only for testing purpose!
   */
  get disableCacheSamplers() {
    return this._cacheSampler ? this._cacheSampler.disabled : false;
  }
  set disableCacheSamplers(disable) {
    if (this._cacheSampler) {
      this._cacheSampler.disabled = disable;
    }
  }
  /**
   * Sets this to true to disable the cache for the render pipelines. You should do it only for testing purpose!
   */
  get disableCacheRenderPipelines() {
    return this._cacheRenderPipeline ? this._cacheRenderPipeline.disabled : false;
  }
  set disableCacheRenderPipelines(disable) {
    if (this._cacheRenderPipeline) {
      this._cacheRenderPipeline.disabled = disable;
    }
  }
  /**
   * Sets this to true to disable the cache for the bind groups. You should do it only for testing purpose!
   */
  get disableCacheBindGroups() {
    return this._cacheBindGroups ? this._cacheBindGroups.disabled : false;
  }
  set disableCacheBindGroups(disable) {
    if (this._cacheBindGroups) {
      this._cacheBindGroups.disabled = disable;
    }
  }
  /**
   * Gets a boolean indicating if all created effects are ready
   * @returns true if all effects are ready
   */
  areAllEffectsReady() {
    return true;
  }
  /**
   * Get Font size information
   * @param font font name
   * @returns an object containing ascent, height and descent
   */
  getFontOffset(font) {
    return GetFontOffset(font);
  }
  /**
   * Gets a Promise<boolean> indicating if the engine can be instantiated (ie. if a WebGPU context can be found)
   */
  static get IsSupportedAsync() {
    return !navigator.gpu ? Promise.resolve(false) : navigator.gpu.requestAdapter().then((adapter) => !!adapter, () => false).catch(() => false);
  }
  /**
   * Not supported by WebGPU, you should call IsSupportedAsync instead!
   */
  static get IsSupported() {
    Logger.Warn("You must call IsSupportedAsync for WebGPU!");
    return false;
  }
  /**
   * Gets a boolean indicating that the engine supports uniform buffers
   */
  get supportsUniformBuffers() {
    return true;
  }
  /** Gets the supported extensions by the WebGPU adapter */
  get supportedExtensions() {
    return this._adapterSupportedExtensions;
  }
  /** Gets the currently enabled extensions on the WebGPU device */
  get enabledExtensions() {
    return this._deviceEnabledExtensions;
  }
  /** Gets the supported limits by the WebGPU adapter */
  get supportedLimits() {
    return this._adapterSupportedLimits;
  }
  /** Gets the current limits of the WebGPU device */
  get currentLimits() {
    return this._deviceLimits;
  }
  /**
   * Returns a string describing the current engine
   */
  get description() {
    const description = this.name + this.version;
    return description;
  }
  /**
   * Returns the version of the engine
   */
  get version() {
    return 1;
  }
  /**
   * Gets an object containing information about the current engine context
   * @returns an object containing the vendor, the renderer and the version of the current engine context
   */
  getInfo() {
    return {
      vendor: this._adapterInfo.vendor || "unknown vendor",
      renderer: this._adapterInfo.architecture || "unknown renderer",
      version: this._adapterInfo.description || "unknown version"
    };
  }
  /**
   * (WebGPU only) True (default) to be in compatibility mode, meaning rendering all existing scenes without artifacts (same rendering than WebGL).
   * Setting the property to false will improve performances but may not work in some scenes if some precautions are not taken.
   * See https://doc.babylonjs.com/setup/support/webGPU/webGPUOptimization/webGPUNonCompatibilityMode for more details
   */
  get compatibilityMode() {
    return this._compatibilityMode;
  }
  set compatibilityMode(mode) {
    this._compatibilityMode = mode;
  }
  /** @internal */
  get currentSampleCount() {
    return this._currentRenderTarget ? this._currentRenderTarget.samples : this._mainPassSampleCount;
  }
  /**
   * Create a new instance of the gpu engine asynchronously
   * @param canvas Defines the canvas to use to display the result
   * @param options Defines the options passed to the engine to create the GPU context dependencies
   * @returns a promise that resolves with the created engine
   */
  static CreateAsync(canvas, options = {}) {
    const engine = new _WebGPUEngine(canvas, options);
    return new Promise((resolve) => {
      engine.initAsync(options.glslangOptions, options.twgslOptions).then(() => resolve(engine));
    });
  }
  /**
   * Create a new instance of the gpu engine.
   * @param canvas Defines the canvas to use to display the result
   * @param options Defines the options passed to the engine to create the GPU context dependencies
   */
  constructor(canvas, options = {}) {
    super(options.antialias ?? true, options);
    this.uniqueId = -1;
    this._uploadEncoderDescriptor = { label: "upload" };
    this._renderEncoderDescriptor = { label: "render" };
    this._clearDepthValue = 1;
    this._clearReverseDepthValue = 0;
    this._clearStencilValue = 0;
    this._defaultSampleCount = 4;
    this._glslang = null;
    this._tintWASM = null;
    this._glslangAndTintAreFullyLoaded = false;
    this._adapterInfo = {
      vendor: "",
      architecture: "",
      device: "",
      description: ""
    };
    this._compiledComputeEffects = {};
    this._counters = {
      numEnableEffects: 0,
      numEnableDrawWrapper: 0,
      numBundleCreationNonCompatMode: 0,
      numBundleReuseNonCompatMode: 0
    };
    this.countersLastFrame = {
      numEnableEffects: 0,
      numEnableDrawWrapper: 0,
      numBundleCreationNonCompatMode: 0,
      numBundleReuseNonCompatMode: 0
    };
    this.numMaxUncapturedErrors = 20;
    this.scenes = [];
    this._virtualScenes = new Array();
    this._commandBuffers = [null, null];
    this._mainRenderPassWrapper = {
      renderPassDescriptor: null,
      colorAttachmentViewDescriptor: null,
      depthAttachmentViewDescriptor: null,
      colorAttachmentGPUTextures: [],
      depthTextureFormat: void 0
    };
    this._rttRenderPassWrapper = {
      renderPassDescriptor: null,
      colorAttachmentViewDescriptor: null,
      depthAttachmentViewDescriptor: null,
      colorAttachmentGPUTextures: [],
      depthTextureFormat: void 0
    };
    this._pendingDebugCommands = [];
    this._currentOverrideVertexBuffers = null;
    this._currentIndexBuffer = null;
    this._colorWriteLocal = true;
    this._forceEnableEffect = false;
    this.isNDCHalfZRange = true;
    this.hasOriginBottomLeft = false;
    this._workingGlslangAndTintPromise = null;
    this._viewportsCurrent = { x: 0, y: 0, w: 0, h: 0 };
    this._scissorsCurrent = { x: 0, y: 0, w: 0, h: 0 };
    this._scissorCached = { x: 0, y: 0, z: 0, w: 0 };
    this._stencilRefsCurrent = -1;
    this._blendColorsCurrent = [null, null, null, null];
    this._performanceMonitor = new PerformanceMonitor();
    this._name = "WebGPU";
    this._drawCalls = new PerfCounter();
    options.deviceDescriptor = options.deviceDescriptor || {};
    options.enableGPUDebugMarkers = options.enableGPUDebugMarkers ?? false;
    Logger.Log(`Babylon.js v${AbstractEngine.Version} - ${this.description} engine`);
    if (!navigator.gpu) {
      Logger.Error("WebGPU is not supported by your browser.");
      return;
    }
    options.swapChainFormat = options.swapChainFormat || navigator.gpu.getPreferredCanvasFormat();
    this._isWebGPU = true;
    this._shaderPlatformName = "WEBGPU";
    this._renderingCanvas = canvas;
    this._options = options;
    this._mainPassSampleCount = options.antialias ? this._defaultSampleCount : 1;
    if (navigator && navigator.userAgent) {
      this._setupMobileChecks();
    }
    this._sharedInit(this._renderingCanvas);
    this._shaderProcessor = new WebGPUShaderProcessorGLSL();
    this._shaderProcessorWGSL = new WebGPUShaderProcessorWGSL();
  }
  /**
   * Load the glslang and tintWASM libraries and prepare them for use.
   * @returns a promise that resolves when the engine is ready to use the glslang and tintWASM
   */
  prepareGlslangAndTintAsync() {
    if (!this._workingGlslangAndTintPromise) {
      this._workingGlslangAndTintPromise = new Promise((resolve) => {
        this._initGlslang(this._glslangOptions ?? this._options?.glslangOptions).then((glslang) => {
          this._glslang = glslang;
          this._tintWASM = new WebGPUTintWASM();
          this._tintWASM.initTwgsl(this._twgslOptions ?? this._options?.twgslOptions).then(() => {
            this._glslangAndTintAreFullyLoaded = true;
            resolve();
          });
        });
      });
    }
    return this._workingGlslangAndTintPromise;
  }
  /**
   * Initializes the WebGPU context and dependencies.
   * @param glslangOptions Defines the GLSLang compiler options if necessary
   * @param twgslOptions Defines the Twgsl compiler options if necessary
   * @returns a promise notifying the readiness of the engine.
   */
  initAsync(glslangOptions, twgslOptions) {
    this.uniqueId = _WebGPUEngine._InstanceId++;
    this._glslangOptions = glslangOptions;
    this._twgslOptions = twgslOptions;
    return navigator.gpu.requestAdapter(this._options).then((adapter) => {
      if (!adapter) {
        throw "Could not retrieve a WebGPU adapter (adapter is null).";
      } else {
        this._adapter = adapter;
        this._adapterSupportedExtensions = [];
        this._adapter.features?.forEach((feature) => this._adapterSupportedExtensions.push(feature));
        this._adapterSupportedLimits = this._adapter.limits;
        this._adapterInfo = this._adapter.info;
        const deviceDescriptor = this._options.deviceDescriptor ?? {};
        const requiredFeatures = deviceDescriptor?.requiredFeatures ?? (this._options.enableAllFeatures ? this._adapterSupportedExtensions : void 0);
        if (requiredFeatures) {
          const requestedExtensions = requiredFeatures;
          const validExtensions = [];
          for (const extension of requestedExtensions) {
            if (this._adapterSupportedExtensions.indexOf(extension) !== -1) {
              validExtensions.push(extension);
            }
          }
          deviceDescriptor.requiredFeatures = validExtensions;
        }
        if (this._options.setMaximumLimits && !deviceDescriptor.requiredLimits) {
          deviceDescriptor.requiredLimits = {};
          for (const name3 in this._adapterSupportedLimits) {
            if (name3 === "minSubgroupSize" || name3 === "maxSubgroupSize") {
              continue;
            }
            deviceDescriptor.requiredLimits[name3] = this._adapterSupportedLimits[name3];
          }
        }
        deviceDescriptor.label = `BabylonWebGPUDevice${this.uniqueId}`;
        return this._adapter.requestDevice(deviceDescriptor);
      }
    }).then((device) => {
      this._device = device;
      this._deviceEnabledExtensions = [];
      this._device.features?.forEach((feature) => this._deviceEnabledExtensions.push(feature));
      this._deviceLimits = device.limits;
      let numUncapturedErrors = -1;
      this._device.addEventListener("uncapturederror", (event) => {
        if (++numUncapturedErrors < this.numMaxUncapturedErrors) {
          Logger.Warn(`WebGPU uncaptured error (${numUncapturedErrors + 1}): ${event.error} - ${event.error.message}`);
        } else if (numUncapturedErrors++ === this.numMaxUncapturedErrors) {
          Logger.Warn(`WebGPU uncaptured error: too many warnings (${this.numMaxUncapturedErrors}), no more warnings will be reported to the console for this engine.`);
        }
      });
      if (!this._doNotHandleContextLost) {
        this._device.lost?.then((info) => {
          if (this._isDisposed) {
            return;
          }
          this._contextWasLost = true;
          Logger.Warn("WebGPU context lost. " + info);
          this.onContextLostObservable.notifyObservers(this);
          this._restoreEngineAfterContextLost(async () => {
            const snapshotRenderingMode = this.snapshotRenderingMode;
            const snapshotRendering = this.snapshotRendering;
            const disableCacheSamplers = this.disableCacheSamplers;
            const disableCacheRenderPipelines = this.disableCacheRenderPipelines;
            const disableCacheBindGroups = this.disableCacheBindGroups;
            const enableGPUTimingMeasurements = this.enableGPUTimingMeasurements;
            await this.initAsync(this._glslangOptions ?? this._options?.glslangOptions, this._twgslOptions ?? this._options?.twgslOptions);
            this.snapshotRenderingMode = snapshotRenderingMode;
            this.snapshotRendering = snapshotRendering;
            this.disableCacheSamplers = disableCacheSamplers;
            this.disableCacheRenderPipelines = disableCacheRenderPipelines;
            this.disableCacheBindGroups = disableCacheBindGroups;
            this.enableGPUTimingMeasurements = enableGPUTimingMeasurements;
            this._currentRenderPass = null;
          });
        });
      }
    }).then(() => {
      this._initializeLimits();
      this._bufferManager = new WebGPUBufferManager(this, this._device);
      this._textureHelper = new WebGPUTextureManager(this, this._device, this._bufferManager, this._deviceEnabledExtensions);
      this._cacheSampler = new WebGPUCacheSampler(this._device);
      this._cacheBindGroups = new WebGPUCacheBindGroups(this._device, this._cacheSampler, this);
      this._timestampQuery = new WebGPUTimestampQuery(this, this._device, this._bufferManager);
      this._occlusionQuery = this._device.createQuerySet ? new WebGPUOcclusionQuery(this, this._device, this._bufferManager) : void 0;
      this._bundleList = new WebGPUBundleList(this._device);
      this._snapshotRendering = new WebGPUSnapshotRendering(this, this._snapshotRenderingMode, this._bundleList);
      this._ubInvertY = this._bufferManager.createBuffer(new Float32Array([-1, 0]), BufferUsage.Uniform | BufferUsage.CopyDst, "UBInvertY");
      this._ubDontInvertY = this._bufferManager.createBuffer(new Float32Array([1, 0]), BufferUsage.Uniform | BufferUsage.CopyDst, "UBDontInvertY");
      if (this.dbgVerboseLogsForFirstFrames) {
        if (this._count === void 0) {
          this._count = 0;
          Logger.Log(["%c frame #" + this._count + " - begin", "background: #ffff00"]);
        }
      }
      this._uploadEncoder = this._device.createCommandEncoder(this._uploadEncoderDescriptor);
      this._renderEncoder = this._device.createCommandEncoder(this._renderEncoderDescriptor);
      this._emptyVertexBuffer = new VertexBuffer(this, [0], "", {
        stride: 1,
        offset: 0,
        size: 1,
        label: "EmptyVertexBuffer"
      });
      this._cacheRenderPipeline = new WebGPUCacheRenderPipelineTree(this._device, this._emptyVertexBuffer);
      this._depthCullingState = new WebGPUDepthCullingState(this._cacheRenderPipeline);
      this._stencilStateComposer = new WebGPUStencilStateComposer(this._cacheRenderPipeline);
      this._stencilStateComposer.stencilGlobal = this._stencilState;
      this._depthCullingState.depthTest = true;
      this._depthCullingState.depthFunc = 515;
      this._depthCullingState.depthMask = true;
      this._textureHelper.setCommandEncoder(this._uploadEncoder);
      this._clearQuad = new WebGPUClearQuad(this._device, this, this._emptyVertexBuffer);
      this._defaultDrawContext = this.createDrawContext();
      this._currentDrawContext = this._defaultDrawContext;
      this._defaultMaterialContext = this.createMaterialContext();
      this._currentMaterialContext = this._defaultMaterialContext;
      this._initializeContextAndSwapChain();
      this._initializeMainAttachments();
      this.resize();
    }).catch((e) => {
      Logger.Error("A fatal error occurred during WebGPU creation/initialization.");
      throw e;
    });
  }
  _initGlslang(glslangOptions) {
    glslangOptions = glslangOptions || {};
    glslangOptions = {
      ..._WebGPUEngine._GlslangDefaultOptions,
      ...glslangOptions
    };
    if (glslangOptions.glslang) {
      return Promise.resolve(glslangOptions.glslang);
    }
    if (self.glslang) {
      return self.glslang(glslangOptions.wasmPath);
    }
    if (glslangOptions.jsPath && glslangOptions.wasmPath) {
      return Tools.LoadBabylonScriptAsync(glslangOptions.jsPath).then(() => {
        return self.glslang(Tools.GetBabylonScriptURL(glslangOptions.wasmPath));
      });
    }
    return Promise.reject("gslang is not available.");
  }
  _initializeLimits() {
    this._caps = {
      maxTexturesImageUnits: this._deviceLimits.maxSampledTexturesPerShaderStage,
      maxVertexTextureImageUnits: this._deviceLimits.maxSampledTexturesPerShaderStage,
      maxCombinedTexturesImageUnits: this._deviceLimits.maxSampledTexturesPerShaderStage * 2,
      maxTextureSize: this._deviceLimits.maxTextureDimension2D,
      maxCubemapTextureSize: this._deviceLimits.maxTextureDimension2D,
      maxRenderTextureSize: this._deviceLimits.maxTextureDimension2D,
      maxVertexAttribs: this._deviceLimits.maxVertexAttributes,
      maxDrawBuffers: 8,
      maxVaryingVectors: this._deviceLimits.maxInterStageShaderVariables,
      maxFragmentUniformVectors: Math.floor(this._deviceLimits.maxUniformBufferBindingSize / 4),
      maxVertexUniformVectors: Math.floor(this._deviceLimits.maxUniformBufferBindingSize / 4),
      standardDerivatives: true,
      astc: this._deviceEnabledExtensions.indexOf(
        "texture-compression-astc"
        /* WebGPUConstants.FeatureName.TextureCompressionASTC */
      ) >= 0 ? true : void 0,
      s3tc: this._deviceEnabledExtensions.indexOf(
        "texture-compression-bc"
        /* WebGPUConstants.FeatureName.TextureCompressionBC */
      ) >= 0 ? true : void 0,
      pvrtc: null,
      etc1: null,
      etc2: this._deviceEnabledExtensions.indexOf(
        "texture-compression-etc2"
        /* WebGPUConstants.FeatureName.TextureCompressionETC2 */
      ) >= 0 ? true : void 0,
      bptc: this._deviceEnabledExtensions.indexOf(
        "texture-compression-bc"
        /* WebGPUConstants.FeatureName.TextureCompressionBC */
      ) >= 0 ? true : void 0,
      maxAnisotropy: 16,
      // Most implementations support maxAnisotropy values in range between 1 and 16, inclusive. The used value of maxAnisotropy will be clamped to the maximum value that the platform supports.
      uintIndices: true,
      fragmentDepthSupported: true,
      highPrecisionShaderSupported: true,
      colorBufferFloat: true,
      supportFloatTexturesResolve: false,
      // See https://github.com/gpuweb/gpuweb/issues/3844
      rg11b10ufColorRenderable: this._deviceEnabledExtensions.indexOf(
        "rg11b10ufloat-renderable"
        /* WebGPUConstants.FeatureName.RG11B10UFloatRenderable */
      ) >= 0,
      textureFloat: true,
      textureFloatLinearFiltering: this._deviceEnabledExtensions.indexOf(
        "float32-filterable"
        /* WebGPUConstants.FeatureName.Float32Filterable */
      ) >= 0,
      textureFloatRender: true,
      textureHalfFloat: true,
      textureHalfFloatLinearFiltering: true,
      textureHalfFloatRender: true,
      textureLOD: true,
      texelFetch: true,
      drawBuffersExtension: true,
      depthTextureExtension: true,
      vertexArrayObject: false,
      instancedArrays: true,
      timerQuery: typeof BigUint64Array !== "undefined" && this._deviceEnabledExtensions.indexOf(
        "timestamp-query"
        /* WebGPUConstants.FeatureName.TimestampQuery */
      ) !== -1 ? true : void 0,
      supportOcclusionQuery: typeof BigUint64Array !== "undefined",
      canUseTimestampForTimerQuery: true,
      multiview: false,
      oculusMultiview: false,
      parallelShaderCompile: void 0,
      blendMinMax: true,
      maxMSAASamples: 4,
      // the spec only supports values of 1 and 4
      canUseGLInstanceID: true,
      canUseGLVertexID: true,
      supportComputeShaders: true,
      supportSRGBBuffers: true,
      supportTransformFeedbacks: false,
      textureMaxLevel: true,
      texture2DArrayMaxLayerCount: this._deviceLimits.maxTextureArrayLayers,
      disableMorphTargetTexture: false,
      textureNorm16: false
      // in the works: https://github.com/gpuweb/gpuweb/issues/3001
    };
    this._features = {
      forceBitmapOverHTMLImageElement: true,
      supportRenderAndCopyToLodForFloatTextures: true,
      supportDepthStencilTexture: true,
      supportShadowSamplers: true,
      uniformBufferHardCheckMatrix: false,
      allowTexturePrefiltering: true,
      trackUbosInFrame: true,
      checkUbosContentBeforeUpload: true,
      supportCSM: true,
      basisNeedsPOT: false,
      support3DTextures: true,
      needTypeSuffixInShaderConstants: true,
      supportMSAA: true,
      supportSSAO2: true,
      supportIBLShadows: true,
      supportExtendedTextureFormats: true,
      supportSwitchCaseInShader: true,
      supportSyncTextureRead: false,
      needsInvertingBitmap: false,
      useUBOBindingCache: false,
      needShaderCodeInlining: true,
      needToAlwaysBindUniformBuffers: true,
      supportRenderPasses: true,
      supportSpriteInstancing: true,
      forceVertexBufferStrideAndOffsetMultiple4Bytes: true,
      _checkNonFloatVertexBuffersDontRecreatePipelineContext: true,
      _collectUbosUpdatedInFrame: false
    };
  }
  _initializeContextAndSwapChain() {
    if (!this._renderingCanvas) {
      throw "The rendering canvas has not been set!";
    }
    this._context = this._renderingCanvas.getContext("webgpu");
    this._configureContext();
    this._colorFormat = this._options.swapChainFormat;
    this._mainRenderPassWrapper.colorAttachmentGPUTextures = [new WebGPUHardwareTexture(this)];
    this._mainRenderPassWrapper.colorAttachmentGPUTextures[0].format = this._colorFormat;
    this._setColorFormat(this._mainRenderPassWrapper);
  }
  // Set default values as WebGL with depth and stencil attachment for the broadest Compat.
  _initializeMainAttachments() {
    if (!this._bufferManager) {
      return;
    }
    this.flushFramebuffer();
    this._mainTextureExtends = {
      width: this.getRenderWidth(true),
      height: this.getRenderHeight(true),
      depthOrArrayLayers: 1
    };
    const bufferDataUpdate = new Float32Array([this.getRenderHeight(true)]);
    this._bufferManager.setSubData(this._ubInvertY, 4, bufferDataUpdate);
    this._bufferManager.setSubData(this._ubDontInvertY, 4, bufferDataUpdate);
    let mainColorAttachments;
    if (this._options.antialias) {
      const mainTextureDescriptor = {
        label: `Texture_MainColor_${this._mainTextureExtends.width}x${this._mainTextureExtends.height}_antialiasing`,
        size: this._mainTextureExtends,
        mipLevelCount: 1,
        sampleCount: this._mainPassSampleCount,
        dimension: "2d",
        format: this._options.swapChainFormat,
        usage: 16
      };
      if (this._mainTexture) {
        this._textureHelper.releaseTexture(this._mainTexture);
      }
      this._mainTexture = this._device.createTexture(mainTextureDescriptor);
      mainColorAttachments = [
        {
          view: this._mainTexture.createView({
            label: "TextureView_MainColor_antialiasing",
            dimension: "2d",
            format: this._options.swapChainFormat,
            mipLevelCount: 1,
            arrayLayerCount: 1
          }),
          clearValue: new Color4(0, 0, 0, 1),
          loadOp: "clear",
          storeOp: "store"
          // don't use StoreOp.Discard, else using several cameras with different viewports or using scissors will fail because we call beginRenderPass / endPass several times for the same color attachment!
        }
      ];
    } else {
      mainColorAttachments = [
        {
          view: void 0,
          clearValue: new Color4(0, 0, 0, 1),
          loadOp: "clear",
          storeOp: "store"
        }
      ];
    }
    this._mainRenderPassWrapper.depthTextureFormat = this.isStencilEnable ? "depth24plus-stencil8" : "depth32float";
    this._setDepthTextureFormat(this._mainRenderPassWrapper);
    this._setColorFormat(this._mainRenderPassWrapper);
    const depthTextureDescriptor = {
      label: `Texture_MainDepthStencil_${this._mainTextureExtends.width}x${this._mainTextureExtends.height}`,
      size: this._mainTextureExtends,
      mipLevelCount: 1,
      sampleCount: this._mainPassSampleCount,
      dimension: "2d",
      format: this._mainRenderPassWrapper.depthTextureFormat,
      usage: 16
    };
    if (this._depthTexture) {
      this._textureHelper.releaseTexture(this._depthTexture);
    }
    this._depthTexture = this._device.createTexture(depthTextureDescriptor);
    const mainDepthAttachment = {
      view: this._depthTexture.createView({
        label: `TextureView_MainDepthStencil_${this._mainTextureExtends.width}x${this._mainTextureExtends.height}`,
        dimension: "2d",
        format: this._depthTexture.format,
        mipLevelCount: 1,
        arrayLayerCount: 1
      }),
      depthClearValue: this._clearDepthValue,
      depthLoadOp: "clear",
      depthStoreOp: "store",
      stencilClearValue: this._clearStencilValue,
      stencilLoadOp: !this.isStencilEnable ? void 0 : "clear",
      stencilStoreOp: !this.isStencilEnable ? void 0 : "store"
    };
    this._mainRenderPassWrapper.renderPassDescriptor = {
      label: "MainRenderPass",
      colorAttachments: mainColorAttachments,
      depthStencilAttachment: mainDepthAttachment
    };
  }
  /**
   * Shared initialization across engines types.
   * @param canvas The canvas associated with this instance of the engine.
   */
  _sharedInit(canvas) {
    super._sharedInit(canvas);
    _CommonInit(this, canvas, this._creationOptions);
  }
  _configureContext() {
    this._context.configure({
      device: this._device,
      format: this._options.swapChainFormat,
      usage: 16 | 1,
      alphaMode: this.premultipliedAlpha ? "premultiplied" : "opaque"
    });
  }
  /**
   * Resize an image and returns the image data as an uint8array
   * @param image image to resize
   * @param bufferWidth destination buffer width
   * @param bufferHeight destination buffer height
   * @returns an uint8array containing RGBA values of bufferWidth * bufferHeight size
   */
  resizeImageBitmap(image, bufferWidth, bufferHeight) {
    return ResizeImageBitmap(this, image, bufferWidth, bufferHeight);
  }
  /**
   * Engine abstraction for loading and creating an image bitmap from a given source string.
   * @param imageSource source to load the image from.
   * @param options An object that sets options for the image's extraction.
   * @returns ImageBitmap
   */
  _createImageBitmapFromSource(imageSource, options) {
    return CreateImageBitmapFromSource(this, imageSource, options);
  }
  /**
   * Toggle full screen mode
   * @param requestPointerLock defines if a pointer lock should be requested from the user
   */
  switchFullscreen(requestPointerLock) {
    if (this.isFullscreen) {
      this.exitFullscreen();
    } else {
      this.enterFullscreen(requestPointerLock);
    }
  }
  /**
   * Enters full screen mode
   * @param requestPointerLock defines if a pointer lock should be requested from the user
   */
  enterFullscreen(requestPointerLock) {
    if (!this.isFullscreen) {
      this._pointerLockRequested = requestPointerLock;
      if (this._renderingCanvas) {
        RequestFullscreen(this._renderingCanvas);
      }
    }
  }
  /**
   * Exits full screen mode
   */
  exitFullscreen() {
    if (this.isFullscreen) {
      ExitFullscreen();
    }
  }
  /**
   * Enters Pointerlock mode
   */
  enterPointerlock() {
    if (this._renderingCanvas) {
      RequestPointerlock(this._renderingCanvas);
    }
  }
  /**
   * Exits Pointerlock mode
   */
  exitPointerlock() {
    ExitPointerlock();
  }
  _rebuildBuffers() {
    super._rebuildBuffers();
    for (const storageBuffer of this._storageBuffers) {
      if (storageBuffer.getBuffer().engineId !== this.uniqueId) {
        storageBuffer._rebuild();
      }
    }
  }
  _restoreEngineAfterContextLost(initEngine) {
    WebGPUCacheRenderPipelineTree.ResetCache();
    WebGPUCacheBindGroups.ResetCache();
    const cleanScenes = (scenes) => {
      for (const scene of scenes) {
        for (const mesh of scene.meshes) {
          const subMeshes = mesh.subMeshes;
          if (!subMeshes) {
            continue;
          }
          for (const subMesh of subMeshes) {
            subMesh._drawWrappers = [];
          }
        }
        for (const material of scene.materials) {
          material._materialContext?.reset();
        }
      }
    };
    cleanScenes(this.scenes);
    cleanScenes(this._virtualScenes);
    const uboList = [];
    for (const uniformBuffer of this._uniformBuffers) {
      if (uniformBuffer.name.indexOf("leftOver") < 0) {
        uboList.push(uniformBuffer);
      }
    }
    this._uniformBuffers = uboList;
    super._restoreEngineAfterContextLost(initEngine);
  }
  /**
   * Force a specific size of the canvas
   * @param width defines the new canvas' width
   * @param height defines the new canvas' height
   * @param forceSetSize true to force setting the sizes of the underlying canvas
   * @returns true if the size was changed
   */
  setSize(width, height, forceSetSize = false) {
    if (!super.setSize(width, height, forceSetSize)) {
      return false;
    }
    if (this.dbgVerboseLogsForFirstFrames) {
      if (this._count === void 0) {
        this._count = 0;
      }
      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {
        Logger.Log(["frame #" + this._count + " - setSize -", width, height]);
      }
    }
    this._initializeMainAttachments();
    if (this.snapshotRendering) {
      this.snapshotRenderingReset();
    }
    return true;
  }
  /**
   * @internal
   */
  _getShaderProcessor(shaderLanguage) {
    if (shaderLanguage === 1) {
      return this._shaderProcessorWGSL;
    }
    return this._shaderProcessor;
  }
  /**
   * @internal
   */
  _getShaderProcessingContext(shaderLanguage, pureMode) {
    return new WebGPUShaderProcessingContext(shaderLanguage, pureMode);
  }
  _getCurrentRenderPass() {
    if (this._currentRenderTarget && !this._currentRenderPass) {
      this._startRenderTargetRenderPass(this._currentRenderTarget, false, null, false, false);
    } else if (!this._currentRenderPass) {
      this._startMainRenderPass(false);
    }
    return this._currentRenderPass;
  }
  /** @internal */
  _getCurrentRenderPassWrapper() {
    return this._currentRenderTarget ? this._rttRenderPassWrapper : this._mainRenderPassWrapper;
  }
  //------------------------------------------------------------------------------
  //                          Static Pipeline WebGPU States
  //------------------------------------------------------------------------------
  /** @internal */
  applyStates() {
    this._stencilStateComposer.apply();
    this._cacheRenderPipeline.setAlphaBlendEnabled(this._alphaState.alphaBlend);
  }
  /**
   * Force the entire cache to be cleared
   * You should not have to use this function unless your engine needs to share the WebGPU context with another engine
   * @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)
   */
  wipeCaches(bruteForce) {
    if (this.preventCacheWipeBetweenFrames && !bruteForce) {
      return;
    }
    this._forceEnableEffect = true;
    this._currentIndexBuffer = null;
    this._currentOverrideVertexBuffers = null;
    this._cacheRenderPipeline.setBuffers(null, null, null);
    if (bruteForce) {
      this._stencilStateComposer.reset();
      this._depthCullingState.reset();
      this._depthCullingState.depthFunc = 515;
      this._alphaState.reset();
      this._alphaMode = 1;
      this._alphaEquation = 0;
      this._cacheRenderPipeline.setAlphaBlendFactors(this._alphaState._blendFunctionParameters, this._alphaState._blendEquationParameters);
      this._cacheRenderPipeline.setAlphaBlendEnabled(false);
      this.setColorWrite(true);
    }
    this._cachedVertexBuffers = null;
    this._cachedIndexBuffer = null;
    this._cachedEffectForVertexBuffers = null;
  }
  /**
   * Enable or disable color writing
   * @param enable defines the state to set
   */
  setColorWrite(enable) {
    this._colorWriteLocal = enable;
    this._cacheRenderPipeline.setWriteMask(enable ? 15 : 0);
  }
  /**
   * Gets a boolean indicating if color writing is enabled
   * @returns the current color writing state
   */
  getColorWrite() {
    return this._colorWriteLocal;
  }
  _mustUpdateViewport() {
    const x = this._viewportCached.x, y = this._viewportCached.y, w = this._viewportCached.z, h = this._viewportCached.w;
    const update = this._viewportsCurrent.x !== x || this._viewportsCurrent.y !== y || this._viewportsCurrent.w !== w || this._viewportsCurrent.h !== h;
    if (update) {
      this._viewportsCurrent.x = this._viewportCached.x;
      this._viewportsCurrent.y = this._viewportCached.y;
      this._viewportsCurrent.w = this._viewportCached.z;
      this._viewportsCurrent.h = this._viewportCached.w;
    }
    return update;
  }
  _applyViewport(bundleList) {
    const x = Math.floor(this._viewportCached.x);
    const w = Math.floor(this._viewportCached.z);
    const h = Math.floor(this._viewportCached.w);
    let y = Math.floor(this._viewportCached.y);
    if (!this._currentRenderTarget) {
      y = this.getRenderHeight(true) - y - h;
    }
    if (bundleList) {
      bundleList.addItem(new WebGPURenderItemViewport(x, y, w, h));
    } else {
      this._getCurrentRenderPass().setViewport(x, y, w, h, 0, 1);
    }
    if (this.dbgVerboseLogsForFirstFrames) {
      if (this._count === void 0) {
        this._count = 0;
      }
      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {
        Logger.Log([
          "frame #" + this._count + " - viewport applied - (",
          this._viewportCached.x,
          this._viewportCached.y,
          this._viewportCached.z,
          this._viewportCached.w,
          ") current pass is main pass=" + this._currentPassIsMainPass()
        ]);
      }
    }
  }
  /**
   * @internal
   */
  _viewport(x, y, width, height) {
    this._viewportCached.x = x;
    this._viewportCached.y = y;
    this._viewportCached.z = width;
    this._viewportCached.w = height;
  }
  _mustUpdateScissor() {
    const x = this._scissorCached.x, y = this._scissorCached.y, w = this._scissorCached.z, h = this._scissorCached.w;
    const update = this._scissorsCurrent.x !== x || this._scissorsCurrent.y !== y || this._scissorsCurrent.w !== w || this._scissorsCurrent.h !== h;
    if (update) {
      this._scissorsCurrent.x = this._scissorCached.x;
      this._scissorsCurrent.y = this._scissorCached.y;
      this._scissorsCurrent.w = this._scissorCached.z;
      this._scissorsCurrent.h = this._scissorCached.w;
    }
    return update;
  }
  _applyScissor(bundleList) {
    const y = this._currentRenderTarget ? this._scissorCached.y : this.getRenderHeight() - this._scissorCached.w - this._scissorCached.y;
    if (bundleList) {
      bundleList.addItem(new WebGPURenderItemScissor(this._scissorCached.x, y, this._scissorCached.z, this._scissorCached.w));
    } else {
      this._getCurrentRenderPass().setScissorRect(this._scissorCached.x, y, this._scissorCached.z, this._scissorCached.w);
    }
    if (this.dbgVerboseLogsForFirstFrames) {
      if (this._count === void 0) {
        this._count = 0;
      }
      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {
        Logger.Log([
          "frame #" + this._count + " - scissor applied - (",
          this._scissorCached.x,
          this._scissorCached.y,
          this._scissorCached.z,
          this._scissorCached.w,
          ") current pass is main pass=" + this._currentPassIsMainPass()
        ]);
      }
    }
  }
  _scissorIsActive() {
    return this._scissorCached.x !== 0 || this._scissorCached.y !== 0 || this._scissorCached.z !== 0 || this._scissorCached.w !== 0;
  }
  enableScissor(x, y, width, height) {
    this._scissorCached.x = x;
    this._scissorCached.y = y;
    this._scissorCached.z = width;
    this._scissorCached.w = height;
  }
  disableScissor() {
    this._scissorCached.x = this._scissorCached.y = this._scissorCached.z = this._scissorCached.w = 0;
    this._scissorsCurrent.x = this._scissorsCurrent.y = this._scissorsCurrent.w = this._scissorsCurrent.h = 0;
  }
  _mustUpdateStencilRef() {
    const update = this._stencilStateComposer.funcRef !== this._stencilRefsCurrent;
    if (update) {
      this._stencilRefsCurrent = this._stencilStateComposer.funcRef;
    }
    return update;
  }
  _applyStencilRef(bundleList) {
    if (bundleList) {
      bundleList.addItem(new WebGPURenderItemStencilRef(this._stencilStateComposer.funcRef ?? 0));
    } else {
      this._getCurrentRenderPass().setStencilReference(this._stencilStateComposer.funcRef ?? 0);
    }
  }
  _mustUpdateBlendColor() {
    const colorBlend = this._alphaState._blendConstants;
    const update = colorBlend[0] !== this._blendColorsCurrent[0] || colorBlend[1] !== this._blendColorsCurrent[1] || colorBlend[2] !== this._blendColorsCurrent[2] || colorBlend[3] !== this._blendColorsCurrent[3];
    if (update) {
      this._blendColorsCurrent[0] = colorBlend[0];
      this._blendColorsCurrent[1] = colorBlend[1];
      this._blendColorsCurrent[2] = colorBlend[2];
      this._blendColorsCurrent[3] = colorBlend[3];
    }
    return update;
  }
  _applyBlendColor(bundleList) {
    if (bundleList) {
      bundleList.addItem(new WebGPURenderItemBlendColor(this._alphaState._blendConstants.slice()));
    } else {
      this._getCurrentRenderPass().setBlendConstant(this._alphaState._blendConstants);
    }
  }
  _resetRenderPassStates() {
    this._viewportsCurrent.x = this._viewportsCurrent.y = this._viewportsCurrent.w = this._viewportsCurrent.h = 0;
    this._scissorsCurrent.x = this._scissorsCurrent.y = this._scissorsCurrent.w = this._scissorsCurrent.h = 0;
    this._stencilRefsCurrent = -1;
    this._blendColorsCurrent[0] = this._blendColorsCurrent[1] = this._blendColorsCurrent[2] = this._blendColorsCurrent[3] = null;
  }
  /**
   * Clear the current render buffer or the current render target (if any is set up)
   * @param color defines the color to use
   * @param backBuffer defines if the back buffer must be cleared
   * @param depth defines if the depth buffer must be cleared
   * @param stencil defines if the stencil buffer must be cleared
   */
  clear(color, backBuffer, depth, stencil = false) {
    if (color && color.a === void 0) {
      color.a = 1;
    }
    const hasScissor = this._scissorIsActive();
    if (this.dbgVerboseLogsForFirstFrames) {
      if (this._count === void 0) {
        this._count = 0;
      }
      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {
        Logger.Log(["frame #" + this._count + " - clear - backBuffer=", backBuffer, " depth=", depth, " stencil=", stencil, " scissor is active=", hasScissor]);
      }
    }
    if (this._currentRenderTarget) {
      if (hasScissor) {
        if (!this._currentRenderPass) {
          this._startRenderTargetRenderPass(this._currentRenderTarget, false, backBuffer ? color : null, depth, stencil);
        }
        this._applyScissor(!this.compatibilityMode ? this._bundleList : null);
        this._clearFullQuad(backBuffer ? color : null, depth, stencil);
      } else {
        if (this._currentRenderPass) {
          this._endCurrentRenderPass();
        }
        this._startRenderTargetRenderPass(this._currentRenderTarget, true, backBuffer ? color : null, depth, stencil);
      }
    } else {
      if (!this._currentRenderPass || !hasScissor) {
        this._startMainRenderPass(!hasScissor, backBuffer ? color : null, depth, stencil);
      }
      if (hasScissor) {
        this._applyScissor(!this.compatibilityMode ? this._bundleList : null);
        this._clearFullQuad(backBuffer ? color : null, depth, stencil);
      }
    }
  }
  _clearFullQuad(clearColor, clearDepth, clearStencil) {
    const renderPass = !this.compatibilityMode ? null : this._getCurrentRenderPass();
    this._clearQuad.setColorFormat(this._colorFormat);
    this._clearQuad.setDepthStencilFormat(this._depthTextureFormat);
    this._clearQuad.setMRTAttachments(this._cacheRenderPipeline.mrtAttachments ?? [], this._cacheRenderPipeline.mrtTextureArray ?? [], this._cacheRenderPipeline.mrtTextureCount);
    if (!this.compatibilityMode) {
      this._bundleList.addItem(new WebGPURenderItemStencilRef(this._clearStencilValue));
    } else {
      renderPass.setStencilReference(this._clearStencilValue);
    }
    const bundle = this._clearQuad.clear(renderPass, clearColor, clearDepth, clearStencil, this.currentSampleCount);
    if (!this.compatibilityMode) {
      this._bundleList.addBundle(bundle);
      this._applyStencilRef(this._bundleList);
      this._reportDrawCall();
    } else {
      this._applyStencilRef(null);
    }
  }
  //------------------------------------------------------------------------------
  //                              Vertex/Index/Storage Buffers
  //------------------------------------------------------------------------------
  /**
   * Creates a vertex buffer
   * @param data the data or the size for the vertex buffer
   * @param _updatable whether the buffer should be created as updatable
   * @param label defines the label of the buffer (for debug purpose)
   * @returns the new buffer
   */
  createVertexBuffer(data, _updatable, label) {
    let view;
    if (data instanceof Array) {
      view = new Float32Array(data);
    } else if (data instanceof ArrayBuffer) {
      view = new Uint8Array(data);
    } else {
      view = data;
    }
    const dataBuffer = this._bufferManager.createBuffer(view, BufferUsage.Vertex | BufferUsage.CopyDst, label);
    return dataBuffer;
  }
  /**
   * Creates a vertex buffer
   * @param data the data for the dynamic vertex buffer
   * @param label defines the label of the buffer (for debug purpose)
   * @returns the new buffer
   */
  createDynamicVertexBuffer(data, label) {
    return this.createVertexBuffer(data, void 0, label);
  }
  /**
   * Creates a new index buffer
   * @param indices defines the content of the index buffer
   * @param _updatable defines if the index buffer must be updatable
   * @param label defines the label of the buffer (for debug purpose)
   * @returns a new buffer
   */
  createIndexBuffer(indices, _updatable, label) {
    let is32Bits = true;
    let view;
    if (indices instanceof Uint32Array || indices instanceof Int32Array) {
      view = indices;
    } else if (indices instanceof Uint16Array) {
      view = indices;
      is32Bits = false;
    } else {
      for (let index = 0; index < indices.length; index++) {
        if (indices[index] > 65535) {
          view = new Uint32Array(indices);
          break;
        }
      }
      if (!view) {
        view = new Uint16Array(indices);
        is32Bits = false;
      }
    }
    const dataBuffer = this._bufferManager.createBuffer(view, BufferUsage.Index | BufferUsage.CopyDst, label);
    dataBuffer.is32Bits = is32Bits;
    return dataBuffer;
  }
  /**
   * Update a dynamic index buffer
   * @param indexBuffer defines the target index buffer
   * @param indices defines the data to update
   * @param offset defines the offset in the target index buffer where update should start
   */
  updateDynamicIndexBuffer(indexBuffer, indices, offset = 0) {
    const gpuBuffer = indexBuffer;
    let view;
    if (indexBuffer.is32Bits) {
      view = indices instanceof Uint32Array ? indices : new Uint32Array(indices);
    } else {
      view = indices instanceof Uint16Array ? indices : new Uint16Array(indices);
    }
    this._bufferManager.setSubData(gpuBuffer, offset, view);
  }
  /**
   * Updates a dynamic vertex buffer.
   * @param vertexBuffer the vertex buffer to update
   * @param data the data used to update the vertex buffer
   * @param byteOffset the byte offset of the data
   * @param byteLength the byte length of the data
   */
  updateDynamicVertexBuffer(vertexBuffer, data, byteOffset, byteLength) {
    const dataBuffer = vertexBuffer;
    if (byteOffset === void 0) {
      byteOffset = 0;
    }
    let view;
    if (byteLength === void 0) {
      if (data instanceof Array) {
        view = new Float32Array(data);
      } else if (data instanceof ArrayBuffer) {
        view = new Uint8Array(data);
      } else {
        view = data;
      }
      byteLength = view.byteLength;
    } else {
      if (data instanceof Array) {
        view = new Float32Array(data);
      } else if (data instanceof ArrayBuffer) {
        view = new Uint8Array(data);
      } else {
        view = data;
      }
    }
    this._bufferManager.setSubData(dataBuffer, byteOffset, view, 0, byteLength);
  }
  /**
   * @internal
   */
  _createBuffer(data, creationFlags, label) {
    let view;
    if (data instanceof Array) {
      view = new Float32Array(data);
    } else if (data instanceof ArrayBuffer) {
      view = new Uint8Array(data);
    } else {
      view = data;
    }
    let flags = 0;
    if (creationFlags & 1) {
      flags |= BufferUsage.CopySrc;
    }
    if (creationFlags & 2) {
      flags |= BufferUsage.CopyDst;
    }
    if (creationFlags & 4) {
      flags |= BufferUsage.Uniform;
    }
    if (creationFlags & 8) {
      flags |= BufferUsage.Vertex;
    }
    if (creationFlags & 16) {
      flags |= BufferUsage.Index;
    }
    if (creationFlags & 32) {
      flags |= BufferUsage.Storage;
    }
    if (creationFlags & 64) {
      flags |= BufferUsage.Indirect;
    }
    return this._bufferManager.createBuffer(view, flags, label);
  }
  /**
   * @internal
   */
  bindBuffersDirectly() {
    throw "Not implemented on WebGPU";
  }
  /**
   * @internal
   */
  updateAndBindInstancesBuffer() {
    throw "Not implemented on WebGPU";
  }
  /**
   * Unbind all instance attributes
   */
  unbindInstanceAttributes() {
  }
  /**
   * Bind a list of vertex buffers with the engine
   * @param vertexBuffers defines the list of vertex buffers to bind
   * @param indexBuffer defines the index buffer to bind
   * @param effect defines the effect associated with the vertex buffers
   * @param overrideVertexBuffers defines optional list of avertex buffers that overrides the entries in vertexBuffers
   */
  bindBuffers(vertexBuffers, indexBuffer, effect, overrideVertexBuffers) {
    this._currentIndexBuffer = indexBuffer;
    this._currentOverrideVertexBuffers = overrideVertexBuffers ?? null;
    this._cacheRenderPipeline.setBuffers(vertexBuffers, indexBuffer, this._currentOverrideVertexBuffers);
  }
  /**
   * @internal
   */
  _releaseBuffer(buffer) {
    return this._bufferManager.releaseBuffer(buffer);
  }
  //------------------------------------------------------------------------------
  //                              Uniform Buffers
  //------------------------------------------------------------------------------
  /**
   * Create an uniform buffer
   * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets
   * @param elements defines the content of the uniform buffer
   * @param label defines a name for the buffer (for debugging purpose)
   * @returns the webGL uniform buffer
   */
  createUniformBuffer(elements, label) {
    let view;
    if (elements instanceof Array) {
      view = new Float32Array(elements);
    } else {
      view = elements;
    }
    const dataBuffer = this._bufferManager.createBuffer(view, BufferUsage.Uniform | BufferUsage.CopyDst, label);
    return dataBuffer;
  }
  /**
   * Create a dynamic uniform buffer (no different from a non dynamic uniform buffer in WebGPU)
   * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets
   * @param elements defines the content of the uniform buffer
   * @param label defines a name for the buffer (for debugging purpose)
   * @returns the webGL uniform buffer
   */
  createDynamicUniformBuffer(elements, label) {
    return this.createUniformBuffer(elements, label);
  }
  /**
   * Update an existing uniform buffer
   * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets
   * @param uniformBuffer defines the target uniform buffer
   * @param elements defines the content to update
   * @param offset defines the offset in the uniform buffer where update should start
   * @param count defines the size of the data to update
   */
  updateUniformBuffer(uniformBuffer, elements, offset, count) {
    if (offset === void 0) {
      offset = 0;
    }
    const dataBuffer = uniformBuffer;
    let view;
    if (count === void 0) {
      if (elements instanceof Float32Array) {
        view = elements;
      } else {
        view = new Float32Array(elements);
      }
      count = view.byteLength;
    } else {
      if (elements instanceof Float32Array) {
        view = elements;
      } else {
        view = new Float32Array(elements);
      }
    }
    this._bufferManager.setSubData(dataBuffer, offset, view, 0, count);
  }
  /**
   * Bind a buffer to the current draw context
   * @param buffer defines the buffer to bind
   * @param _location not used in WebGPU
   * @param name Name of the uniform variable to bind
   */
  bindUniformBufferBase(buffer, _location, name3) {
    this._currentDrawContext.setBuffer(name3, buffer);
  }
  /**
   * Unused in WebGPU
   */
  bindUniformBlock() {
  }
  //------------------------------------------------------------------------------
  //                              Effects
  //------------------------------------------------------------------------------
  /**
   * Create a new effect (used to store vertex/fragment shaders)
   * @param baseName defines the base name of the effect (The name of file without .fragment.fx or .vertex.fx)
   * @param attributesNamesOrOptions defines either a list of attribute names or an IEffectCreationOptions object
   * @param uniformsNamesOrEngine defines either a list of uniform names or the engine to use
   * @param samplers defines an array of string used to represent textures
   * @param defines defines the string containing the defines to use to compile the shaders
   * @param fallbacks defines the list of potential fallbacks to use if shader compilation fails
   * @param onCompiled defines a function to call when the effect creation is successful
   * @param onError defines a function to call when the effect creation has failed
   * @param indexParameters defines an object containing the index values to use to compile shaders (like the maximum number of simultaneous lights)
   * @param shaderLanguage the language the shader is written in (default: GLSL)
   * @param extraInitializationsAsync additional async code to run before preparing the effect
   * @returns the new Effect
   */
  createEffect(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, defines, fallbacks, onCompiled, onError, indexParameters, shaderLanguage = 0, extraInitializationsAsync) {
    const vertex = typeof baseName === "string" ? baseName : baseName.vertexToken || baseName.vertexSource || baseName.vertexElement || baseName.vertex;
    const fragment = typeof baseName === "string" ? baseName : baseName.fragmentToken || baseName.fragmentSource || baseName.fragmentElement || baseName.fragment;
    const globalDefines = this._getGlobalDefines();
    const isOptions = attributesNamesOrOptions.attributes !== void 0;
    let fullDefines = defines ?? attributesNamesOrOptions.defines ?? "";
    if (globalDefines) {
      fullDefines += "\n" + globalDefines;
    }
    const name3 = vertex + "+" + fragment + "@" + fullDefines;
    if (this._compiledEffects[name3]) {
      const compiledEffect = this._compiledEffects[name3];
      if (onCompiled && compiledEffect.isReady()) {
        onCompiled(compiledEffect);
      }
      compiledEffect._refCount++;
      return compiledEffect;
    }
    const effect = new Effect(baseName, attributesNamesOrOptions, isOptions ? this : uniformsNamesOrEngine, samplers, this, defines, fallbacks, onCompiled, onError, indexParameters, name3, attributesNamesOrOptions.shaderLanguage ?? shaderLanguage, attributesNamesOrOptions.extraInitializationsAsync ?? extraInitializationsAsync);
    this._compiledEffects[name3] = effect;
    return effect;
  }
  _compileRawShaderToSpirV(source, type) {
    return this._glslang.compileGLSL(source, type);
  }
  _compileShaderToSpirV(source, type, defines, shaderVersion) {
    return this._compileRawShaderToSpirV(shaderVersion + (defines ? defines + "\n" : "") + source, type);
  }
  _getWGSLShader(source, type, defines) {
    if (defines) {
      defines = "//" + defines.split("\n").join("\n//") + "\n";
    } else {
      defines = "";
    }
    return defines + source;
  }
  _createPipelineStageDescriptor(vertexShader, fragmentShader, shaderLanguage, disableUniformityAnalysisInVertex, disableUniformityAnalysisInFragment) {
    if (this._tintWASM && shaderLanguage === 0) {
      vertexShader = this._tintWASM.convertSpirV2WGSL(vertexShader, disableUniformityAnalysisInVertex);
      fragmentShader = this._tintWASM.convertSpirV2WGSL(fragmentShader, disableUniformityAnalysisInFragment);
    }
    return {
      vertexStage: {
        module: this._device.createShaderModule({
          label: "vertex",
          code: vertexShader
        }),
        entryPoint: "main"
      },
      fragmentStage: {
        module: this._device.createShaderModule({
          label: "fragment",
          code: fragmentShader
        }),
        entryPoint: "main"
      }
    };
  }
  _compileRawPipelineStageDescriptor(vertexCode, fragmentCode, shaderLanguage) {
    const disableUniformityAnalysisInVertex = vertexCode.indexOf(`#define DISABLE_UNIFORMITY_ANALYSIS`) >= 0;
    const disableUniformityAnalysisInFragment = fragmentCode.indexOf(`#define DISABLE_UNIFORMITY_ANALYSIS`) >= 0;
    const vertexShader = shaderLanguage === 0 ? this._compileRawShaderToSpirV(vertexCode, "vertex") : vertexCode;
    const fragmentShader = shaderLanguage === 0 ? this._compileRawShaderToSpirV(fragmentCode, "fragment") : fragmentCode;
    return this._createPipelineStageDescriptor(vertexShader, fragmentShader, shaderLanguage, disableUniformityAnalysisInVertex, disableUniformityAnalysisInFragment);
  }
  _compilePipelineStageDescriptor(vertexCode, fragmentCode, defines, shaderLanguage) {
    this.onBeforeShaderCompilationObservable.notifyObservers(this);
    const disableUniformityAnalysisInVertex = vertexCode.indexOf(`#define DISABLE_UNIFORMITY_ANALYSIS`) >= 0;
    const disableUniformityAnalysisInFragment = fragmentCode.indexOf(`#define DISABLE_UNIFORMITY_ANALYSIS`) >= 0;
    const shaderVersion = "#version 450\n";
    const vertexShader = shaderLanguage === 0 ? this._compileShaderToSpirV(vertexCode, "vertex", defines, shaderVersion) : this._getWGSLShader(vertexCode, "vertex", defines);
    const fragmentShader = shaderLanguage === 0 ? this._compileShaderToSpirV(fragmentCode, "fragment", defines, shaderVersion) : this._getWGSLShader(fragmentCode, "fragment", defines);
    const program = this._createPipelineStageDescriptor(vertexShader, fragmentShader, shaderLanguage, disableUniformityAnalysisInVertex, disableUniformityAnalysisInFragment);
    this.onAfterShaderCompilationObservable.notifyObservers(this);
    return program;
  }
  /**
   * @internal
   */
  createRawShaderProgram() {
    throw "Not available on WebGPU";
  }
  /**
   * @internal
   */
  createShaderProgram() {
    throw "Not available on WebGPU";
  }
  /**
   * Inline functions in shader code that are marked to be inlined
   * @param code code to inline
   * @returns inlined code
   */
  inlineShaderCode(code) {
    const sci = new ShaderCodeInliner(code);
    sci.debug = false;
    sci.processCode();
    return sci.code;
  }
  /**
   * Creates a new pipeline context
   * @param shaderProcessingContext defines the shader processing context used during the processing if available
   * @returns the new pipeline
   */
  createPipelineContext(shaderProcessingContext) {
    return new WebGPUPipelineContext(shaderProcessingContext, this);
  }
  /**
   * Creates a new material context
   * @returns the new context
   */
  createMaterialContext() {
    return new WebGPUMaterialContext();
  }
  /**
   * Creates a new draw context
   * @returns the new context
   */
  createDrawContext() {
    return new WebGPUDrawContext(this._bufferManager);
  }
  /**
   * @internal
   */
  async _preparePipelineContext(pipelineContext, vertexSourceCode, fragmentSourceCode, createAsRaw, rawVertexSourceCode, rawFragmentSourceCode, _rebuildRebind, defines, _transformFeedbackVaryings, _key, onReady) {
    const webGpuContext = pipelineContext;
    const shaderLanguage = webGpuContext.shaderProcessingContext.shaderLanguage;
    if (shaderLanguage === 0 && !this._glslangAndTintAreFullyLoaded) {
      await this.prepareGlslangAndTintAsync();
    }
    if (this.dbgShowShaderCode) {
      Logger.Log(["defines", defines]);
      Logger.Log(vertexSourceCode);
      Logger.Log(fragmentSourceCode);
      Logger.Log("***********************************************");
    }
    webGpuContext.sources = {
      fragment: fragmentSourceCode,
      vertex: vertexSourceCode,
      rawVertex: rawVertexSourceCode,
      rawFragment: rawFragmentSourceCode
    };
    if (createAsRaw) {
      webGpuContext.stages = this._compileRawPipelineStageDescriptor(vertexSourceCode, fragmentSourceCode, shaderLanguage);
    } else {
      webGpuContext.stages = this._compilePipelineStageDescriptor(vertexSourceCode, fragmentSourceCode, defines, shaderLanguage);
    }
    onReady();
  }
  /**
   * Gets the list of active attributes for a given WebGPU program
   * @param pipelineContext defines the pipeline context to use
   * @param attributesNames defines the list of attribute names to get
   * @returns an array of indices indicating the offset of each attribute
   */
  getAttributes(pipelineContext, attributesNames) {
    const results = new Array(attributesNames.length);
    const gpuPipelineContext = pipelineContext;
    for (let i = 0; i < attributesNames.length; i++) {
      const attributeName = attributesNames[i];
      const attributeLocation = gpuPipelineContext.shaderProcessingContext.availableAttributes[attributeName];
      if (attributeLocation === void 0) {
        continue;
      }
      results[i] = attributeLocation;
    }
    return results;
  }
  /**
   * Activates an effect, making it the current one (ie. the one used for rendering)
   * @param effect defines the effect to activate
   */
  enableEffect(effect) {
    if (!effect) {
      return;
    }
    if (!IsWrapper(effect)) {
      this._currentEffect = effect;
      this._currentMaterialContext = this._defaultMaterialContext;
      this._currentDrawContext = this._defaultDrawContext;
      this._counters.numEnableEffects++;
      if (this.dbgLogIfNotDrawWrapper) {
        Logger.Warn(`enableEffect has been called with an Effect and not a Wrapper! effect.uniqueId=${effect.uniqueId}, effect.name=${effect.name}, effect.name.vertex=${typeof effect.name === "string" ? "" : effect.name.vertex}, effect.name.fragment=${typeof effect.name === "string" ? "" : effect.name.fragment}`, 10);
      }
    } else if (!effect.effect || effect.effect === this._currentEffect && effect.materialContext === this._currentMaterialContext && effect.drawContext === this._currentDrawContext && !this._forceEnableEffect) {
      if (!effect.effect && this.dbgShowEmptyEnableEffectCalls) {
        Logger.Log(["drawWrapper=", effect]);
        throw "Invalid call to enableEffect: the effect property is empty!";
      }
      return;
    } else {
      this._currentEffect = effect.effect;
      this._currentMaterialContext = effect.materialContext;
      this._currentDrawContext = effect.drawContext;
      this._counters.numEnableDrawWrapper++;
      if (!this._currentMaterialContext) {
        Logger.Log(["drawWrapper=", effect]);
        throw `Invalid call to enableEffect: the materialContext property is empty!`;
      }
    }
    this._stencilStateComposer.stencilMaterial = void 0;
    this._forceEnableEffect = false;
    if (this._currentEffect.onBind) {
      this._currentEffect.onBind(this._currentEffect);
    }
    if (this._currentEffect._onBindObservable) {
      this._currentEffect._onBindObservable.notifyObservers(this._currentEffect);
    }
  }
  /**
   * @internal
   */
  _releaseEffect(effect) {
    if (this._compiledEffects[effect._key]) {
      delete this._compiledEffects[effect._key];
      this._deletePipelineContext(effect.getPipelineContext());
    }
  }
  /**
   * Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled
   */
  releaseEffects() {
    for (const name3 in this._compiledEffects) {
      const webGPUPipelineContext = this._compiledEffects[name3].getPipelineContext();
      this._deletePipelineContext(webGPUPipelineContext);
    }
    this._compiledEffects = {};
    this.onReleaseEffectsObservable.notifyObservers(this);
  }
  _deletePipelineContext(pipelineContext) {
    const webgpuPipelineContext = pipelineContext;
    if (webgpuPipelineContext) {
      resetCachedPipeline(webgpuPipelineContext);
    }
  }
  //------------------------------------------------------------------------------
  //                              Textures
  //------------------------------------------------------------------------------
  /**
   * Gets a boolean indicating that only power of 2 textures are supported
   * Please note that you can still use non power of 2 textures but in this case the engine will forcefully convert them
   */
  get needPOTTextures() {
    return false;
  }
  /** @internal */
  _createHardwareTexture() {
    return new WebGPUHardwareTexture(this);
  }
  /**
   * @internal
   */
  _releaseTexture(texture) {
    const index = this._internalTexturesCache.indexOf(texture);
    if (index !== -1) {
      this._internalTexturesCache.splice(index, 1);
    }
    this._textureHelper.releaseTexture(texture);
  }
  /**
   * @internal
   */
  _getRGBABufferInternalSizedFormat() {
    return 5;
  }
  updateTextureComparisonFunction(texture, comparisonFunction) {
    texture._comparisonFunction = comparisonFunction;
  }
  /**
   * Creates an internal texture without binding it to a framebuffer
   * @internal
   * @param size defines the size of the texture
   * @param options defines the options used to create the texture
   * @param delayGPUTextureCreation true to delay the texture creation the first time it is really needed. false to create it right away
   * @param source source type of the texture
   * @returns a new internal texture
   */
  _createInternalTexture(size, options, delayGPUTextureCreation = true, source = 0) {
    const fullOptions = {};
    if (options !== void 0 && typeof options === "object") {
      fullOptions.generateMipMaps = options.generateMipMaps;
      fullOptions.createMipMaps = options.createMipMaps;
      fullOptions.type = options.type === void 0 ? 0 : options.type;
      fullOptions.samplingMode = options.samplingMode === void 0 ? 3 : options.samplingMode;
      fullOptions.format = options.format === void 0 ? 5 : options.format;
      fullOptions.samples = options.samples ?? 1;
      fullOptions.creationFlags = options.creationFlags ?? 0;
      fullOptions.useSRGBBuffer = options.useSRGBBuffer ?? false;
      fullOptions.label = options.label;
    } else {
      fullOptions.generateMipMaps = options;
      fullOptions.type = 0;
      fullOptions.samplingMode = 3;
      fullOptions.format = 5;
      fullOptions.samples = 1;
      fullOptions.creationFlags = 0;
      fullOptions.useSRGBBuffer = false;
    }
    if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {
      fullOptions.samplingMode = 1;
    } else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {
      fullOptions.samplingMode = 1;
    }
    if (fullOptions.type === 1 && !this._caps.textureFloat) {
      fullOptions.type = 0;
      Logger.Warn("Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE");
    }
    const texture = new InternalTexture(this, source);
    const width = size.width ?? size;
    const height = size.height ?? size;
    const depth = size.depth ?? 0;
    const layers = size.layers ?? 0;
    texture.baseWidth = width;
    texture.baseHeight = height;
    texture.width = width;
    texture.height = height;
    texture.depth = depth || layers;
    texture.isReady = true;
    texture.samples = fullOptions.samples;
    texture.generateMipMaps = !!fullOptions.generateMipMaps;
    texture.samplingMode = fullOptions.samplingMode;
    texture.type = fullOptions.type;
    texture.format = fullOptions.format;
    texture.is2DArray = layers > 0;
    texture.is3D = depth > 0;
    texture._cachedWrapU = 0;
    texture._cachedWrapV = 0;
    texture._useSRGBBuffer = fullOptions.useSRGBBuffer;
    texture.label = fullOptions.label;
    this._internalTexturesCache.push(texture);
    if (!delayGPUTextureCreation) {
      const createMipMapsOnly = !fullOptions.generateMipMaps && fullOptions.createMipMaps;
      if (createMipMapsOnly) {
        texture.generateMipMaps = true;
      }
      this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, layers || 1, fullOptions.creationFlags);
      if (createMipMapsOnly) {
        texture.generateMipMaps = false;
      }
    }
    return texture;
  }
  /**
   * Usually called from Texture.ts.
   * Passed information to create a hardware texture
   * @param url defines a value which contains one of the following:
   * * A conventional http URL, e.g. 'http://...' or 'file://...'
   * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'
   * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'
   * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file
   * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)
   * @param scene needed for loading to the correct scene
   * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)
   * @param onLoad optional callback to be called upon successful completion
   * @param onError optional callback to be called upon failure
   * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob
   * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities
   * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures
   * @param forcedExtension defines the extension to use to pick the right loader
   * @param mimeType defines an optional mime type
   * @param loaderOptions options to be passed to the loader
   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).
   * @returns a InternalTexture for assignment back into BABYLON.Texture
   */
  createTexture(url, noMipmap, invertY, scene, samplingMode = 3, onLoad = null, onError = null, buffer = null, fallback = null, format = null, forcedExtension = null, mimeType, loaderOptions, creationFlags, useSRGBBuffer) {
    return this._createTextureBase(url, noMipmap, invertY, scene, samplingMode, onLoad, onError, (texture, extension, scene2, img, invertY2, noMipmap2, isCompressed, processFunction) => {
      const imageBitmap = img;
      texture.baseWidth = imageBitmap.width;
      texture.baseHeight = imageBitmap.height;
      texture.width = imageBitmap.width;
      texture.height = imageBitmap.height;
      texture.format = texture.format !== -1 ? texture.format : format ?? 5;
      texture.type = texture.type !== -1 ? texture.type : 0;
      texture._creationFlags = creationFlags ?? 0;
      processFunction(texture.width, texture.height, imageBitmap, extension, texture, () => {
      });
      if (!texture._hardwareTexture?.underlyingResource) {
        const gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, imageBitmap.width, imageBitmap.height, void 0, creationFlags);
        if (WebGPUTextureHelper.IsImageBitmap(imageBitmap)) {
          this._textureHelper.updateTexture(imageBitmap, texture, imageBitmap.width, imageBitmap.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY2, false, 0, 0);
          if (!noMipmap2 && !isCompressed) {
            this._generateMipmaps(texture, this._uploadEncoder);
          }
        }
      } else if (!noMipmap2 && !isCompressed) {
        this._generateMipmaps(texture, this._uploadEncoder);
      }
      if (scene2) {
        scene2.removePendingData(texture);
      }
      texture.isReady = true;
      texture.onLoadedObservable.notifyObservers(texture);
      texture.onLoadedObservable.clear();
    }, () => false, buffer, fallback, format, forcedExtension, mimeType, loaderOptions, useSRGBBuffer);
  }
  /**
   * Wraps an external web gpu texture in a Babylon texture.
   * @param texture defines the external texture
   * @returns the babylon internal texture
   */
  wrapWebGPUTexture(texture) {
    const hardwareTexture = new WebGPUHardwareTexture(this, texture);
    const internalTexture = new InternalTexture(this, 0, true);
    internalTexture._hardwareTexture = hardwareTexture;
    internalTexture.isReady = true;
    return internalTexture;
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Wraps an external web gl texture in a Babylon texture.
   * @returns the babylon internal texture
   */
  wrapWebGLTexture() {
    throw new Error("wrapWebGLTexture is not supported, use wrapWebGPUTexture instead.");
  }
  /**
   * @internal
   */
  _getUseSRGBBuffer(useSRGBBuffer, _noMipmap) {
    return useSRGBBuffer && this._caps.supportSRGBBuffers;
  }
  /**
   * @internal
   */
  _unpackFlipY(_value) {
  }
  /**
   * Update the sampling mode of a given texture
   * @param samplingMode defines the required sampling mode
   * @param texture defines the texture to update
   * @param generateMipMaps defines whether to generate mipmaps for the texture
   */
  updateTextureSamplingMode(samplingMode, texture, generateMipMaps = false) {
    if (generateMipMaps) {
      texture.generateMipMaps = true;
      this._generateMipmaps(texture);
    }
    texture.samplingMode = samplingMode;
  }
  /**
   * Update the sampling mode of a given texture
   * @param texture defines the texture to update
   * @param wrapU defines the texture wrap mode of the u coordinates
   * @param wrapV defines the texture wrap mode of the v coordinates
   * @param wrapR defines the texture wrap mode of the r coordinates
   */
  updateTextureWrappingMode(texture, wrapU, wrapV = null, wrapR = null) {
    if (wrapU !== null) {
      texture._cachedWrapU = wrapU;
    }
    if (wrapV !== null) {
      texture._cachedWrapV = wrapV;
    }
    if ((texture.is2DArray || texture.is3D) && wrapR !== null) {
      texture._cachedWrapR = wrapR;
    }
  }
  /**
   * Update the dimensions of a texture
   * @param texture texture to update
   * @param width new width of the texture
   * @param height new height of the texture
   * @param depth new depth of the texture
   */
  updateTextureDimensions(texture, width, height, depth = 1) {
    if (!texture._hardwareTexture) {
      return;
    }
    if (texture.width === width && texture.height === height && texture.depth === depth) {
      return;
    }
    const additionalUsages = texture._hardwareTexture.textureAdditionalUsages;
    texture._hardwareTexture.release();
    this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, depth, additionalUsages);
  }
  /**
   * @internal
   */
  _setInternalTexture(name3, texture, baseName) {
    baseName = baseName ?? name3;
    if (this._currentEffect) {
      const webgpuPipelineContext = this._currentEffect._pipelineContext;
      const availableTexture = webgpuPipelineContext.shaderProcessingContext.availableTextures[baseName];
      this._currentMaterialContext.setTexture(name3, texture);
      if (availableTexture && availableTexture.autoBindSampler) {
        const samplerName = baseName + `Sampler`;
        this._currentMaterialContext.setSampler(samplerName, texture);
      }
    }
  }
  /**
   * Create a cube texture from prefiltered data (ie. the mipmaps contain ready to use data for PBR reflection)
   * @param rootUrl defines the url where the file to load is located
   * @param scene defines the current scene
   * @param lodScale defines scale to apply to the mip map selection
   * @param lodOffset defines offset to apply to the mip map selection
   * @param onLoad defines an optional callback raised when the texture is loaded
   * @param onError defines an optional callback raised if there is an issue to load the texture
   * @param format defines the format of the data
   * @param forcedExtension defines the extension to use to pick the right loader
   * @param createPolynomials defines wheter or not to create polynomails harmonics for the texture
   * @returns the cube texture as an InternalTexture
   */
  createPrefilteredCubeTexture(rootUrl, scene, lodScale, lodOffset, onLoad = null, onError = null, format, forcedExtension = null, createPolynomials = true) {
    const callback = (loadData) => {
      if (!loadData) {
        if (onLoad) {
          onLoad(null);
        }
        return;
      }
      const texture = loadData.texture;
      if (!createPolynomials) {
        texture._sphericalPolynomial = new SphericalPolynomial();
      } else if (loadData.info.sphericalPolynomial) {
        texture._sphericalPolynomial = loadData.info.sphericalPolynomial;
      }
      texture._source = 9;
      if (onLoad) {
        onLoad(texture);
      }
    };
    return this.createCubeTexture(rootUrl, scene, null, false, callback, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset);
  }
  /**
   * Sets a texture to the according uniform.
   * @param channel The texture channel
   * @param unused unused parameter
   * @param texture The texture to apply
   * @param name The name of the uniform in the effect
   */
  setTexture(channel, unused, texture, name3) {
    this._setTexture(channel, texture, false, false, name3, name3);
  }
  /**
   * Sets an array of texture to the WebGPU context
   * @param channel defines the channel where the texture array must be set
   * @param unused unused parameter
   * @param textures defines the array of textures to bind
   * @param name name of the channel
   */
  setTextureArray(channel, unused, textures, name3) {
    for (let index = 0; index < textures.length; index++) {
      this._setTexture(-1, textures[index], true, false, name3 + index.toString(), name3);
    }
  }
  /**
   * @internal
   */
  _setTexture(channel, texture, isPartOfTextureArray = false, depthStencilTexture = false, name3 = "", baseName) {
    baseName = baseName ?? name3;
    if (this._currentEffect) {
      if (!texture) {
        this._currentMaterialContext.setTexture(name3, null);
        return false;
      }
      if (texture.video) {
        texture.update();
      } else if (texture.delayLoadState === 4) {
        texture.delayLoad();
        return false;
      }
      let internalTexture = null;
      if (depthStencilTexture) {
        internalTexture = texture.depthStencilTexture;
      } else if (texture.isReady()) {
        internalTexture = texture.getInternalTexture();
      } else if (texture.isCube) {
        internalTexture = this.emptyCubeTexture;
      } else if (texture.is3D) {
        internalTexture = this.emptyTexture3D;
      } else if (texture.is2DArray) {
        internalTexture = this.emptyTexture2DArray;
      } else {
        internalTexture = this.emptyTexture;
      }
      if (internalTexture && !internalTexture.isMultiview) {
        if (internalTexture.isCube && internalTexture._cachedCoordinatesMode !== texture.coordinatesMode) {
          internalTexture._cachedCoordinatesMode = texture.coordinatesMode;
          const textureWrapMode = texture.coordinatesMode !== 3 && texture.coordinatesMode !== 5 ? 1 : 0;
          texture.wrapU = textureWrapMode;
          texture.wrapV = textureWrapMode;
        }
        internalTexture._cachedWrapU = texture.wrapU;
        internalTexture._cachedWrapV = texture.wrapV;
        if (internalTexture.is3D) {
          internalTexture._cachedWrapR = texture.wrapR;
        }
        this._setAnisotropicLevel(0, internalTexture, texture.anisotropicFilteringLevel);
      }
      this._setInternalTexture(name3, internalTexture, baseName);
    } else {
      if (this.dbgVerboseLogsForFirstFrames) {
        if (this._count === void 0) {
          this._count = 0;
        }
        if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {
          Logger.Log(["frame #" + this._count + " - _setTexture called with a null _currentEffect! texture=", texture]);
        }
      }
    }
    return true;
  }
  /**
   * @internal
   */
  _setAnisotropicLevel(target, internalTexture, anisotropicFilteringLevel) {
    if (internalTexture._cachedAnisotropicFilteringLevel !== anisotropicFilteringLevel) {
      internalTexture._cachedAnisotropicFilteringLevel = Math.min(anisotropicFilteringLevel, this._caps.maxAnisotropy);
    }
  }
  /**
   * @internal
   */
  _bindTexture(channel, texture, name3) {
    if (channel === void 0) {
      return;
    }
    this._setInternalTexture(name3, texture);
  }
  /**
   * Generates the mipmaps for a texture
   * @param texture texture to generate the mipmaps for
   */
  generateMipmaps(texture) {
    this._generateMipmaps(texture);
  }
  /**
   * Update a portion of an internal texture
   * @param texture defines the texture to update
   * @param imageData defines the data to store into the texture
   * @param xOffset defines the x coordinates of the update rectangle
   * @param yOffset defines the y coordinates of the update rectangle
   * @param width defines the width of the update rectangle
   * @param height defines the height of the update rectangle
   * @param faceIndex defines the face index if texture is a cube (0 by default)
   * @param lod defines the lod level to update (0 by default)
   * @param generateMipMaps defines whether to generate mipmaps or not
   */
  updateTextureData(texture, imageData, xOffset, yOffset, width, height, faceIndex = 0, lod = 0, generateMipMaps = false) {
    let gpuTextureWrapper = texture._hardwareTexture;
    if (!texture._hardwareTexture?.underlyingResource) {
      gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture);
    }
    const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);
    this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, xOffset, yOffset);
    if (generateMipMaps) {
      this._generateMipmaps(texture);
    }
  }
  /**
   * @internal
   */
  _uploadCompressedDataToTextureDirectly(texture, internalFormat, width, height, imageData, faceIndex = 0, lod = 0) {
    let gpuTextureWrapper = texture._hardwareTexture;
    if (!texture._hardwareTexture?.underlyingResource) {
      texture.format = internalFormat;
      gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);
    }
    const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);
    this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, false, false, 0, 0);
  }
  /**
   * @internal
   */
  _uploadDataToTextureDirectly(texture, imageData, faceIndex = 0, lod = 0, babylonInternalFormat, useTextureWidthAndHeight = false) {
    const lodMaxWidth = Math.round(Math.log(texture.width) * Math.LOG2E);
    const lodMaxHeight = Math.round(Math.log(texture.height) * Math.LOG2E);
    const width = useTextureWidthAndHeight ? texture.width : Math.pow(2, Math.max(lodMaxWidth - lod, 0));
    const height = useTextureWidthAndHeight ? texture.height : Math.pow(2, Math.max(lodMaxHeight - lod, 0));
    let gpuTextureWrapper = texture._hardwareTexture;
    if (!texture._hardwareTexture?.underlyingResource) {
      gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);
    }
    const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);
    this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, 0, 0);
  }
  /**
   * @internal
   */
  _uploadArrayBufferViewToTexture(texture, imageData, faceIndex = 0, lod = 0) {
    this._uploadDataToTextureDirectly(texture, imageData, faceIndex, lod);
  }
  /**
   * @internal
   */
  _uploadImageToTexture(texture, image, faceIndex = 0, lod = 0) {
    let gpuTextureWrapper = texture._hardwareTexture;
    if (!texture._hardwareTexture?.underlyingResource) {
      gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture);
    }
    if (image instanceof HTMLImageElement) {
      throw "WebGPU engine: HTMLImageElement not supported in _uploadImageToTexture!";
    }
    const bitmap = image;
    const width = Math.ceil(texture.width / (1 << lod));
    const height = Math.ceil(texture.height / (1 << lod));
    this._textureHelper.updateTexture(bitmap, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, 0, 0);
  }
  /**
   * Reads pixels from the current frame buffer. Please note that this function can be slow
   * @param x defines the x coordinate of the rectangle where pixels must be read
   * @param y defines the y coordinate of the rectangle where pixels must be read
   * @param width defines the width of the rectangle where pixels must be read
   * @param height defines the height of the rectangle where pixels must be read
   * @param hasAlpha defines whether the output should have alpha or not (defaults to true)
   * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels
   * @param data defines the data to fill with the read pixels (if not provided, a new one will be created)
   * @returns a ArrayBufferView promise (Uint8Array) containing RGBA colors
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  readPixels(x, y, width, height, hasAlpha = true, flushRenderer = true, data = null) {
    const renderPassWrapper = this._getCurrentRenderPassWrapper();
    const hardwareTexture = renderPassWrapper.colorAttachmentGPUTextures[0];
    if (!hardwareTexture) {
      return Promise.resolve(new Uint8Array(0));
    }
    const gpuTexture = hardwareTexture.underlyingResource;
    const gpuTextureFormat = hardwareTexture.format;
    if (!gpuTexture) {
      return Promise.resolve(new Uint8Array(0));
    }
    if (flushRenderer) {
      this.flushFramebuffer();
    }
    return this._textureHelper.readPixels(gpuTexture, x, y, width, height, gpuTextureFormat, void 0, void 0, data);
  }
  //------------------------------------------------------------------------------
  //                              Frame management
  //------------------------------------------------------------------------------
  _measureFps() {
    this._performanceMonitor.sampleFrame();
    this._fps = this._performanceMonitor.averageFPS;
    this._deltaTime = this._performanceMonitor.instantaneousFrameTime || 0;
  }
  /**
   * Gets the performance monitor attached to this engine
   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#engineinstrumentation
   */
  get performanceMonitor() {
    return this._performanceMonitor;
  }
  /**
   * Begin a new frame
   */
  beginFrame() {
    this._measureFps();
    super.beginFrame();
  }
  /**
   * End the current frame
   */
  endFrame() {
    this._endCurrentRenderPass();
    this._snapshotRendering.endFrame();
    this._timestampQuery.endFrame(this._renderEncoder);
    this._timestampIndex = 0;
    this.flushFramebuffer();
    this._textureHelper.destroyDeferredTextures();
    this._bufferManager.destroyDeferredBuffers();
    if (this._features._collectUbosUpdatedInFrame) {
      if (this.dbgVerboseLogsForFirstFrames) {
        if (this._count === void 0) {
          this._count = 0;
        }
        if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {
          const list = [];
          for (const name3 in UniformBuffer._UpdatedUbosInFrame) {
            list.push(name3 + ":" + UniformBuffer._UpdatedUbosInFrame[name3]);
          }
          Logger.Log(["frame #" + this._count + " - updated ubos -", list.join(", ")]);
        }
      }
      UniformBuffer._UpdatedUbosInFrame = {};
    }
    this.countersLastFrame.numEnableEffects = this._counters.numEnableEffects;
    this.countersLastFrame.numEnableDrawWrapper = this._counters.numEnableDrawWrapper;
    this.countersLastFrame.numBundleCreationNonCompatMode = this._counters.numBundleCreationNonCompatMode;
    this.countersLastFrame.numBundleReuseNonCompatMode = this._counters.numBundleReuseNonCompatMode;
    this._counters.numEnableEffects = 0;
    this._counters.numEnableDrawWrapper = 0;
    this._counters.numBundleCreationNonCompatMode = 0;
    this._counters.numBundleReuseNonCompatMode = 0;
    this._cacheRenderPipeline.endFrame();
    this._cacheBindGroups.endFrame();
    this._pendingDebugCommands.length = 0;
    if (this.dbgVerboseLogsForFirstFrames) {
      if (this._count === void 0) {
        this._count = 0;
      }
      if (this._count < this.dbgVerboseLogsNumFrames) {
        Logger.Log(["%c frame #" + this._count + " - end", "background: #ffff00"]);
      }
      if (this._count < this.dbgVerboseLogsNumFrames) {
        this._count++;
        if (this._count !== this.dbgVerboseLogsNumFrames) {
          Logger.Log(["%c frame #" + this._count + " - begin", "background: #ffff00"]);
        }
      }
    }
    super.endFrame();
  }
  /**Gets driver info if available */
  extractDriverInfo() {
    return "";
  }
  /**
   * Force a WebGPU flush (ie. a flush of all waiting commands)
   */
  flushFramebuffer() {
    this._endCurrentRenderPass();
    this._commandBuffers[0] = this._uploadEncoder.finish();
    this._commandBuffers[1] = this._renderEncoder.finish();
    this._device.queue.submit(this._commandBuffers);
    this._uploadEncoder = this._device.createCommandEncoder(this._uploadEncoderDescriptor);
    this._renderEncoder = this._device.createCommandEncoder(this._renderEncoderDescriptor);
    this._timestampQuery.startFrame(this._uploadEncoder);
    this._textureHelper.setCommandEncoder(this._uploadEncoder);
    this._bundleList.reset();
  }
  /** @internal */
  _currentFrameBufferIsDefaultFrameBuffer() {
    return this._currentPassIsMainPass();
  }
  //------------------------------------------------------------------------------
  //                              Render Pass
  //------------------------------------------------------------------------------
  _startRenderTargetRenderPass(renderTargetWrapper, setClearStates, clearColor, clearDepth, clearStencil) {
    this._endCurrentRenderPass();
    const rtWrapper = renderTargetWrapper;
    const depthStencilTexture = rtWrapper._depthStencilTexture;
    const gpuDepthStencilWrapper = depthStencilTexture?._hardwareTexture;
    const gpuDepthStencilTexture = gpuDepthStencilWrapper?.underlyingResource;
    const gpuDepthStencilMSAATexture = gpuDepthStencilWrapper?.getMSAATexture(0);
    const depthTextureView = gpuDepthStencilTexture?.createView(this._rttRenderPassWrapper.depthAttachmentViewDescriptor);
    const depthMSAATextureView = gpuDepthStencilMSAATexture?.createView(this._rttRenderPassWrapper.depthAttachmentViewDescriptor);
    const depthTextureHasStencil = gpuDepthStencilWrapper ? WebGPUTextureHelper.HasStencilAspect(gpuDepthStencilWrapper.format) : false;
    const colorAttachments = [];
    if (this.useReverseDepthBuffer) {
      this.setDepthFunctionToGreaterOrEqual();
    }
    const clearColorForIntegerRT = tempColor4;
    if (clearColor) {
      clearColorForIntegerRT.r = clearColor.r * 255;
      clearColorForIntegerRT.g = clearColor.g * 255;
      clearColorForIntegerRT.b = clearColor.b * 255;
      clearColorForIntegerRT.a = clearColor.a * 255;
    }
    const mustClearColor = setClearStates && clearColor;
    const mustClearDepth = setClearStates && clearDepth;
    const mustClearStencil = setClearStates && clearStencil;
    if (rtWrapper._attachments && rtWrapper.isMulti) {
      if (!this._mrtAttachments || this._mrtAttachments.length === 0) {
        this._mrtAttachments = rtWrapper._defaultAttachments;
      }
      for (let i = 0; i < this._mrtAttachments.length; ++i) {
        const index = this._mrtAttachments[i];
        const mrtTexture = rtWrapper.textures[i];
        const gpuMRTWrapper = mrtTexture?._hardwareTexture;
        const gpuMRTTexture = gpuMRTWrapper?.underlyingResource;
        if (gpuMRTWrapper && gpuMRTTexture) {
          const baseArrayLayer = rtWrapper.getBaseArrayLayer(i);
          const gpuMSAATexture = gpuMRTWrapper.getMSAATexture(baseArrayLayer);
          const viewDescriptor = {
            ...this._rttRenderPassWrapper.colorAttachmentViewDescriptor,
            dimension: mrtTexture.is3D ? "3d" : "2d",
            format: gpuMRTWrapper.format,
            baseArrayLayer
          };
          const msaaViewDescriptor = {
            ...this._rttRenderPassWrapper.colorAttachmentViewDescriptor,
            dimension: mrtTexture.is3D ? "3d" : "2d",
            format: gpuMRTWrapper.format,
            baseArrayLayer: 0
          };
          const isRTInteger = mrtTexture.type === 7 || mrtTexture.type === 5;
          const colorTextureView = gpuMRTTexture.createView(viewDescriptor);
          const colorMSAATextureView = gpuMSAATexture?.createView(msaaViewDescriptor);
          colorAttachments.push({
            view: colorMSAATextureView ? colorMSAATextureView : colorTextureView,
            resolveTarget: gpuMSAATexture ? colorTextureView : void 0,
            depthSlice: mrtTexture.is3D ? rtWrapper.layerIndices?.[i] ?? 0 : void 0,
            clearValue: index !== 0 && mustClearColor ? isRTInteger ? clearColorForIntegerRT : clearColor : void 0,
            loadOp: index !== 0 && mustClearColor ? "clear" : "load",
            storeOp: "store"
          });
        }
      }
      this._cacheRenderPipeline.setMRT(rtWrapper.textures, this._mrtAttachments.length);
      this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);
    } else {
      const internalTexture = rtWrapper.texture;
      if (internalTexture) {
        const gpuWrapper = internalTexture._hardwareTexture;
        const gpuTexture = gpuWrapper.underlyingResource;
        let depthSlice = void 0;
        if (rtWrapper.is3D) {
          depthSlice = this._rttRenderPassWrapper.colorAttachmentViewDescriptor.baseArrayLayer;
          this._rttRenderPassWrapper.colorAttachmentViewDescriptor.baseArrayLayer = 0;
        }
        const gpuMSAATexture = gpuWrapper.getMSAATexture(0);
        const colorTextureView = gpuTexture.createView(this._rttRenderPassWrapper.colorAttachmentViewDescriptor);
        const colorMSAATextureView = gpuMSAATexture?.createView(this._rttRenderPassWrapper.colorAttachmentViewDescriptor);
        const isRTInteger = internalTexture.type === 7 || internalTexture.type === 5;
        colorAttachments.push({
          view: colorMSAATextureView ? colorMSAATextureView : colorTextureView,
          resolveTarget: gpuMSAATexture ? colorTextureView : void 0,
          depthSlice,
          clearValue: mustClearColor ? isRTInteger ? clearColorForIntegerRT : clearColor : void 0,
          loadOp: mustClearColor ? "clear" : "load",
          storeOp: "store"
        });
      } else {
        colorAttachments.push(null);
      }
    }
    this._debugPushGroup?.("render target pass" + (renderTargetWrapper.label ? " (" + renderTargetWrapper.label + ")" : ""), 0);
    this._rttRenderPassWrapper.renderPassDescriptor = {
      label: (renderTargetWrapper.label ?? "RTT") + " - RenderPass",
      colorAttachments,
      depthStencilAttachment: depthStencilTexture && gpuDepthStencilTexture ? {
        view: depthMSAATextureView ? depthMSAATextureView : depthTextureView,
        depthClearValue: mustClearDepth ? this.useReverseDepthBuffer ? this._clearReverseDepthValue : this._clearDepthValue : void 0,
        depthLoadOp: mustClearDepth ? "clear" : "load",
        depthStoreOp: "store",
        stencilClearValue: rtWrapper._depthStencilTextureWithStencil && mustClearStencil ? this._clearStencilValue : void 0,
        stencilLoadOp: !depthTextureHasStencil ? void 0 : rtWrapper._depthStencilTextureWithStencil && mustClearStencil ? "clear" : "load",
        stencilStoreOp: !depthTextureHasStencil ? void 0 : "store"
      } : void 0,
      occlusionQuerySet: this._occlusionQuery?.hasQueries ? this._occlusionQuery.querySet : void 0
    };
    this._timestampQuery.startPass(this._rttRenderPassWrapper.renderPassDescriptor, this._timestampIndex);
    this._currentRenderPass = this._renderEncoder.beginRenderPass(this._rttRenderPassWrapper.renderPassDescriptor);
    if (this.dbgVerboseLogsForFirstFrames) {
      if (this._count === void 0) {
        this._count = 0;
      }
      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {
        const internalTexture = rtWrapper.texture;
        Logger.Log([
          "frame #" + this._count + " - render target begin pass - rtt name=" + renderTargetWrapper.label + ", internalTexture.uniqueId=" + internalTexture.uniqueId + ", width=" + internalTexture.width + ", height=" + internalTexture.height + ", setClearStates=" + setClearStates,
          "renderPassDescriptor=",
          this._rttRenderPassWrapper.renderPassDescriptor
        ]);
      }
    }
    this._debugFlushPendingCommands?.();
    this._resetRenderPassStates();
    if (!gpuDepthStencilWrapper || !WebGPUTextureHelper.HasStencilAspect(gpuDepthStencilWrapper.format)) {
      this._stencilStateComposer.enabled = false;
    }
  }
  _startMainRenderPass(setClearStates, clearColor, clearDepth, clearStencil) {
    this._endCurrentRenderPass();
    if (this.useReverseDepthBuffer) {
      this.setDepthFunctionToGreaterOrEqual();
    }
    const mustClearColor = setClearStates && clearColor;
    const mustClearDepth = setClearStates && clearDepth;
    const mustClearStencil = setClearStates && clearStencil;
    this._mainRenderPassWrapper.renderPassDescriptor.colorAttachments[0].clearValue = mustClearColor ? clearColor : void 0;
    this._mainRenderPassWrapper.renderPassDescriptor.colorAttachments[0].loadOp = mustClearColor ? "clear" : "load";
    this._mainRenderPassWrapper.renderPassDescriptor.depthStencilAttachment.depthClearValue = mustClearDepth ? this.useReverseDepthBuffer ? this._clearReverseDepthValue : this._clearDepthValue : void 0;
    this._mainRenderPassWrapper.renderPassDescriptor.depthStencilAttachment.depthLoadOp = mustClearDepth ? "clear" : "load";
    this._mainRenderPassWrapper.renderPassDescriptor.depthStencilAttachment.stencilClearValue = mustClearStencil ? this._clearStencilValue : void 0;
    this._mainRenderPassWrapper.renderPassDescriptor.depthStencilAttachment.stencilLoadOp = !this.isStencilEnable ? void 0 : mustClearStencil ? "clear" : "load";
    this._mainRenderPassWrapper.renderPassDescriptor.occlusionQuerySet = this._occlusionQuery?.hasQueries ? this._occlusionQuery.querySet : void 0;
    const swapChainTexture = this._context.getCurrentTexture();
    this._mainRenderPassWrapper.colorAttachmentGPUTextures[0].set(swapChainTexture);
    if (this._options.antialias) {
      viewDescriptorSwapChainAntialiasing.format = swapChainTexture.format;
      this._mainRenderPassWrapper.renderPassDescriptor.colorAttachments[0].resolveTarget = swapChainTexture.createView(viewDescriptorSwapChainAntialiasing);
    } else {
      viewDescriptorSwapChain.format = swapChainTexture.format;
      this._mainRenderPassWrapper.renderPassDescriptor.colorAttachments[0].view = swapChainTexture.createView(viewDescriptorSwapChain);
    }
    if (this.dbgVerboseLogsForFirstFrames) {
      if (this._count === void 0) {
        this._count = 0;
      }
      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {
        Logger.Log([
          "frame #" + this._count + " - main begin pass - texture width=" + this._mainTextureExtends.width,
          " height=" + this._mainTextureExtends.height + ", setClearStates=" + setClearStates,
          "renderPassDescriptor=",
          this._mainRenderPassWrapper.renderPassDescriptor
        ]);
      }
    }
    this._debugPushGroup?.("main pass", 0);
    this._timestampQuery.startPass(this._mainRenderPassWrapper.renderPassDescriptor, this._timestampIndex);
    this._currentRenderPass = this._renderEncoder.beginRenderPass(this._mainRenderPassWrapper.renderPassDescriptor);
    this._setDepthTextureFormat(this._mainRenderPassWrapper);
    this._setColorFormat(this._mainRenderPassWrapper);
    this._debugFlushPendingCommands?.();
    this._resetRenderPassStates();
    if (!this._isStencilEnable) {
      this._stencilStateComposer.enabled = false;
    }
  }
  /**
   * Binds the frame buffer to the specified texture.
   * @param texture The render target wrapper to render to
   * @param faceIndex The face of the texture to render to in case of cube texture
   * @param requiredWidth The width of the target to render to
   * @param requiredHeight The height of the target to render to
   * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true
   * @param lodLevel defines the lod level to bind to the frame buffer
   * @param layer defines the 2d array index to bind to frame buffer to
   */
  bindFramebuffer(texture, faceIndex = 0, requiredWidth, requiredHeight, forceFullscreenViewport, lodLevel = 0, layer = 0) {
    const hardwareTexture = texture.texture?._hardwareTexture;
    if (this._currentRenderTarget) {
      this.unBindFramebuffer(this._currentRenderTarget);
    } else {
      this._endCurrentRenderPass();
    }
    this._currentRenderTarget = texture;
    const depthStencilTexture = this._currentRenderTarget._depthStencilTexture;
    this._rttRenderPassWrapper.colorAttachmentGPUTextures[0] = hardwareTexture;
    this._rttRenderPassWrapper.depthTextureFormat = depthStencilTexture ? WebGPUTextureHelper.GetWebGPUTextureFormat(-1, depthStencilTexture.format) : void 0;
    this._setDepthTextureFormat(this._rttRenderPassWrapper);
    this._setColorFormat(this._rttRenderPassWrapper);
    this._rttRenderPassWrapper.colorAttachmentViewDescriptor = {
      format: this._colorFormat,
      dimension: texture.is3D ? "3d" : "2d",
      mipLevelCount: 1,
      baseArrayLayer: texture.isCube ? layer * 6 + faceIndex : layer,
      baseMipLevel: lodLevel,
      arrayLayerCount: 1,
      aspect: "all"
    };
    this._rttRenderPassWrapper.depthAttachmentViewDescriptor = {
      format: this._depthTextureFormat,
      dimension: depthStencilTexture && depthStencilTexture.is3D ? "3d" : "2d",
      mipLevelCount: 1,
      baseArrayLayer: depthStencilTexture ? depthStencilTexture.isCube ? layer * 6 + faceIndex : layer : 0,
      baseMipLevel: 0,
      arrayLayerCount: 1,
      aspect: "all"
    };
    if (this.dbgVerboseLogsForFirstFrames) {
      if (this._count === void 0) {
        this._count = 0;
      }
      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {
        Logger.Log([
          "frame #" + this._count + " - bindFramebuffer - rtt name=" + texture.label + ", internalTexture.uniqueId=" + texture.texture?.uniqueId + ", face=" + faceIndex + ", lodLevel=" + lodLevel + ", layer=" + layer,
          "colorAttachmentViewDescriptor=",
          this._rttRenderPassWrapper.colorAttachmentViewDescriptor,
          "depthAttachmentViewDescriptor=",
          this._rttRenderPassWrapper.depthAttachmentViewDescriptor
        ]);
      }
    }
    if (this._cachedViewport && !forceFullscreenViewport) {
      this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);
    } else {
      if (!requiredWidth) {
        requiredWidth = texture.width;
        if (lodLevel) {
          requiredWidth = requiredWidth / Math.pow(2, lodLevel);
        }
      }
      if (!requiredHeight) {
        requiredHeight = texture.height;
        if (lodLevel) {
          requiredHeight = requiredHeight / Math.pow(2, lodLevel);
        }
      }
      this._viewport(0, 0, requiredWidth, requiredHeight);
    }
    this.wipeCaches();
  }
  /**
   * Unbind the current render target texture from the WebGPU context
   * @param texture defines the render target wrapper to unbind
   * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated
   * @param onBeforeUnbind defines a function which will be called before the effective unbind
   */
  unBindFramebuffer(texture, disableGenerateMipMaps = false, onBeforeUnbind) {
    const saveCRT = this._currentRenderTarget;
    this._currentRenderTarget = null;
    if (onBeforeUnbind) {
      onBeforeUnbind();
    }
    this._currentRenderTarget = saveCRT;
    this._endCurrentRenderPass();
    if (!disableGenerateMipMaps) {
      if (texture.isMulti) {
        this.generateMipMapsMultiFramebuffer(texture);
      } else {
        this.generateMipMapsFramebuffer(texture);
      }
    }
    this._currentRenderTarget = null;
    if (this.dbgVerboseLogsForFirstFrames) {
      if (this._count === void 0) {
        this._count = 0;
      }
      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {
        Logger.Log("frame #" + this._count + " - unBindFramebuffer - rtt name=" + texture.label + ", internalTexture.uniqueId=", texture.texture?.uniqueId);
      }
    }
    this._mrtAttachments = [];
    this._cacheRenderPipeline.setMRT([]);
    this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);
  }
  /**
   * Generates mipmaps for the texture of the (single) render target
   * @param texture The render target containing the texture to generate the mipmaps for
   */
  generateMipMapsFramebuffer(texture) {
    if (!texture.isMulti && texture.texture?.generateMipMaps && !texture.isCube) {
      this._generateMipmaps(texture.texture);
    }
  }
  /**
   * Resolves the MSAA texture of the (single) render target into its non-MSAA version.
   * Note that if "texture" is not a MSAA render target, no resolve is performed.
   * @param _texture The render target texture containing the MSAA texture to resolve
   */
  resolveFramebuffer(_texture) {
    throw new Error("resolveFramebuffer is not yet implemented in WebGPU!");
  }
  /**
   * Unbind the current render target and bind the default framebuffer
   */
  restoreDefaultFramebuffer() {
    if (this._currentRenderTarget) {
      this.unBindFramebuffer(this._currentRenderTarget);
    } else if (!this._currentRenderPass) {
      this._startMainRenderPass(false);
    }
    if (this._cachedViewport) {
      this.setViewport(this._cachedViewport);
    }
    this.wipeCaches();
  }
  //------------------------------------------------------------------------------
  //                              Render
  //------------------------------------------------------------------------------
  /**
   * @internal
   */
  _setColorFormat(wrapper) {
    const format = wrapper.colorAttachmentGPUTextures[0]?.format ?? null;
    this._cacheRenderPipeline.setColorFormat(format);
    if (this._colorFormat === format) {
      return;
    }
    this._colorFormat = format;
  }
  /**
   * @internal
   */
  _setDepthTextureFormat(wrapper) {
    this._cacheRenderPipeline.setDepthStencilFormat(wrapper.depthTextureFormat);
    if (this._depthTextureFormat === wrapper.depthTextureFormat) {
      return;
    }
    this._depthTextureFormat = wrapper.depthTextureFormat;
  }
  setDitheringState() {
  }
  setRasterizerState() {
  }
  /**
   * @internal
   */
  _executeWhenRenderingStateIsCompiled(pipelineContext, action) {
    action();
  }
  /**
   * @internal
   */
  bindSamplers() {
  }
  /** @internal */
  _getUnpackAlignement() {
    return 1;
  }
  /**
   * @internal
   */
  _bindTextureDirectly() {
    return false;
  }
  setStateCullFaceType(cullBackFaces, force = false) {
    const cullFace = this.cullBackFaces ?? cullBackFaces ?? true ? 1 : 2;
    if (this._depthCullingState.cullFace !== cullFace || force) {
      this._depthCullingState.cullFace = cullFace;
    }
  }
  /**
   * Set various states to the webGL context
   * @param culling defines culling state: true to enable culling, false to disable it
   * @param zOffset defines the value to apply to zOffset (0 by default)
   * @param force defines if states must be applied even if cache is up to date
   * @param reverseSide defines if culling must be reversed (CCW if false, CW if true)
   * @param cullBackFaces true to cull back faces, false to cull front faces (if culling is enabled)
   * @param stencil stencil states to set
   * @param zOffsetUnits defines the value to apply to zOffsetUnits (0 by default)
   */
  setState(culling, zOffset = 0, force, reverseSide = false, cullBackFaces, stencil, zOffsetUnits = 0) {
    if (this._depthCullingState.cull !== culling || force) {
      this._depthCullingState.cull = culling;
    }
    this.setStateCullFaceType(cullBackFaces, force);
    this.setZOffset(zOffset);
    this.setZOffsetUnits(zOffsetUnits);
    const frontFace = reverseSide ? this._currentRenderTarget ? 1 : 2 : this._currentRenderTarget ? 2 : 1;
    if (this._depthCullingState.frontFace !== frontFace || force) {
      this._depthCullingState.frontFace = frontFace;
    }
    this._stencilStateComposer.stencilMaterial = stencil;
  }
  _applyRenderPassChanges(bundleList) {
    const mustUpdateStencilRef = !this._stencilStateComposer.enabled ? false : this._mustUpdateStencilRef();
    const mustUpdateBlendColor = !this._alphaState.alphaBlend ? false : this._mustUpdateBlendColor();
    if (this._mustUpdateViewport()) {
      this._applyViewport(bundleList);
    }
    if (this._mustUpdateScissor()) {
      this._applyScissor(bundleList);
    }
    if (mustUpdateStencilRef) {
      this._applyStencilRef(bundleList);
    }
    if (mustUpdateBlendColor) {
      this._applyBlendColor(bundleList);
    }
  }
  _draw(drawType, fillMode, start, count, instancesCount) {
    const renderPass = this._getCurrentRenderPass();
    const bundleList = this._bundleList;
    this.applyStates();
    const webgpuPipelineContext = this._currentEffect._pipelineContext;
    this.bindUniformBufferBase(this._currentRenderTarget ? this._ubInvertY : this._ubDontInvertY, 0, WebGPUShaderProcessor.InternalsUBOName);
    if (webgpuPipelineContext.uniformBuffer) {
      webgpuPipelineContext.uniformBuffer.update();
      this.bindUniformBufferBase(webgpuPipelineContext.uniformBuffer.getBuffer(), 0, WebGPUShaderProcessor.LeftOvertUBOName);
    }
    if (this._snapshotRendering.play) {
      this._reportDrawCall();
      return;
    }
    if (!this.compatibilityMode && (this._currentDrawContext.isDirty(this._currentMaterialContext.updateId) || this._currentMaterialContext.isDirty || this._currentMaterialContext.forceBindGroupCreation)) {
      this._currentDrawContext.fastBundle = void 0;
    }
    const useFastPath = !this.compatibilityMode && this._currentDrawContext.fastBundle;
    let renderPass2 = renderPass;
    if (useFastPath || this._snapshotRendering.record) {
      this._applyRenderPassChanges(bundleList);
      if (!this._snapshotRendering.record) {
        this._counters.numBundleReuseNonCompatMode++;
        if (this._currentDrawContext.indirectDrawBuffer) {
          this._currentDrawContext.setIndirectData(count, instancesCount || 1, start);
        }
        bundleList.addBundle(this._currentDrawContext.fastBundle);
        this._reportDrawCall();
        return;
      }
      renderPass2 = bundleList.getBundleEncoder(this._cacheRenderPipeline.colorFormats, this._depthTextureFormat, this.currentSampleCount);
      bundleList.numDrawCalls++;
    }
    let textureState = 0;
    if (this._currentMaterialContext.hasFloatOrDepthTextures) {
      let bitVal = 1;
      for (let i = 0; i < webgpuPipelineContext.shaderProcessingContext.textureNames.length; ++i) {
        const textureName = webgpuPipelineContext.shaderProcessingContext.textureNames[i];
        const texture = this._currentMaterialContext.textures[textureName]?.texture;
        const textureIsDepth = texture && texture.format >= 13 && texture.format <= 18;
        if (texture?.type === 1 && !this._caps.textureFloatLinearFiltering || textureIsDepth) {
          textureState |= bitVal;
        }
        bitVal = bitVal << 1;
      }
    }
    this._currentMaterialContext.textureState = textureState;
    const pipeline = this._cacheRenderPipeline.getRenderPipeline(fillMode, this._currentEffect, this.currentSampleCount, textureState);
    const bindGroups = this._cacheBindGroups.getBindGroups(webgpuPipelineContext, this._currentDrawContext, this._currentMaterialContext);
    if (!this._snapshotRendering.record) {
      this._applyRenderPassChanges(!this.compatibilityMode ? bundleList : null);
      if (!this.compatibilityMode) {
        this._counters.numBundleCreationNonCompatMode++;
        renderPass2 = this._device.createRenderBundleEncoder({
          colorFormats: this._cacheRenderPipeline.colorFormats,
          depthStencilFormat: this._depthTextureFormat,
          sampleCount: WebGPUTextureHelper.GetSample(this.currentSampleCount)
        });
      }
    }
    renderPass2.setPipeline(pipeline);
    if (this._currentIndexBuffer) {
      renderPass2.setIndexBuffer(this._currentIndexBuffer.underlyingResource, this._currentIndexBuffer.is32Bits ? "uint32" : "uint16", 0);
    }
    const vertexBuffers = this._cacheRenderPipeline.vertexBuffers;
    for (let index = 0; index < vertexBuffers.length; index++) {
      const vertexBuffer = vertexBuffers[index];
      const buffer = vertexBuffer.effectiveBuffer;
      if (buffer) {
        renderPass2.setVertexBuffer(index, buffer.underlyingResource, vertexBuffer._validOffsetRange ? 0 : vertexBuffer.byteOffset);
      }
    }
    for (let i = 0; i < bindGroups.length; i++) {
      renderPass2.setBindGroup(i, bindGroups[i]);
    }
    const nonCompatMode = !this.compatibilityMode && !this._snapshotRendering.record;
    if (nonCompatMode && this._currentDrawContext.indirectDrawBuffer) {
      this._currentDrawContext.setIndirectData(count, instancesCount || 1, start);
      if (drawType === 0) {
        renderPass2.drawIndexedIndirect(this._currentDrawContext.indirectDrawBuffer, 0);
      } else {
        renderPass2.drawIndirect(this._currentDrawContext.indirectDrawBuffer, 0);
      }
    } else if (drawType === 0) {
      renderPass2.drawIndexed(count, instancesCount || 1, start, 0, 0);
    } else {
      renderPass2.draw(count, instancesCount || 1, start, 0);
    }
    if (nonCompatMode) {
      this._currentDrawContext.fastBundle = renderPass2.finish();
      bundleList.addBundle(this._currentDrawContext.fastBundle);
    }
    this._reportDrawCall();
  }
  /**
   * Draw a list of indexed primitives
   * @param fillMode defines the primitive to use
   * @param indexStart defines the starting index
   * @param indexCount defines the number of index to draw
   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)
   */
  drawElementsType(fillMode, indexStart, indexCount, instancesCount = 1) {
    this._draw(0, fillMode, indexStart, indexCount, instancesCount);
  }
  /**
   * Draw a list of unindexed primitives
   * @param fillMode defines the primitive to use
   * @param verticesStart defines the index of first vertex to draw
   * @param verticesCount defines the count of vertices to draw
   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)
   */
  drawArraysType(fillMode, verticesStart, verticesCount, instancesCount = 1) {
    this._currentIndexBuffer = null;
    this._draw(1, fillMode, verticesStart, verticesCount, instancesCount);
  }
  //------------------------------------------------------------------------------
  //                              Dispose
  //------------------------------------------------------------------------------
  /**
   * Dispose and release all associated resources
   */
  dispose() {
    this._isDisposed = true;
    this.hideLoadingUI();
    this._timestampQuery.dispose();
    this._mainTexture?.destroy();
    this._depthTexture?.destroy();
    this._textureHelper.destroyDeferredTextures();
    this._bufferManager.destroyDeferredBuffers();
    this._device.destroy();
    _CommonDispose(this, this._renderingCanvas);
    super.dispose();
  }
  //------------------------------------------------------------------------------
  //                              Misc
  //------------------------------------------------------------------------------
  /**
   * Gets the current render width
   * @param useScreen defines if screen size must be used (or the current render target if any)
   * @returns a number defining the current render width
   */
  getRenderWidth(useScreen = false) {
    if (!useScreen && this._currentRenderTarget) {
      return this._currentRenderTarget.width;
    }
    return this._renderingCanvas?.width ?? 0;
  }
  /**
   * Gets the current render height
   * @param useScreen defines if screen size must be used (or the current render target if any)
   * @returns a number defining the current render height
   */
  getRenderHeight(useScreen = false) {
    if (!useScreen && this._currentRenderTarget) {
      return this._currentRenderTarget.height;
    }
    return this._renderingCanvas?.height ?? 0;
  }
  //------------------------------------------------------------------------------
  //                              Errors
  //------------------------------------------------------------------------------
  /**
   * Get the current error code of the WebGPU context
   * @returns the error code
   */
  getError() {
    return 0;
  }
  //------------------------------------------------------------------------------
  //                              External Textures
  //------------------------------------------------------------------------------
  /**
   * Creates an external texture
   * @param video video element
   * @returns the external texture, or null if external textures are not supported by the engine
   */
  createExternalTexture(video) {
    const texture = new WebGPUExternalTexture(video);
    return texture;
  }
  /**
   * Sets an internal texture to the according uniform.
   * @param name The name of the uniform in the effect
   * @param texture The texture to apply
   */
  setExternalTexture(name3, texture) {
    if (!texture) {
      this._currentMaterialContext.setTexture(name3, null);
      return;
    }
    this._setInternalTexture(name3, texture);
  }
  //------------------------------------------------------------------------------
  //                              Samplers
  //------------------------------------------------------------------------------
  /**
   * Sets a texture sampler to the according uniform.
   * @param name The name of the uniform in the effect
   * @param sampler The sampler to apply
   */
  setTextureSampler(name3, sampler) {
    this._currentMaterialContext?.setSampler(name3, sampler);
  }
  //------------------------------------------------------------------------------
  //                              Storage Buffers
  //------------------------------------------------------------------------------
  /**
   * Creates a storage buffer
   * @param data the data for the storage buffer or the size of the buffer
   * @param creationFlags flags to use when creating the buffer (see undefined). The BUFFER_CREATIONFLAG_STORAGE flag will be automatically added
   * @param label defines the label of the buffer (for debug purpose)
   * @returns the new buffer
   */
  createStorageBuffer(data, creationFlags, label) {
    return this._createBuffer(data, creationFlags | 32, label);
  }
  /**
   * Updates a storage buffer
   * @param buffer the storage buffer to update
   * @param data the data used to update the storage buffer
   * @param byteOffset the byte offset of the data
   * @param byteLength the byte length of the data
   */
  updateStorageBuffer(buffer, data, byteOffset, byteLength) {
    const dataBuffer = buffer;
    if (byteOffset === void 0) {
      byteOffset = 0;
    }
    let view;
    if (byteLength === void 0) {
      if (data instanceof Array) {
        view = new Float32Array(data);
      } else if (data instanceof ArrayBuffer) {
        view = new Uint8Array(data);
      } else {
        view = data;
      }
      byteLength = view.byteLength;
    } else {
      if (data instanceof Array) {
        view = new Float32Array(data);
      } else if (data instanceof ArrayBuffer) {
        view = new Uint8Array(data);
      } else {
        view = data;
      }
    }
    this._bufferManager.setSubData(dataBuffer, byteOffset, view, 0, byteLength);
  }
  _readFromGPUBuffer(gpuBuffer, size, buffer, noDelay) {
    return new Promise((resolve, reject) => {
      const readFromBuffer = () => {
        gpuBuffer.mapAsync(1, 0, size).then(() => {
          const copyArrayBuffer = gpuBuffer.getMappedRange(0, size);
          let data = buffer;
          if (data === void 0) {
            data = new Uint8Array(size);
            data.set(new Uint8Array(copyArrayBuffer));
          } else {
            const ctor = data.constructor;
            data = new ctor(data.buffer);
            data.set(new ctor(copyArrayBuffer));
          }
          gpuBuffer.unmap();
          this._bufferManager.releaseBuffer(gpuBuffer);
          resolve(data);
        }, (reason) => {
          if (this.isDisposed) {
            resolve(new Uint8Array());
          } else {
            reject(reason);
          }
        });
      };
      if (noDelay) {
        this.flushFramebuffer();
        readFromBuffer();
      } else {
        this.onEndFrameObservable.addOnce(() => {
          readFromBuffer();
        });
      }
    });
  }
  /**
   * Read data from a storage buffer
   * @param storageBuffer The storage buffer to read from
   * @param offset The offset in the storage buffer to start reading from (default: 0)
   * @param size  The number of bytes to read from the storage buffer (default: capacity of the buffer)
   * @param buffer The buffer to write the data we have read from the storage buffer to (optional)
   * @param noDelay If true, a call to flushFramebuffer will be issued so that the data can be read back immediately and not in engine.onEndFrameObservable. This can speed up data retrieval, at the cost of a small perf penalty (default: false).
   * @returns If not undefined, returns the (promise) buffer (as provided by the 4th parameter) filled with the data, else it returns a (promise) Uint8Array with the data read from the storage buffer
   */
  readFromStorageBuffer(storageBuffer, offset, size, buffer, noDelay) {
    size = size || storageBuffer.capacity;
    const gpuBuffer = this._bufferManager.createRawBuffer(size, BufferUsage.MapRead | BufferUsage.CopyDst, void 0, "TempReadFromStorageBuffer");
    this._renderEncoder.copyBufferToBuffer(storageBuffer.underlyingResource, offset ?? 0, gpuBuffer, 0, size);
    return this._readFromGPUBuffer(gpuBuffer, size, buffer, noDelay);
  }
  /**
   * Read data from multiple storage buffers
   * @param storageBuffers The list of storage buffers to read from
   * @param offset The offset in the storage buffer to start reading from (default: 0). This is the same offset for all storage buffers!
   * @param size  The number of bytes to read from each storage buffer (default: capacity of the first buffer)
   * @param buffer The buffer to write the data we have read from the storage buffers to (optional). If provided, the buffer should be large enough to hold the data from all storage buffers!
   * @param noDelay If true, a call to flushFramebuffer will be issued so that the data can be read back immediately and not in engine.onEndFrameObservable. This can speed up data retrieval, at the cost of a small perf penalty (default: false).
   * @returns If not undefined, returns the (promise) buffer (as provided by the 4th parameter) filled with the data, else it returns a (promise) Uint8Array with the data read from the storage buffer
   */
  readFromMultipleStorageBuffers(storageBuffers, offset, size, buffer, noDelay) {
    size = size || storageBuffers[0].capacity;
    const gpuBuffer = this._bufferManager.createRawBuffer(size * storageBuffers.length, BufferUsage.MapRead | BufferUsage.CopyDst, void 0, "TempReadFromMultipleStorageBuffers");
    for (let i = 0; i < storageBuffers.length; i++) {
      this._renderEncoder.copyBufferToBuffer(storageBuffers[i].underlyingResource, offset ?? 0, gpuBuffer, i * size, size);
    }
    return this._readFromGPUBuffer(gpuBuffer, size * storageBuffers.length, buffer, noDelay);
  }
  /**
   * Sets a storage buffer in the shader
   * @param name Defines the name of the storage buffer as defined in the shader
   * @param buffer Defines the value to give to the uniform
   */
  setStorageBuffer(name3, buffer) {
    this._currentDrawContext?.setBuffer(name3, buffer?.getBuffer() ?? null);
  }
};
WebGPUEngine._GlslangDefaultOptions = {
  jsPath: `${Tools._DefaultCdnUrl}/glslang/glslang.js`,
  wasmPath: `${Tools._DefaultCdnUrl}/glslang/glslang.wasm`
};
WebGPUEngine._InstanceId = 0;

// node_modules/@babylonjs/core/Engines/engineFactory.js
var EngineFactory = class {
  /**
   * Creates an engine based on the capabilities of the underlying hardware
   * @param canvas Defines the canvas to use to display the result
   * @param options Defines the options passed to the engine to create the context dependencies
   * @returns a promise that resolves with the created engine
   */
  static async CreateAsync(canvas, options) {
    const supported = await WebGPUEngine.IsSupportedAsync;
    if (supported) {
      return WebGPUEngine.CreateAsync(canvas, options);
    }
    if (Engine.IsSupported) {
      return new Engine(canvas, void 0, options);
    }
    return new NullEngine(options);
  }
};

export {
  inlineScheduler,
  createYieldingScheduler,
  runCoroutine,
  runCoroutineSync,
  runCoroutineAsync,
  makeSyncFunction,
  makeAsyncFunction,
  IntersectionInfo,
  BoundingBox,
  BoundingSphere,
  BoundingInfo,
  SubMesh,
  VertexDataMaterialInfo,
  VertexData,
  TransformNode,
  _MeshCollisionData,
  AbstractMesh,
  AudioEngine,
  NullEngineOptions,
  NullEngine,
  _OcclusionDataStorage,
  InjectStartingAndEndingCode,
  ShaderCodeInliner,
  checkNonFloatVertexBuffers,
  PowerPreference,
  FeatureName,
  BufferMapState,
  BufferUsage,
  MapMode,
  TextureDimension,
  TextureUsage,
  TextureViewDimension,
  TextureAspect,
  TextureFormat,
  AddressMode,
  FilterMode,
  MipmapFilterMode,
  CompareFunction,
  ShaderStage,
  BufferBindingType,
  SamplerBindingType,
  TextureSampleType,
  StorageTextureAccess,
  CompilationMessageType,
  PipelineErrorReason,
  AutoLayoutMode,
  PrimitiveTopology,
  FrontFace,
  CullMode,
  ColorWrite,
  BlendFactor,
  BlendOperation,
  StencilOperation,
  IndexFormat,
  VertexFormat,
  VertexStepMode,
  ComputePassTimestampLocation,
  RenderPassTimestampLocation,
  LoadOp,
  StoreOp,
  QueryType,
  CanvasAlphaMode,
  CanvasToneMappingMode,
  DeviceLostReason,
  ErrorFilter,
  WebGPUShaderProcessor,
  WebGPUPipelineContext,
  WebGPUDataBuffer,
  WebGPUCacheSampler,
  WebGPUCacheRenderPipeline,
  WebGPUCacheRenderPipelineTree,
  ExternalTexture,
  WebGPUDrawContext,
  WebGPUCacheBindGroups,
  WebGPUTintWASM,
  WebGPURenderTargetWrapper,
  WebGPUEngine,
  EngineFactory
};
//# sourceMappingURL=chunk-JKQ4Y6O4.js.map
